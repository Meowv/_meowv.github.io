[{"title":"Python入门教程","date":"2017-12-06T02:49:27.000Z","path":"2017/12/06/python-tutorial/","text":"Python是由吉多·范罗苏姆(Guido Van Rossum)在90年代早期设计。它是如今最常用的编程 语言之一。它的语法简洁且优美，几乎就是可执行的伪代码。 注意：这篇教程是用Python3写的。 下面一起来学习吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575# 用井字符开头的是单行注释\"\"\" 多行字符串用三个引号 包裹，也常被用来做多 行注释\"\"\"###################################################### 1. 原始数据类型和运算符##################################################### 整数3 # =&gt; 3# 算术运算没有什么出乎意料的1 + 1 # =&gt; 28 - 1 # =&gt; 710 * 2 # =&gt; 20# 但是除法例外，会自动转换成浮点数35 / 5 # =&gt; 7.05 / 3 # =&gt; 1.6666666666666667# 整数除法的结果都是向下取整5 // 3 # =&gt; 15.0 // 3.0 # =&gt; 1.0 # 浮点数也可以-5 // 3 # =&gt; -2-5.0 // 3.0 # =&gt; -2.0# 浮点数的运算结果也是浮点数3 * 2.0 # =&gt; 6.0# 模除7 % 3 # =&gt; 1# x的y次方2**4 # =&gt; 16# 用括号决定优先级(1 + 3) * 2 # =&gt; 8# 布尔值TrueFalse# 用not取非not True # =&gt; Falsenot False # =&gt; True# 逻辑运算符，注意and和or都是小写True and False #=&gt; FalseFalse or True #=&gt; True# 整数也可以当作布尔值0 and 2 #=&gt; 0-5 or 0 #=&gt; -50 == False #=&gt; True2 == True #=&gt; False1 == True #=&gt; True# 用==判断相等1 == 1 # =&gt; True2 == 1 # =&gt; False# 用!=判断不等1 != 1 # =&gt; False2 != 1 # =&gt; True# 比较大小1 &lt; 10 # =&gt; True1 &gt; 10 # =&gt; False2 &lt;= 2 # =&gt; True2 &gt;= 2 # =&gt; True# 大小比较可以连起来！1 &lt; 2 &lt; 3 # =&gt; True2 &lt; 3 &lt; 2 # =&gt; False# 字符串用单引双引都可以\"这是个字符串\"'这也是个字符串'# 用加号连接字符串\"Hello \" + \"world!\" # =&gt; \"Hello world!\"# 字符串可以被当作字符列表\"This is a string\"[0] # =&gt; 'T'# 用.format来格式化字符串\"&#123;&#125; can be &#123;&#125;\".format(\"strings\", \"interpolated\")# 可以重复参数以节省时间\"&#123;0&#125; be nimble, &#123;0&#125; be quick, &#123;0&#125; jump over the &#123;1&#125;\".format(\"Jack\", \"candle stick\")#=&gt; \"Jack be nimble, Jack be quick, Jack jump over the candle stick\"# 如果不想数参数，可以用关键字\"&#123;name&#125; wants to eat &#123;food&#125;\".format(name=\"Bob\", food=\"lasagna\") #=&gt; \"Bob wants to eat lasagna\"# 如果你的Python3程序也要在Python2.5以下环境运行，也可以用老式的格式化语法\"%s can be %s the %s way\" % (\"strings\", \"interpolated\", \"old\")# None是一个对象None # =&gt; None# 当与None进行比较时不要用 ==，要用is。is是用来比较两个变量是否指向同一个对象。\"etc\" is None # =&gt; FalseNone is None # =&gt; True# None，0，空字符串，空列表，空字典都算是False# 所有其他值都是Truebool(0) # =&gt; Falsebool(\"\") # =&gt; Falsebool([]) #=&gt; Falsebool(&#123;&#125;) #=&gt; False###################################################### 2. 变量和集合##################################################### print是内置的打印函数print(\"I'm Python. Nice to meet you!\")# 在给变量赋值前不用提前声明# 传统的变量命名是小写，用下划线分隔单词some_var = 5some_var # =&gt; 5# 访问未赋值的变量会抛出异常# 参考流程控制一段来学习异常处理some_unknown_var # 抛出NameError# 用列表(list)储存序列li = []# 创建列表时也可以同时赋给元素other_li = [4, 5, 6]# 用append在列表最后追加元素li.append(1) # li现在是[1]li.append(2) # li现在是[1, 2]li.append(4) # li现在是[1, 2, 4]li.append(3) # li现在是[1, 2, 4, 3]# 用pop从列表尾部删除li.pop() # =&gt; 3 且li现在是[1, 2, 4]# 把3再放回去li.append(3) # li变回[1, 2, 4, 3]# 列表存取跟数组一样li[0] # =&gt; 1# 取出最后一个元素li[-1] # =&gt; 3# 越界存取会造成IndexErrorli[4] # 抛出IndexError# 列表有切割语法li[1:3] # =&gt; [2, 4]# 取尾li[2:] # =&gt; [4, 3]# 取头li[:3] # =&gt; [1, 2, 4]# 隔一个取一个li[::2] # =&gt;[1, 4]# 倒排列表li[::-1] # =&gt; [3, 4, 2, 1]# 可以用三个参数的任何组合来构建切割# li[始:终:步伐]# 用del删除任何一个元素del li[2] # li is now [1, 2, 3]# 列表可以相加# 注意：li和other_li的值都不变li + other_li # =&gt; [1, 2, 3, 4, 5, 6]# 用extend拼接列表li.extend(other_li) # li现在是[1, 2, 3, 4, 5, 6]# 用in测试列表是否包含值1 in li # =&gt; True# 用len取列表长度len(li) # =&gt; 6# 元组是不可改变的序列tup = (1, 2, 3)tup[0] # =&gt; 1tup[0] = 3 # 抛出TypeError# 列表允许的操作元组大都可以len(tup) # =&gt; 3tup + (4, 5, 6) # =&gt; (1, 2, 3, 4, 5, 6)tup[:2] # =&gt; (1, 2)2 in tup # =&gt; True# 可以把元组合列表解包，赋值给变量a, b, c = (1, 2, 3) # 现在a是1，b是2，c是3# 元组周围的括号是可以省略的d, e, f = 4, 5, 6# 交换两个变量的值就这么简单e, d = d, e # 现在d是5，e是4# 用字典表达映射关系empty_dict = &#123;&#125;# 初始化的字典filled_dict = &#123;\"one\": 1, \"two\": 2, \"three\": 3&#125;# 用[]取值filled_dict[\"one\"] # =&gt; 1# 用keys获得所有的键。因为keys返回一个可迭代对象，所以在这里把结果包在list里。我们下面会详细介绍可迭代。# 注意：字典键的顺序是不定的，你得到的结果可能和以下不同。list(filled_dict.keys()) # =&gt; [\"three\", \"two\", \"one\"]# 用values获得所有的值。跟keys一样，要用list包起来，顺序也可能不同。list(filled_dict.values()) # =&gt; [3, 2, 1]# 用in测试一个字典是否包含一个键\"one\" in filled_dict # =&gt; True1 in filled_dict # =&gt; False# 访问不存在的键会导致KeyErrorfilled_dict[\"four\"] # KeyError# 用get来避免KeyErrorfilled_dict.get(\"one\") # =&gt; 1filled_dict.get(\"four\") # =&gt; None# 当键不存在的时候get方法可以返回默认值filled_dict.get(\"one\", 4) # =&gt; 1filled_dict.get(\"four\", 4) # =&gt; 4# setdefault方法只有当键不存在的时候插入新值filled_dict.setdefault(\"five\", 5) # filled_dict[\"five\"]设为5filled_dict.setdefault(\"five\", 6) # filled_dict[\"five\"]还是5# 字典赋值filled_dict.update(&#123;\"four\":4&#125;) #=&gt; &#123;\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4&#125;filled_dict[\"four\"] = 4 # 另一种赋值方法# 用del删除del filled_dict[\"one\"] # 从filled_dict中把one删除# 用set表达集合empty_set = set()# 初始化一个集合，语法跟字典相似。some_set = &#123;1, 1, 2, 2, 3, 4&#125; # some_set现在是&#123;1, 2, 3, 4&#125;# 可以把集合赋值于变量filled_set = some_set# 为集合添加元素filled_set_add(5) # filled_set现在是&#123;1, 2, 3, 4, 5&#125;# &amp; 取交集other_set = &#123;3, 4, 5, 6&#125;filled_set &amp; other_set # =&gt; &#123;3, 4, 5&#125;# | 取并集filled_set | other_set # =&gt; &#123;1, 2, 3, 4, 5, 6&#125;# - 取补集&#123;1, 2, 3, 4&#125; - &#123;2, 3, 5&#125; # =&gt; &#123;1, 4&#125;# in 测试集合是否包含元素2 in filled_set # =&gt; True10 in filled_set # =&gt; False###################################################### 3. 流程控制和迭代器##################################################### 先随便定义一个变量some_var = 5# 这是一个if语句。注意缩进在Python里是有意义的# 打印出\"some_var比10小\"if some_var &gt; 10: print(\"some_var比10大\")elif some_var &lt; 10: # elif句是可选的 print(\"some_var比10小\")else: # else也是可选的 print(\"some_var就是10\")\"\"\"用for循环语句遍历列表打印: dog is a mammal cat is a mammal mouse is a mammal\"\"\"for animal in [\"dog\", \"cat\", \"moouse\"]: print(\"&#123;&#125; is a animal\".format(animal))\"\"\"\"range(number)\"返回数字列表从0到给的数字打印: 0 1 2 3\"\"\"for i in range(4): print(i)\"\"\"while循环直到条件不满足打印: 0 1 2 3\"\"\"x = 0while x &lt; 4: print(x) x += 1 # x = x + 1 的简写# 用try/except块处理异常状况try: # 用raise抛弃异常 raise IndexError(\"This is an index error\")except IndexError as e: pass # pass是无操作，但是应该在这里处理错误except (TypeError, NameError): pass # 可以同时处理不同类的错误else: # else语句是可选的，必须在所有的except之后 print(\"All good!\") # 只有当try运行完没有错误的时候这句才会运行# Python提供一个叫做可迭代(iterable)的基本抽象。一个可迭代对象是可以被当作序列# 的对象。比如说上面range返回的对象就是可迭代的。filled_dict = &#123;\"one\": 1, \"two\": 2, \"three\": 3&#125;our_iterable = filled_dic.keys()print(our_iterable) # =&gt; range(1,10) 是一个实现可迭代接口的对象# 可迭代对象可以遍历for i in our_iterable: print(i) # 打印 one, two, three# 但是不可以随机访问our_iterable[1] # 抛出TypeError# 可迭代对象知道怎么生成迭代器our_iterable = iter(our_iterable)# 迭代器是一个可以记住遍历的位置的对象# 用__next__可以取得下一个元素our_iterable.__next__() #=&gt; \"one\"# 再一次调用__next__时会记得位置our_iterator.__next__() #=&gt; \"two\"our_iterator.__next__() #=&gt; \"three\"# 当迭代器所有元素都取出后，会抛出StopIterationour_iterator.__next__() # 抛出StopIteration# 可以用list一次取出迭代器所有元素list(filled_dict.keys()) #=&gt; Returns [\"one\", \"two\", \"three\"]###################################################### 4. 函数##################################################### 用def定义新函数def add(x, y): print(\"x is &#123;&#125; and y is &#123;&#125;\".formatm(x, y)) return x + y 用return语句返回# 调用函数add(5, 6) # =&gt; 打印出\"x is 5 and y is 6\"并且返回11# 也可以用关键字参数来调用函数add(y=6, x=5) # 关键字参数可以用任何顺序#我们可以定义一个可变参数函数def varargs(*args): return argsvarargs(1, 2, 3) # =&gt; (1, 2, 3)# 我们也可以定义一个关键字可变参数函数def keyword_args(**kwargs): return kwargs# 看看结果是什么keyword_args(big=\"foot\", loch=\"ness\") # =&gt; &#123;\"big\": \"foot\", \"loch\": \"ness\"&#125;# 这两种可变参数可以混着用def all_the args(*args, **kwargs): print(args) print(kwargs)\"\"\"all_the_args(1, 2, a=3, b=4) prints: (1, 2) &#123;\"a\": 3, \"b\": 4&#125;\"\"\"# 调用可变参数函数时可以做跟上面相反的，用*展开序列，用**展开字典。args = (1, 2, 3, 4)kwargs = &#123;\"a\": 3, \"b\": 4&#125;all_the_args(*args) # 相当于 foo(1, 2, 3, 4)all_the_args(**kwargs) # 相当于 foo(a=3, b=4)all_the_args(*args, **kwargs) # 相当于 foo(1, 2, 3, 4, a=3, b=4)# 函数作用域x = 5def setX(num): # 局部作用域的x和全局作用域的x是不同的 x = num # =&gt; 43 print (x) # =&gt; 43def setGlobalX(num): global x print (x) # =&gt; 5 x = num #现在全局作用域的x被赋值 print (x) # =&gt; 6setX(43)setGlobalX(6)# 函数在Python是一等公民def create_adder(x): def adder(y): return x + y return adderadd_10 = create_adder(10)add_10(3) # =&gt; 13# 也有匿名函数(lambda x: x &gt; 2)(3) # =&gt; True# 内置的高阶函数map(add_10, [1, 2, 3]) # =&gt; [11, 12, 13]filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]) # =&gt; [6, 7]#用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。[add_10(i) for i in [1, 2, 3]] # =&gt; [11, 12, 13][x for x in [3, 4, 5, 6, 7] if x &gt; 5] # =&gt; [6, 7]###################################################### 5. 类##################################################### 定义一个继承object的类class Human(object): # 类属性，被所有此类的实例共用。 species = \"H. sapiens\" # 构造方法，当实例被初始化时调用。注意名字前后的双下划线，这是表名这个属 # 性或方法对Python有特殊意义，但是允许用户自定义。自己取名时不应该用这种格式 def __init__(self, name): # Assign the argument to the instance's name attribute self.name = name # 实例方法，第一个参数总是self，就是这个实例对象 def say(self, msg): return \"&#123;name&#125;: &#123;message&#125;\".format(name=self.name, message=msg) # 类方法，被所有此类的实例共用。第一个参数是这个类对象。 @classmethod def get_species(cls): return cls.species # 静态方法。调用时没有实例或类的绑定。 @staticmethod def grunt(): return \"*grunt*\"# 构造一个实例i = Human(name=\"Ian\")print(i.say(\"hi\")) # 打印出 \"Ian: hi\"j = Human(\"Joel\")print(j.say(\"hello\")) # 印出 \"Joel: hello\"# 调用一个类方法i.get_species() # =&gt; \"H. sapiens\"# 改一个共用的类属性Human.species = \"H. neanderthalensis\"i.get_species() # =&gt; \"H. neanderthalensis\"j.get_species() # =&gt; \"H. neanderthalensis\"# 调用静态方法Human.grunt() # =&gt; \"*grunt*\"###################################################### 6. 模块##################################################### 用import导入模块import mathprint(math.sqrt(16)) # =&gt; 4.0# 也可以从模块中导入个别值from math import ceil,floorprint(ceil(3.7)) # =&gt; 4.0print(floor(3.7)) # =&gt; 3.0# 可以导入一个模块中所有值# 警告：不建议这么做from math import *# 如此缩写模块名字import math as mmath.sqrt(16) == m.sqrt(16) # =&gt; True# Python模块其实就是普通的Python文件。# 你可以自己写，然后导入，模块的名字就是文件的名字。# 你可以这样列出一个模块里所有的值import mathdir(math)###################################################### 7. 高级用法##################################################### 用生成器(generators)方便的写惰性计算def double_numbers(iterable): for i in iterable: yield i + i# 生成器只有在需要时才计算下一个值。它们每一次循环只生成一个值，而不是把所有的# 值全部计算好。这意味着double_numbers不会生成大于15的数字。## range的返回值也是一个生成器，不然一个1到900000000的列表会花很多时间和内存。## 如果你想用一个Python的关键字当作变量，可以加一个下划线来区分。range_ = range(1, 900000000)# 当找到一个 &gt;= 30 的结果就会停for i in double_numbers(range_): print(i) if i &gt;= 30: break# 装饰器(decorators)# 这个例子中，beg装饰say# beg会先调用say。如果返回的say_please为真，beg会改变返回的字符串。from functools import wrapsdef beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return \"&#123;&#125; &#123;&#125;\".format(msg, \"Please! I am poor :(\") return msg return wrapper@begdef say(say_please=False): msg = \"Can you buy me a beer?\" return msg, say_pleaseprint(say()) # Can you buy me a beer?print(say(say_please=True)) # Can you buy me a beer? Please! I am poor :(","tags":[{"name":"Python","slug":"Python","permalink":"http://xj8c.cc/tags/Python/"},{"name":"入门教程","slug":"入门教程","permalink":"http://xj8c.cc/tags/入门教程/"}]},{"title":"正则表达式术语中英文对照表","date":"2017-10-13T01:37:20.000Z","path":"2017/10/13/Regex-chinese-english-comparison-table/","text":"术语中英文对照表 正则表达式 regular expressions 字符组 character classes 反义字符组 negated character classes 范围表达式法 range expressions 元字符 metacharacters 通配符 wildcard character 换行符 newline charactor 回车符 carriage return character 水平制表符 tab character 垂直制表符 vertical tab charecter 换页符 form feed character 空白符 whitespace 段终止符 paragraph terminator 行终止符 line terminator 单词字符 word characters 非单词字符 non-word characters 数字字符 digits 非数字字符 non-digits 字母数字字符 alphanumeric characters 量词 quantifiers 贪婪量词 greedy quantifiers 惰性量词 lazy quantifiers 位置 positions 锚 anchors 行开头 beginning of a line 行结尾 end of a line 单词边界 word boundaries 非单词边界 non-word boundaries 向前查找 lookahead 正向向前查找 positive lookahead 负向向前查找 negative lookahead 向后查找 lookbehind 正向向后查找 positive lookbehind 负向向后查找 negative lookbehind 分组 groups 捕获分组 capturing groups 非捕获分组 non-capturing groups 分支结构 alternations 反向引用 back references 回溯 backtracks 运算符 operators 优先级 priority level 修饰符 flags 全局匹配修饰符 global flag 忽略大小写修饰符 ingnoreCase flag 多行匹配修饰符 multiline flag","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"正则表达式速查表","date":"2017-10-12T10:01:07.000Z","path":"2017/10/12/Regex-cheat-sheet/","text":"字面量 模式 说明 字母、数字 匹配字面量本身。比如 /f/，匹配字母 &quot;f&quot;。 \\0 匹配 NUL 字符。 \\t 匹配水平制表符。 \\v 匹配垂直制表符。 \\n 匹配换行符。 \\r 匹配回车符。 \\f 匹配换页符。 \\xnn 匹配拉丁字符。比如 \\xOA 等价于 \\n。 \\uxxxx 匹配 Unicode 字符。比如 \\u2028 匹配行终止符，\\u2029 匹配段终止符。 \\cX 匹配 ctrl+X。比如 \\cI 匹配 ctrl+I，等价于 \\t。 [\\b] 匹配 Backspace 键（特殊记忆）。 字符组 模式 说明 [abc] 匹配 &quot;a&quot;、&quot;b&quot;、&quot;c&quot; 其中任何一个字符。 [a-d1-4] 匹配 &quot;a&quot;、&quot;b&quot;、&quot;c&quot;、&quot;d&quot;、&quot;1&quot;、&quot;2&quot;、&quot;3&quot;、&quot;4&quot; 其中任何一个字符。 [^abc] 匹配除了 &quot;a&quot;、&quot;b&quot;、&quot;c&quot; 之外的任何一个字符。 [^a-d1-4] 匹配除了 &quot;a&quot;、&quot;b&quot;、&quot;c&quot;、&quot;d&quot;、&quot;1&quot;、&quot;2&quot;、&quot;3&quot;、&quot;4&quot; 之外的任何一个字符。 . 通配符，匹配除了少数字符（\\n）之外的任意字符。 \\d 匹配数字，等价于 [0-9]。 \\D 匹配非数字，等价于 [^0-9]。 \\w 匹配单词字符，等价于 [a-zA-Z0-9_]。 \\W 匹配非单词字符，等价于 [^a-zA-Z0-9_]。 \\s 匹配空白符，等价于 [ \\t\\v\\n\\r\\f]。 \\S 匹配非空白符，等价于 [^ \\t\\v\\n\\r\\f]。 量词 模式 说明 {n,m} 连续出现 n 到 m 次。贪婪模式。 {n,} 至少连续出现 n 次。贪婪模式。 {n} 连续出现 n 次。贪婪模式。 ? 等价于 {0,1}。贪婪模式。 + 等价于 {1,}。贪婪模式。 * 等价于 {0,}。贪婪模式。 {n,m}? 连续出现 n 到 m 次。惰性模式。 {n,}? 至少连续出现 n 次。惰性模式。 {n}? 连续出现 n 次。惰性模式。 ?? 等价于 {0,1}?。惰性模式。 +? 等价于 {1,}?。惰性模式。 *? 等价于 {0,}?。惰性模式。 位置 模式 说明 ^ 匹配开头的位置，当正则有修饰符 m 时，表示匹配行开头位置。 $ 匹配结尾的位置，当正则有修饰符 m 时，表示匹配行结尾位置。 \\b 匹配单词边界，即，\\w 与 \\W、^ 与 \\w、\\w 与 $ 之间的位置。 \\B 匹配非单词边界，即，\\w 与 \\w、\\W 与 \\W、^ 与 \\W，\\W 与 $ 之间的位置。 (?=abc) 匹配 &quot;abc&quot; 前面的位置，即此位置后面匹配 &quot;abc&quot;。 (?!abc) 匹配非 &quot;abc&quot; 前面的位置，即此位置后面不匹配 &quot;abc&quot;。 括号的作用 模式 说明 (ab) 捕获型分组。把 &quot;ab&quot; 当成一个整体，比如 (ab)+ 表示 &quot;ab&quot; 至少连续出现一次。 (?:ab) 非捕获型分组。与 (ab) 的区别是，它不捕获数据。 (good&#124;nice) 捕获型分支结构。匹配 &quot;good&quot; 或 &quot;nice&quot;。 (?:good&#124;nice) 非捕获型分支结构。与 (good&#124;nice) 的区别是，它不捕获数据。 \\num 反向引用。比如 \\2，表示引用的是第二个括号里的捕获的数据。 修饰符 符号 说明 g 全局匹配，找到所有满足匹配的子串。 i 匹配过程中，忽略英文字母大小写。 m 多行匹配，把 ^ 和 $ 变成行开头和行结尾。 String相关实例方法 属性 方法作用说明 search 返回正则匹配到的第一个子串在目标字符串中的下标位置。 split 以正则匹配到的子串，对目标字符串进行切分。返回一个数组。 match 对目标字符串执行正则匹配操作，返回的匹配结果数组中包含具体的匹配信息。 replace 对目标字符串进行替换操作。正则是其第一个参数。返回替换后的字符串。 replace第二个参数中的特殊字符 字符 说明 $1,$2,…,$99 匹配第 1-99 个分组里捕获的文本 $&amp; 匹配到的子串文本 $` 匹配到的子串的左边文本 $&#39; 匹配到的子串的右边文本 $$ 美元符号 RegExp相关实例方法 属性 方法作用说明 test 判断目标字符串中是否有满足正则匹配的子串。返回布尔值。 exec 比 match 更强大的正则匹配操作。返回结果与 match 一致。 RegExp静态属性 属性 方法作用说明 $1,…,$9 最近一次第 1-9 个分组捕获的数据。 input 最近一次目标字符串，可以简写成 $_。 lastMatch 最近一次匹配的文本，可以简写成 $&amp;。 lastParen 最近一次捕获的文本，可以简写成 $+。 leftContext 目标字符串中 lastMatch 之前的文本，可以简写成 $`。 rightContext 目标字符串中 lastMatch 之后的文本，可以简写成 $&#39;。","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"正则表达式编程","date":"2017-10-12T05:30:33.000Z","path":"2017/10/12/Regex-7/","text":"第七章 正则表达式编程什么叫知识，能指导我们实践的东西才叫知识。 学习一样东西，如果不能使用，最多只能算作纸上谈兵。正则表达式的学习，也不例外。 掌握了正则表达式的语法后，下一步，也是关键的一步，就是在真实世界中使用它。 那么如何使用正则表达式呢？有哪些关键的点呢？本章就解决这个问题。 内容包括： 正则表达式的四种操作 相关 API 注意要点 真实案例 正则表达式的四种操作 正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。 有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。 进行任何相关操作，也需要宿主引擎相关 API 的配合使用。当然，在 JavaScript 中，相关 API 也不多。 验证验证是正则表达式最直接的应用，比如表单验证。 在说验证之前，先要说清楚匹配是什么概念。 所谓匹配，就是看目标字符串里是否有满足匹配的子串。因此，“匹配”的本质就是“查找”。 有没有匹配，是不是匹配上，判断是否的操作，即称为“验证”。 这里举一个例子，来看看如何使用相关 API 进行验证操作的。 比如，判断一个字符串中是否有数字。 使用 search： 1234var regex = /\\d/;var string = \"abc123\";console.log( !!~string.search(regex) );// =&gt; true 使用 test： 1234var regex = /\\d/;var string = \"abc123\";console.log( regex.test(string) );// =&gt; true 使用 match： 1234var regex = /\\d/;var string = \"abc123\";console.log( !!string.match(regex) );// =&gt; true 使用 exec： 1234var regex = /\\d/;var string = \"abc123\";console.log( !!regex.exec(string) );// =&gt; true 其中，最常用的是 test。 切分匹配上了，我们就可以进行一些操作，比如切分。 所谓“切分”，就是把目标字符串，切成一段一段的。在 JavaScript 中使用的是 split。 比如，目标字符串是 &quot;html,css,javascript&quot;，按逗号来切分： 1234var regex = /,/;var string = \"html,css,javascript\";console.log( string.split(regex) );// =&gt; [\"html\", \"css\", \"javascript\"] 又比如，如下的日期格式： 1232017/06/262017.06.262017-06-26 可以使用 split “切出”年月日： 1234567var regex = /\\D/;console.log( \"2017/06/26\".split(regex) );console.log( \"2017.06.26\".split(regex) );console.log( \"2017-06-26\".split(regex) );// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"]// =&gt; [\"2017\", \"06\", \"26\"] 提取虽然整体匹配上了，但有时需要提取部分匹配的数据。 此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关 API。 这里，还是以日期为例，提取出年月日。注意下面正则中的括号： 使用 match： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( string.match(regex) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 使用 exec： 1234var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";console.log( regex.exec(string) );// =&gt;[\"2017-06-26\", \"2017\", \"06\", \"26\", index: 0, input: \"2017-06-26\"] 使用 test： 12345var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";regex.test(string);console.log( RegExp.$1, RegExp.$2, RegExp.$3 );// =&gt; \"2017\" \"06\" \"26\" 使用 search： 12345var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";string.search(regex);console.log( RegExp.$1, RegExp.$2, RegExp.$3 );// =&gt; \"2017\" \"06\" \"26\" 使用 replace： 12345678var regex = /^(\\d&#123;4&#125;)\\D(\\d&#123;2&#125;)\\D(\\d&#123;2&#125;)$/;var string = \"2017-06-26\";var date = [];string.replace(regex, function (match, year, month, day) &#123; date.push(year, month, day);&#125;);console.log(date);// =&gt; [\"2017\", \"06\", \"26\"] 其中，最常用的是 match。 替换找，往往不是目的，通常下一步是为了替换。在 JavaScript 中，使用 replace 进行替换。 比如把日期格式，从 yyyy-mm-dd 替换成 yyyy/mm/dd： 1234var string = \"2017-06-26\";var today = new Date( string.replace(/-/g, \"/\") );console.log( today );// =&gt; Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间) 这里只是简单地应用了一下 replace。但，replace 方法很是强大的，是需要重点掌握的。 相关 API 注意要点 从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个： 123456String#searchString#splitString#matchString#replaceRegExp#testRegExp#exec 本章不打算详细地讲解它们的方方面面细节，具体可以参考《JavaScript 权威指南》的第三部分。本章重点列出一些容易忽视的地方，以飨读者。 search 和 match 的参数问题我们知道字符串实例的那 4 个方法参数都支持正则和字符串。 但 search 和 match，会把字符串转换为正则的。 12345678910111213141516171819var string = \"2017.06.27\";console.log( string.search(\".\") );// =&gt; 0//需要修改成下列形式之一console.log( string.search(\"\\\\.\") );console.log( string.search(/\\./) );// =&gt; 4// =&gt; 4console.log( string.match(\".\") );// =&gt; [\"2\", index: 0, input: \"2017.06.27\"]//需要修改成下列形式之一console.log( string.match(\"\\\\.\") );console.log( string.match(/\\./) );// =&gt; [\".\", index: 4, input: \"2017.06.27\"]// =&gt; [\".\", index: 4, input: \"2017.06.27\"]console.log( string.split(\".\") );// =&gt; [\"2017\", \"06\", \"27\"]console.log( string.replace(\".\", \"/\") );// =&gt; \"2017/06.27\" match 返回结果的格式问题match 返回结果的格式，与正则对象是否有修饰符 g 有关。 1234567var string = \"2017.06.27\";var regex1 = /\\b(\\d+)\\b/;var regex2 = /\\b(\\d+)\\b/g;console.log( string.match(regex1) );console.log( string.match(regex2) );// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; [\"2017\", \"06\", \"27\"] 没有 g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。 有 g，返回的是所有匹配的内容。 当没有匹配时，不管有无 g，都返回 null。 exec 比 match 更强大当正则没有 g 时，使用 match 返回的信息比较多。但是有 g 后，就没有关键的信息 index 了。 而 exec 方法就能解决这个问题，它能接着上一次匹配后继续匹配： 123456789101112131415161718var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"]// =&gt; 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"]// =&gt; 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例 lastIndex 属性，表示下一次匹配开始的位置。 比如第一次匹配了 &quot;2017&quot;，开始下标是 0，共 4 个字符，因此这次匹配结束的位置是 3，下一次开始匹配的位置是 4。 从上述代码看出，在使用 exec 时，经常需要配合使用 while 循环： 123456789var string = \"2017.06.27\";var regex2 = /\\b(\\d+)\\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [\"2017\", \"2017\", index: 0, input: \"2017.06.27\"] 4// =&gt; [\"06\", \"06\", index: 5, input: \"2017.06.27\"] 7// =&gt; [\"27\", \"27\", index: 8, input: \"2017.06.27\"] 10 修饰符 g，对 exex 和 test 的影响上面提到了正则实例的 lastIndex 属性，表示尝试匹配时，从字符串的 lastIndex 位开始去匹配。 字符串的四个方法，每次匹配时，都是从 0 开始的，即 lastIndex 属性始终不变。 而正则实例的两个方法 exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改 lastIndex。下面让我们以 test 为例，看看你是否会迷糊： 1234567var regex = /a/g;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 1// =&gt; true 3// =&gt; false 0 注意上面代码中的第三次调用 test，因为这一次尝试匹配，开始从下标 lastIndex，即 3 位置处开始查找，自然就找不到了。 如果没有 g，自然都是从字符串第 0 个字符处开始尝试匹配： 1234567var regex = /a/;console.log( regex.test(\"a\"), regex.lastIndex );console.log( regex.test(\"aba\"), regex.lastIndex );console.log( regex.test(\"ababc\"), regex.lastIndex );// =&gt; true 0// =&gt; true 0// =&gt; true 0 test 整体匹配时需要使用 ^ 和 $这个相对容易理解，因为 test 是看目标字符串中是否有子串匹配正则，即有部分匹配即可。 如果，要整体匹配，正则前后需要添加开头和结尾： 123456console.log( /123/.test(\"a123b\") );// =&gt; trueconsole.log( /^123$/.test(\"a123b\") );// =&gt; falseconsole.log( /^123$/.test(\"123\") );// =&gt; true split 相关注意事项split 方法看起来不起眼，但要注意的地方有两个的。 第一，它可以有第二个参数，表示结果数组的最大长度： 123var string = \"html,css,javascript\";console.log( string.split(/,/, 2) );// =&gt;[\"html\", \"css\"] 第二，正则使用分组时，结果数组中是包含分隔符的： 123var string = \"html,css,javascript\";console.log( string.split(/(,)/) );// =&gt;[\"html\", \",\", \"css\", \",\", \"javascript\"] replace 是很强大的《JavaScript 权威指南》认为 exec 是这 6 个 API 中最强大的，而我始终认为 replace 才是最强大的。因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。 总体来说 replace 有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。 当第二个参数是字符串时，如下的字符有特殊的含义： 属性 描述 $1,$2,…,$99 匹配第 1-99个 分组里捕获的文本 $&amp; 匹配到的子串文本 $ 匹配到的子串的左边文本 $&#39; 匹配到的子串的右边文本 $$ 美元符号 例如，把 &quot;2,3,5&quot;，变成 &quot;5=2+3&quot;： 123var result = \"2,3,5\".replace(/(\\d+),(\\d+),(\\d+)/, \"$3=$1+$2\");console.log(result);// =&gt; \"5=2+3\" 又例如，把 &quot;2,3,5&quot;，变成 &quot;222,333,555&quot;: 123var result = \"2,3,5\".replace(/(\\d+)/g, \"$&amp;$&amp;$&amp;\");console.log(result);// =&gt; \"222,333,555\" 再例如，把 &quot;2+3=5&quot;，变成 &quot;2+3=2+3=5=5&quot;: 123var result = \"2+3=5\".replace(/=/, \"$&amp;$`$&amp;$'$&amp;\");console.log(result);// =&gt; \"2+3=2+3=5=5\" 我们对最后这个进行一下说明。要把 &quot;2+3=5&quot;，变成 &quot;2+3=2+3=5=5&quot;，其实就是想办法把 = 替换成=2+3=5=，其中，$&amp; 匹配的是 =， $` 匹配的是 2+3，$\\’ 匹配的是 5。因此使用 “$&amp;$`$&amp;$’$&amp;” 便达成了目的。 当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么： 123456\"1234 2345 3456\".replace(/(\\d)\\d&#123;2&#125;(\\d)/g, function (match, $1, $2, index, input) &#123; console.log([match, $1, $2, index, input]);&#125;);// =&gt; [\"1234\", \"1\", \"4\", 0, \"1234 2345 3456\"]// =&gt; [\"2345\", \"2\", \"5\", 5, \"1234 2345 3456\"]// =&gt; [\"3456\", \"3\", \"6\", 10, \"1234 2345 3456\"] 此时我们可以看到 replace 拿到的信息，并不比 exec 少。 使用构造函数需要注意的问题一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 \\。 1234567var string = \"2017-06-27 2017.06.27 2017/06/27\";var regex = /\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;/g;console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"]regex = new RegExp(\"\\\\d&#123;4&#125;(-|\\\\.|\\\\/)\\\\d&#123;2&#125;\\\\1\\\\d&#123;2&#125;\", \"g\");console.log( string.match(regex) );// =&gt; [\"2017-06-27\", \"2017.06.27\", \"2017/06/27\"] 修饰符ES5 中修饰符，共 3 个： 修饰符 描述 g 全局匹配，即找到所有匹配的，单词是 global。 i 忽略字母大小写，单词是 ingoreCase。 i 多行匹配，只影响 ^ 和 $，二者变成行的概念，即行开头和行结尾。单词是 multiline。 当然正则对象也有相应的只读属性： 1234567var regex = /\\w/img;console.log( regex.global );console.log( regex.ignoreCase );console.log( regex.multiline );// =&gt; true// =&gt; true// =&gt; true source 属性正则实例对象属性，除了 global、ingnoreCase、multiline、lastIndex 属性之外，还有一个 source 属性。 它什么时候有用呢？ 比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么： 1234var className = \"high\";var regex = new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\");console.log( regex.source )// =&gt; (^|\\s)high(\\s|$) 即字符串\"(^|\\\\s)high(\\\\s|$)\" 构造函数属性构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是 $1,…,$9 之外，还有几个不太常用的属性（有兼容性问题）： 静态属性 描述 简写形式 RegExp.input 最近一次目标字符串 RegExp[&quot;$_&quot;] RegExp.lastMatch 最近一次匹配的文本 RegExp[&quot;$&amp;&quot;] RegExp.lastParen 最近一次捕获的文本 RegExp[&quot;$+&quot;] RegExp.leftContext 目标字符串中lastMatch之前的文本 RegExp[“$`”] RegExp.rightContext 目标字符串中lastMatch之后的文本 RegExp[&quot;$&#39;&quot;] 测试代码如下： 123456789101112131415161718var regex = /([abc])(\\d)/g;var string = \"a1b2c3d4e5\";string.match(regex);console.log( RegExp.input );console.log( RegExp[\"$_\"]);// =&gt; \"a1b2c3d4e5\"console.log( RegExp.lastMatch );console.log( RegExp[\"$&amp;\"] );// =&gt; \"c3\"console.log( RegExp.lastParen );console.log( RegExp[\"$+\"] );// =&gt; \"3\"console.log( RegExp.leftContext );console.log( RegExp[\"$`\"] );// =&gt; \"a1b2\"console.log( RegExp.rightContext );console.log( RegExp[\"$'\"] );// =&gt; \"d4e5\" 真实案例 使用构造函数生成正则表达式我们知道要优先使用字面量来创建正则，但有时正则表达式的主体是不确定的，此时可以使用构造函数来创建。模拟 getElementsByClassName 方法，就是很能说明该问题的一个例子。 这里 getElementsByClassName 函数的实现思路是： 比如要获取 className 为 &quot;high&quot; 的 dom 元素； 首先生成一个正则：/(^|\\s)high(\\s|$)/, 然后再用其逐一验证页面上的所有dom元素的类名，拿到满足匹配的元素即可。 代码如下(可以直接复制到本地查看运行效果)： 123456789101112131415161718192021&lt;p class=\"high\"&gt;1111&lt;/p&gt;&lt;p class=\"high\"&gt;2222&lt;/p&gt;&lt;p&gt;3333&lt;/p&gt;&lt;script&gt;function getElementsByClassName (className) &#123; var elements = document.getElementsByTagName(\"*\"); var regex = new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\"); var result = []; for (var i = 0; i &lt; elements.length; i++) &#123; var element = elements[i]; if (regex.test(element.className)) &#123; result.push(element) &#125; &#125; return result;&#125;var highs = getElementsByClassName('high');highs.forEach(function (item) &#123; item.style.color = 'red';&#125;);&lt;/script&gt; 使用字符串保存数据一般情况下，我们都愿意使用数组来保存数据。但我看到有的框架中，使用的却是字符串。 使用时，仍需要把字符串切分成数组。虽然不一定用到正则，但总感觉酷酷的，这里分享如下： 123456789var utils = &#123;&#125;;\"Boolean|Number|String|Function|Array|Date|RegExp|Object|Error\".split(\"|\").forEach(function (item) &#123; utils[\"is\" + item] = function (obj) &#123; return &#123;&#125;.toString.call(obj) == \"[object \" + item + \"]\"; &#125;;&#125;);console.log( utils.isArray([1, 2, 3]) );// =&gt; true if 语句中使用正则替代 &amp;&amp;比如，模拟 ready 函数，即加载完毕后再执行回调（不兼容 IE 的）： 123456789101112131415161718var readyRE = /complete|loaded|interactive/;function ready (callback) &#123; if (readyRE.test(document.readyState) &amp;&amp; document.body) &#123; callback() &#125; else &#123; document.addEventListener( 'DOMContentLoaded', function () &#123; callback() &#125;, false ); &#125;&#125;;ready(function () &#123; alert(\"加载完毕！\")&#125;); 使用强大的 replace因为 replace 方法比较强大，有时用它根本不是为了替换，只是拿其匹配到的信息来做文章。 这里以查询字符串（querystring）压缩技术为例，注意下面 replace 方法中，回调函数根本没有返回任何东西。 12345678910111213function compress (source) &#123; var keys = &#123;&#125;; source.replace(/([^=&amp;]+)=([^&amp;]*)/g, function (full, key, value) &#123; keys[key] = (keys[key] ? keys[key] + ',' : '') + value; &#125;); var result = []; for (var key in keys) &#123; result.push(key + '=' + keys[key]); &#125; return result.join('&amp;');&#125;console.log( compress(\"a=1&amp;b=2&amp;a=3&amp;b=4\") );// =&gt; \"a=1,3&amp;b=2,4\" 综合运用最后这里再做个简单实用的正则测试器。 具体效果如下： 代码，直接贴了，相信你能看得懂（代码改编于《JavaScript Regular Expressions》）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;section&gt; &lt;div id=\"err\"&gt;&lt;/div&gt; &lt;input id=\"regex\" placeholder=\"请输入正则表达式\"&gt; &lt;input id=\"text\" placeholder=\"请输入测试文本\"&gt; &lt;button id=\"run\"&gt;测试一下&lt;/button&gt; &lt;div id=\"result\"&gt;&lt;/div&gt;&lt;/section&gt;&lt;style&gt;section &#123; display: flex; flex-direction: column; justify-content: space-around; height: 300px; padding: 0 200px;&#125;section * &#123; min-height: 30px;&#125;#err &#123; color: red;&#125;#result &#123; line-height: 30px;&#125;.info &#123; background: #00c5ff; padding: 2px; margin: 2px; display: inline-block;&#125;&lt;/style&gt;&lt;script&gt;(function() &#123; // 获取相应dom元素 var regexInput = document.getElementById(\"regex\"); var textInput = document.getElementById(\"text\"); var runBtn = document.getElementById(\"run\"); var errBox = document.getElementById(\"err\"); var resultBox = document.getElementById(\"result\"); // 绑定点击事件 runBtn.onclick = function() &#123; // 清除错误和结果 errBox.innerHTML = \"\"; resultBox.innerHTML = \"\"; // 获取正则和文本 var text = textInput.value; var regex = regexInput.value; if (regex == \"\") &#123; errBox.innerHTML = \"请输入正则表达式\"; &#125; else if (text == \"\") &#123; errBox.innerHTML = \"请输入测试文本\"; &#125; else &#123; regex = createRegex(regex); if (!regex) return; var result, results = []; // 没有修饰符g的话，会死循环 if (regex.global) &#123; while (result = regex.exec(text)) &#123; results.push(result); &#125; &#125; else &#123; results.push(regex.exec(text)); &#125; if (results[0] == null) &#123; resultBox.innerHTML = \"匹配到0个结果\"; return; &#125; // 倒序是有必要的 for (var i = results.length - 1; i &gt;= 0; i--) &#123; var result = results[i]; var match = result[0]; var prefix = text.substr(0, result.index); var suffix = text.substr(result.index + match.length); text = prefix + '&lt;span class=\"info\"&gt;' + match + '&lt;/span&gt;' + suffix; &#125; resultBox.innerHTML = \"匹配到\" + results.length + \"个结果:&lt;br&gt;\" + text; &#125; &#125;; // 生成正则表达式，核心函数 function createRegex(regex) &#123; try &#123; if (regex[0] == \"/\") &#123; regex = regex.split(\"/\"); regex.shift(); var flags = regex.pop(); regex = regex.join(\"/\"); regex = new RegExp(regex, flags); &#125; else &#123; regex = new RegExp(regex, \"g\"); &#125; return regex; &#125; catch (e) &#123; errBox.innerHTML = \"无效的正则表达式\"; return false; &#125; &#125;&#125;)();&lt;/script&gt; 本章小结相关 API 的注意点，本章基本上算是一网打尽了。 至此，恭喜你，你学完了 JavaScript 正则表达式的所有内容。 纸上得来终觉浅，觉知此事要躬行。","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"正则表达式的构建","date":"2017-10-12T02:30:30.000Z","path":"2017/10/12/Regex-6/","text":"第六章 正则表达式的构建对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。 不仅要看懂别人的解决方案，也要能独立地解决问题。代码是这样，正则表达式也是这样。 与“读”相比，“写”往往更为重要，这个道理是不言而喻的。 对正则的运用，首重就是：如何针对问题，构建一个合适的正则表达式？ 本章就解决该问题，内容包括： 平衡法则 构建正则前提 准确性 效率 平衡法则 构建正则有一点非常重要，需要做到下面几点的平衡： 匹配预期的字符串 不匹配非预期的字符串 可读性和可维护性 效率 构建正则前提 是否能使用正则？正则太强大了，以至于我们随便遇到一个操作字符串问题时，都会下意识地去想，用正则该怎么做。但我们始终要提醒自己，正则虽然强大，但不是万能的，很多看似很简单的事情，还是做不到的。 比如匹配这样的字符串：1010010001…. 虽然很有规律，但是只靠正则就是无能为力。 是否有必要使用正则？要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。能用字符串 API 解决的简单问题，就不该正则出马。 比如，从日期中提取出年月日，虽然可以使用正则： 1234var string = \"2017-07-01\";var regex = /^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;console.log( string.match(regex) );// =&gt; [\"2017-07-01\", \"2017\", \"07\", \"01\", index: 0, input: \"2017-07-01\"] 其实，可以使用字符串的 split 方法来做，即可： 1234var string = \"2017-07-01\";var result = string.split(\"-\");console.log( result );// =&gt; [\"2017\", \"07\", \"01\"] 比如，判断是否有问号，虽然可以使用： 123var string = \"?id=xx&amp;act=search\";console.log( string.search(/\\?/) );// =&gt; 0 其实，可以使用字符串的 indexOf 方法： 123var string = \"?id=xx&amp;act=search\";console.log( string.indexOf(\"?\") );// =&gt; 0 比如获取子串，虽然可以使用正则： 123var string = \"JavaScript\";console.log( string.match(/.&#123;4&#125;(.+)/)[1] );// =&gt; Script 其实，可以直接使用字符串的 substring 或 substr 方法来做： 123var string = \"JavaScript\";console.log( string.substring(4) );// =&gt; Script 是否有必要构建一个复杂的正则？比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。 在第2章里，我们写出了正则是： /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/ 其实可以使用多个小正则来做： 1234567891011var regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/;var regex2 = /^[0-9]&#123;6,12&#125;$/;var regex3 = /^[A-Z]&#123;6,12&#125;$/;var regex4 = /^[a-z]&#123;6,12&#125;$/;function checkPassword (string) &#123; if (!regex1.test(string)) return false; if (regex2.test(string)) return false; if (regex3.test(string)) return false; if (regex4.test(string)) return false; return true;&#125; 准确性 所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。 这里提到了“预期”二字，那么我们就需要知道目标的组成规则。 不然没法界定什么样的目标字符串是符合预期的，什么样的又不是符合预期的。 下面将举例说明，当目标字符串构成比较复杂时，该如何构建正则，并考虑到哪些平衡。 匹配固定电话比如要匹配如下格式的固定电话号码： 1230551888888880551-88888888(0551)88888888 第一步，了解各部分的模式规则。 上面的电话，总体上分为区号和号码两部分（不考虑分机号和 &quot;+86&quot; 的情形）。 区号是 &quot;0&quot; 开头的 3 到 4 位数字，对应的正则是：0\\d{2,3}， 号码是非 &quot;0&quot; 开头的 7 到 8 位数字，对应的正则是：[1-9]\\d{6,7}， 因此，匹配 &quot;055188888888&quot; 的正则是：/^0\\d{2,3}[1-9]\\d{6,7}$/， 匹配 &quot;0551-88888888&quot; 的正则是：/^0\\d{2,3}-[1-9]\\d{6,7}$/， 匹配 &quot;(0551)88888888&quot; 的正则是：/^\\(0\\d{2,3}\\)[1-9]\\d{6,7}$/。 第二步，明确形式关系。 这三者情形是或的关系，可以构建分支： /^0\\d{2,3}[1-9]\\d{6,7}$|^0\\d{2,3}-[1-9]\\d{6,7}$|^\\(0\\d{2,3}\\)[1-9]\\d{6,7}$/ 提取公共部分： /^(0\\d{2,3}|0\\d{2,3}-|\\(0\\d{2,3}\\))[1-9]\\d{6,7}$/ 进一步简写： /^(0\\d{2,3}-?|\\(0\\d{2,3}\\))[1-9]\\d{6,7}$/ 其可视化形式： 上面的正则构建过程略显罗嗦，但是这样做，能保证正则是准确的。 上述三种情形是或的关系，这一点很重要，不然很容易按字符是否出现的情形把正则写成： /^\\(?0\\d{2,3}\\)?-?[1-9]\\d{6,7}$/ 虽然也能匹配上述目标字符串，但也会匹配 &quot;(0551-88888888&quot; 这样的字符串。当然，这不是我们想要的。 其实这个正则也不是完美的，因为现实中，并不是每个 3 位数和 4 位数都是一个真实的区号。 这就是一个平衡取舍问题，一般够用就行。 匹配浮点数要求匹配如下的格式： 1231.23、+1.23、-1.2310、+10、-10.2、+.2、-.2 可以看出正则分为三部分。 符号部分：[+-]， 整数部分：\\d+， 小数部分：\\.\\d+。 上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则： /^[-]?(\\d)?(\\.\\d+)?$/ 此正则看似没问题，但这个正则也会匹配空字符 &quot;&quot;。 因为目标字符串的形式关系不是要求每部分都是可选的。 要匹配 &quot;1.23&quot;、&quot;+1.23&quot;、&quot;-1.23&quot;，可以用/^[-]?\\d\\.\\d+$/， 要匹配 &quot;10&quot;、&quot;+10&quot;、&quot;-10&quot;，可以用/^[-]?\\d$/， 要匹配 &quot;.2&quot;、&quot;+.2&quot;、&quot;-.2&quot;，可以用/^[-]?\\.\\d$/。 因此整个正则是这三者的或的关系，提取公众部分后是： /^[-]?(\\d\\.\\d+|\\d+|\\.\\d+)$/ 其可视化形式是： 如果要求不匹配 &quot;+.2&quot; 和 &quot;-.2&quot;，此时正则变成： 当然，/^[-]?(\\d\\.\\d+|\\d+|\\.\\d+)$/ 也不是完美的，我们也是做了些取舍，比如： 它也会匹配 &quot;012&quot; 这样以 &quot;0&quot; 开头的整数。如果要求不匹配的话，需要修改整数部分的正则。一般进行验证操作之前，都要经过 trim 和判空。那样的话，也许那个错误正则也就够用了。也可以进一步改写成：/^[-]?(\\d)?(\\.)?\\d+$/，这样我们就需要考虑可读性和可维护性了。 效率 保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。 正则表达式的运行分为如下的阶段： 编译； 设定起始位置； 尝试匹配； 匹配失败的话，从下一位开始继续第 3 步； 最终结果：匹配成功或失败。 下面以代码为例，来看看这几个阶段都做了什么： 123456789var regex = /\\d+/g;console.log( regex.lastIndex, regex.exec(\"123abc34def\") );console.log( regex.lastIndex, regex.exec(\"123abc34def\") );console.log( regex.lastIndex, regex.exec(\"123abc34def\") );console.log( regex.lastIndex, regex.exec(\"123abc34def\") );// =&gt; 0 [\"123\", index: 0, input: \"123abc34def\"]// =&gt; 3 [\"34\", index: 6, input: \"123abc34def\"]// =&gt; 8 null// =&gt; 0 [\"123\", index: 0, input: \"123abc34def\"] 具体分析如下： var regex = /\\d+/g; 当生成一个正则时，引擎会对其进行编译。报错与否出现这这个阶段。 regex.exec(&quot;123abc34def&quot;) 当尝试匹配时，需要确定从哪一位置开始匹配。一般情形都是字符串的开头，即第 0 位。 但当使用 test 和 exec 方法，且正则有 g 时，起始位置是从正则对象的 lastIndex 属性开始。 因此第一次 exec 是从第 0 位开始，而第二次是从 3 开始的。 设定好起始位置后，就开始尝试匹配了。 比如第一次 exec，从 0 开始，去尝试匹配，并且成功地匹配到 3 个数字。此时结束时的下标是 2，因此下一次的起始位置是 3。 而第二次，起始下标是 3，但第 3 个字符是 &quot;a&quot;，并不是数字。但此时并不会直接报匹配失败，而是移动到下一位置，即从第 4 位开始继续尝试匹配，但该字符是 &quot;b&quot;，也不是数字。再移动到下一位，是 &quot;c&quot; 仍不行，再移动一位是数字 &quot;3&quot;，此时匹配到了两位数字 &quot;34&quot;。此时，下一次匹配的位置是 &quot;d&quot; 的位置，即第8 位。 第三次，是从第 8 位开始匹配，直到试到最后一位，也没发现匹配的，因此匹配失败，返回 null。同时设置 lastIndex 为 0，即，如要再尝试匹配的话，需从头开始。 从上面可以看出，匹配会出现效率问题，主要出现在上面的第 3 阶段和第 4 阶段。 因此，主要优化手法也是针对这两阶段的。 使用具体型字符组来代替通配符，来消除回溯而在第三阶段，最大的问题就是回溯。 例如，匹配双引用号之间的字符。如，匹配字符串 123&quot;abc&quot;456 中的 &quot;abc&quot;。 如果正则用的是：/&quot;.*&quot;/，会在第 3 阶段产生 4 次回溯（粉色表示 .* 匹配的内容）： 如果正则用的是：/&quot;.*?&quot;/，会产生 2 次回溯（粉色表示 .*? 匹配的内容）： 因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。 此时要使用具体化的字符组，来代替通配符.，以便消除不必要的字符，此时使用正则 /&quot;[^&quot;]*&quot;/，即可。 使用非捕获型分组因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。 当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。 例如，/^[-]?(\\d\\.\\d+|\\d+|\\.\\d+)$/ 可以修改成：/^[-]?(?:\\d\\.\\d+|\\d+|\\.\\d+)$/。 独立出确定字符例如，/a+/ 可以修改成 /aa*/。 因为后者能比前者多确定了字符 &quot;a&quot;。这样会在第四步中，加快判断是否匹配失败，进而加快移位的速度。 提取分支公共部分比如，/^abc|^def/ 修改成 /^(?:abc|def)/。 又比如， /this|that/修改成 /th(?:is|at)/。 这样做，可以减少匹配过程中可消除的重复。 减少分支的数量，缩小它们的范围/red|read/ 可以修改成 /rea?d/。 此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。 本章小结本章涉及的内容并不多。 一般情况下，针对某问题能写出一个满足需求的正则，基本上就可以了。 至于准确性和效率方面的追求，纯属看个人要求了。我觉得够用就行了。 关于准确性，本章关心的是最常用的解决思路： 针对每种情形，分别写出正则，然用分支把它们合并在一起，再提取分支公共部分，就能得到准确的正则。 至于优化，本章没有为了凑数，去写一大堆。了解了匹配原理，常见的优化手法也就这么几种。","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"正则表达式的拆分","date":"2017-10-11T05:12:10.000Z","path":"2017/10/11/Regex-5/","text":"第五章 正则表达式的拆分对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。 不仅要求自己能解决问题，还要看懂别人的解决方案。代码是这样，正则表达式也是这样。 正则这门语言跟其他语言有一点不同，它通常就是一大堆字符，而没有所谓“语句”的概念。 如何能正确地把一大串正则拆分成一块一块的，成为了破解“天书”的关键。 本章就解决这一问题，内容包括： 结构和操作符 注意要点 案例分析 结构和操作符 编程语言一般都有操作符。只要有操作符，就会出现一个问题。当一大堆操作在一起时，先操作谁，又后操作谁呢？为了不产生歧义，就需要语言本身定义好操作顺序，即所谓的优先级。 而在正则表达式中，操作符都体现在结构中，即由特殊字符和普通字符所代表的一个个特殊整体。 JavaScript 正则表达式中，都有哪些结构呢？ 字符字面量、字符组、量词、锚、分组、选择分支、反向引用。 具体含义简要回顾如下： 结构 说明 字面量 匹配一个具体字符，包括不用转义的和需要转义的。比如 a 匹配字符 &quot;a&quot;，又比如 \\n 匹配换行符，又比如 \\. 匹配小数点。 字符组 匹配一个字符，可以是多种可能之一，比如 [0-9]，表示匹配一个数字。也有 \\d 的简写形式。另外还有反义字符组，表示可以是除了特定字符之外任何一个字符，比如 [^0-9]，表示一个非数字字符，也有 \\D 的简写形式。 量词 表示一个字符连续出现，比如 a{1,3} 表示 &quot;a&quot; 字符连续出现 3 次。另外还有常见的简写形式，比如 a+ 表示 &quot;a&quot; 字符连续出现至少一次。 锚 匹配一个位置，而不是字符。比如 ^ 匹配字符串的开头，又比如 \\b 匹配单词边界，又比如 (?=\\d) 表示数字前面的位置。 分组 用括号表示一个整体，比如 (ab)+，表示 &quot;ab&quot; 两个字符连续出现多次，也可以使用非捕获分组 (?:ab)+。 分支 多个子表达式多选一，比如 abc&#124;bcd，表达式匹配 &quot;abc&quot; 或者 &quot;bcd&quot; 字符子串。反向引用，比如 \\2，表示引用第 2 个分组。 其中涉及到的操作符有： 操作符描述 操作符 优先级 转义符 \\ 1 括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 2 量词限定符 {m}、{m,n}、{m,}、?、*、+ 3 位置和序列 ^、$、\\元字符、一般字符 4 管道符（竖杠） &#124; 5 上面操作符的优先级从上至下，由高到低。 这里，我们来分析一个正则： /ab?(c|de*)+|fg/ 由于括号的存在，所以，(c|de*) 是一个整体结构。 在 (c|de*) 中，注意其中的量词 ，因此 e 是一个整体结构。 又因为分支结构 | 优先级最低，因此 c 是一个整体、而 de* 是另一个整体。 同理，整个正则分成了 a、b?、(…)+、f、g。而由于分支的原因，又可以分成 ab?(c|de*)+ 和 fg 这两部分。 希望你没被我绕晕，上面的分析可用其可视化形式描述如下： 注意要点 关于结构和操作符，还是有几点需要强调： 匹配字符串整体问题因为是要匹配整个字符串，我们经常会在正则前后中加上锚 ^ 和 $。 比如要匹配目标字符串 &quot;abc&quot; 或者 &quot;bcd&quot; 时，如果一不小心，就会写成 /^abc|bcd$/。 而位置字符和字符序列优先级要比竖杠高，故其匹配的结构是： 应该修改成: 量词连缀问题假设，要匹配这样的字符串： 每个字符为 “a、”b”、”c”任选其一， 字符串的长度是 3 的倍数。 此时正则不能想当然地写成 /^[abc]{3}+$/，这样会报错，说 + 前面没什么可重复的： 此时要修改成： 元字符转义问题所谓元字符，就是正则中有特殊含义的字符。 所有结构里，用到的元字符总结如下： ^、$、.、*、+、?、|、\\、/、(、)、[、]、{、}、=、!、:、- ，当匹配上面的字符本身时，可以一律转义： 1234var string = \"^$.*+?|\\\\/[]&#123;&#125;=!:-,\";var regex = /\\^\\$\\.\\*\\+\\?\\|\\\\\\/\\[\\]\\&#123;\\&#125;\\=\\!\\:\\-\\,/;console.log( regex.test(string) );// =&gt; true 其中 string 中的 \\ 字符也要转义的。 另外，在 string 中，也可以把每个字符转义，当然，转义后的结果仍是本身： 1234var string = \"^$.*+?|\\\\/[]&#123;&#125;=!:-,\";var string2 = \"\\^\\$\\.\\*\\+\\?\\|\\\\\\/\\[\\]\\&#123;\\&#125;\\=\\!\\:\\-\\,\";console.log( string == string2 );// =&gt; true 现在的问题是，是不是每个字符都需要转义呢？否，看情况。 字符组中的元字符跟字符组相关的元字符有 [、]、^、-。因此在会引起歧义的地方进行转义。例如开头的 ^ 必须转义，不然会把整个字符组，看成反义字符组。 1234var string = \"^$.*+?|\\\\/[]&#123;&#125;=!:-,\";var regex = /[\\^$.*+?|\\\\/\\[\\]&#123;&#125;=!:\\-,]/g;console.log( string.match(regex) );// =&gt; [\"^\", \"$\", \".\", \"*\", \"+\", \"?\", \"|\", \"\\\", \"/\", \"[\", \"]\", \"&#123;\", \"&#125;\", \"=\", \"!\", \":\",\"-\", \",\"] 匹配 &quot;[abc]&quot; 和 &quot;{3,5}&quot;我们知道 [abc]，是个字符组。如果要匹配字符串 &quot;[abc]&quot; 时，该怎么办？ 可以写成 /\\[abc\\]/，也可以写成 /\\[abc]/，测试如下： 1234var string = \"[abc]\";var regex = /\\[abc]/g;console.log( string.match(regex)[0] );// =&gt; \"[abc]\" 只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。 同理，要匹配字符串 &quot;{3,5}&quot;，只需要把正则写成 /\\{3,5}/ 即可。 另外，我们知道量词有简写形式 {m,}，却没有 {,n} 的情况。虽然后者不构成量词的形式，但此时并不会报错。当然，匹配的字符串也是 &quot;{,n}&quot;，测试如下： 1234var string = \"&#123;,3&#125;\";var regex = /&#123;,3&#125;/g;console.log( string.match(regex)[0] );// =&gt; \"&#123;,3&#125;\" 其余情况比如=、!、:、-、,等符号，只要不在特殊结构中，并不需要转义。 但是，括号需要前后都转义的，如 /\\(123\\)/。 至于剩下的 ^、$、.、*、+、?、|、\\、/ 等字符，只要不在字符组内，都需要转义的。 案例分析 接下来分析两个例子，一个简单的，一个复杂的。 身份证正则表达式是： /^(\\d{15}|\\d{17}[\\dxX])$/ 因为竖杠 | 的优先级最低，所以正则分成了两部分 \\d{15} 和 \\d{17}[\\dxX]。 \\d{15} 表示 15 位连续数字。 \\d{17}[\\dxX] 表示 17 位连续数字，最后一位可以是数字，可以大小写字母 &quot;x&quot;。 可视化如下： IPV4 地址正则表达式是： /^((0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5])$/ 这个正则，看起来非常吓人。但是熟悉优先级后，会立马得出如下的结构： ((…)\\.){3}(…) 其中，两个 (…) 是一样的结构。表示匹配的是 3 位数字。因此整个结构是 3位数.3位数.3位数.3位数 然后再来分析 (…)： (0{0,2}\\d|0?\\d{2}|1\\d{2}|2[0-4]\\d|25[0-5]) 它是一个多选结构，分成5个部分： 0{0,2}\\d，匹配一位数，包括 &quot;0&quot; 补齐的。比如，&quot;9&quot;、&quot;09&quot;、&quot;009&quot;； 0?\\d{2}，匹配两位数，包括 &quot;0&quot; 补齐的，也包括一位数； 1\\d{2}，匹配 &quot;100&quot; 到 &quot;199&quot;; 2[0-4]\\d，匹配 &quot;200&quot; 到 &quot;249&quot;； 25[0-5]，匹配 &quot;250&quot; 到 &quot;255&quot;。 最后来看一下其可视化形式： 本章小结掌握正则表达式中的优先级后，再看任何正则应该都有信心分析下去了。 至于例子，不一而足，没有写太多。 这里稍微总结一下，竖杠的优先级最低，即最后运算。 只要知道这一点，就能读懂大部分正则。 另外关于元字符转义问题，当自己不确定与否时，尽管去转义，总之是不会错的。","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"正则表达式回溯法原理","date":"2017-10-11T01:18:38.000Z","path":"2017/10/11/Regex-4/","text":"第四章 正则表达式回溯法原理学习正则表达式，是需要懂点儿匹配原理的。 而研究匹配原理时，有两个字出现的频率比较高：“回溯”。 听起来挺高大上，事实上却是一个比较容易理解的概念。 因此，本章就简单扼要地说清楚回溯到底是什么东西。 内容包括： 没有回溯的匹配 有回溯的匹配 常见的回溯形式 没有回溯的匹配 假设我们的正则是 /ab{1,3}c/，其可视化形式是： 而当目标字符串是 &quot;abbbc&quot; 时，就没有所谓的“回溯”。其匹配过程是： 其中子表达式 b{1,3} 表示 &quot;b&quot; 字符连续出现 1 到 3 次。 有回溯的匹配 如果目标字符串是”abbc”，中间就有回溯。 图中第 5 步有红颜色，表示匹配不成功。此时 b{1,3} 已经匹配到了 2 个字符 &quot;b&quot;，准备尝试第三个时，结果发现接下来的字符是 &quot;c&quot;。那么就认为 b{1,3} 就已经匹配完毕。然后状态又回到之前的状态（即第 6 步与第 4 步一样），最后再用子表达式 c，去匹配字符 &quot;c&quot;。当然，此时整个表达式匹配成功了。 图中的第 6 步，就是“回溯”。 你可能对此没有感觉，这里我们再举一个例子。正则是： 目标字符串是&quot;abbbc&quot;，匹配过程是： 其中第 7 步和第 10 步是回溯。第 7 步与第 4 步一样，此时 b{1,3} 匹配了两个 &quot;b&quot;，而第 10 步与第 3 步一样，此时 b{1,3} 只匹配了一个 &quot;b&quot;，这也是 b{1,3} 的最终匹配结果。 这里再看一个清晰的回溯，正则是： 目标字符串是：&quot;abc&quot;de，匹配过程是： 图中省略了尝试匹配双引号失败的过程。可以看出 .* 是非常影响效率的。 为了减少一些不必要的回溯，可以把正则修改为 /&quot;[^&quot;]*&quot;/。 常见的回溯形式 正则表达式匹配字符串的这种方式，有个学名，叫回溯法。 回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。 — 百度百科 本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。 道理，我们是懂了。那么 JavaScript 中正则表达式会产生回溯的地方都有哪些呢？ 贪婪量词之前的例子都是贪婪量词相关的。比如 b{1,3}，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试 &quot;bbb&quot;，然后再看整个正则是否能匹配。不能匹配时，吐出一个 “b”，即在 “bb” 的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。 虽然局部匹配是贪婪的，但也要满足整体能正确匹配。否则，皮之不存，毛将焉附？ 此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？ 答案是，先下手为强！因为深度优先搜索。测试如下： 1234var string = \"12345\";var regex = /(\\d&#123;1,3&#125;)(\\d&#123;1,3&#125;)/;console.log( string.match(regex) );// =&gt; [\"12345\", \"123\", \"45\", index: 0, input: \"12345\"] 其中，前面的 \\d{1,3} 匹配的是 &quot;123&quot;，后面的 \\d{1,3} 匹配的是 &quot;45&quot;。 惰性量词惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如： 1234var string = \"12345\";var regex = /(\\d&#123;1,3&#125;?)(\\d&#123;1,3&#125;)/;console.log( string.match(regex) );// =&gt; [\"1234\", \"1\", \"234\", index: 0, input: \"12345\"] 其中 \\d{1,3}? 只匹配到一个字符 &quot;1&quot;，而后面的 \\d{1,3} 匹配了 &quot;234&quot;。 虽然惰性量词不贪，但也会有回溯的现象。比如正则是： 目标字符串是”12345”，匹配过程是： 知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 \\d{1,3}? 匹配的字符是 &quot;12&quot;，是两个数字，而不是一个。 分支结构我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 &quot;candy&quot;，得到的结果是 &quot;can&quot;，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。 分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。 比如正则： 目标字符串是 &quot;candy&quot;，匹配过程： 上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是一种回溯的。 本章小结其实回溯法，很容易掌握的。 简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。 贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。 既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎, DFA 是“确定型有限自动机”的简写。 而 JavaScript 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。 大部分语言中的正则都是 NFA，为啥它这么流行呢？ 答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"正则表达式括号的作用","date":"2017-10-10T03:21:05.000Z","path":"2017/10/10/Regex-3/","text":"第三章 正则表达式括号的作用不管哪门语言中都有括号。正则表达式也是一门语言，而括号的存在使这门语言更为强大。 对括号的使用是否得心应手，是衡量对正则的掌握水平的一个侧面标准。 括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。 引用某个分组，会有两种情形：在 JavaScript 里引用它，在正则表达式里引用它。 本章内容虽相对简单，但我也要写长点。 内容包括： 分组和分支结构 分组引用 反向引用 非捕获括号 相关案例 分组和分支结构 这二者是括号最直觉的作用，也是最原始的功能，强调括号内的正则是一个整体，即提供子表达式。 分组我们知道 /a+/ 匹配连续出现的 &quot;a&quot;，而要匹配连续出现的 &quot;ab&quot; 时，需要使用 /(ab)+/。 其中括号是提供分组功能，使量词 + 作用于 &quot;ab&quot; 这个整体，测试如下： 1234var regex = /(ab)+/g;var string = \"ababa abbb ababab\";console.log( string.match(regex) );// =&gt; [\"abab\", \"ab\", \"ababab\"] 分支结构而在多选分支结构 (p1|p2) 中，此处括号的作用也是不言而喻的，提供了分支表达式的所有可能。 比如，要匹配如下的字符串： 12I love JavaScriptI love Regular Expression 可以使用正则： 12345var regex = /^I love (JavaScript|Regular Expression)$/;console.log( regex.test(\"I love JavaScript\") );console.log( regex.test(\"I love Regular Expression\") );// =&gt; true// =&gt; true 如果去掉正则中的括号，即： /^I love JavaScript|Regular Expression$/， 匹配字符串是 &quot;I love JavaScript&quot; 和 &quot;Regular Expression&quot;，当然这不是我们想要的。 分组引用 这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。 而要使用它带来的好处，必须配合使用实现环境的 API。 以日期为例。假设格式是 yyyy-mm-dd 的，我们可以先写一个简单的正则： 1var regex = /\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/; 其可视化形式是： 然后再修改成括号版的： 1var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/; 其可视化形式是： 对比这两个可视化图片，我们发现，与前者相比，后者多了分组编号，如 Group #1。 其实正则引擎也是这么做的，在匹配过程中，给每一个分组都开辟一个空间，用来存储每一个分组匹配到的数据。 既然分组可以捕获数据，那么我们就可以使用它们。 提取数据比如提取出年、月、日，可以这么做： 1234var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = \"2017-06-12\";console.log( string.match(regex) );// =&gt; [\"2017-06-12\", \"2017\", \"06\", \"12\", index: 0, input: \"2017-06-12\"] NOTE： match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match返回的数组格式是不一样的。 另外也可以使用正则实例对象的 exec 方法： 1234var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = \"2017-06-12\";console.log( regex.exec(string) );// =&gt; [\"2017-06-12\", \"2017\", \"06\", \"12\", index: 0, input: \"2017-06-12\"] 同时，也可以使用构造函数的全局属性 $1 至 $9 来获取： 12345678var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = \"2017-06-12\";regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // \"2017\"console.log(RegExp.$2); // \"06\"console.log(RegExp.$3); // \"12\" 替换比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？ 12345var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = \"2017-06-12\";var result = string.replace(regex, \"$2/$3/$1\");console.log(result);// =&gt; \"06/12/2017\" 其中 replace 中的，第二个参数里用 $1、$2、$3 指代相应的分组。等价于如下的形式： 1234567var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = \"2017-06-12\";var result = string.replace(regex, function () &#123; return RegExp.$2 + \"/\" + RegExp.$3 + \"/\" + RegExp.$1;&#125;);console.log(result);// =&gt; \"06/12/2017\" 也等价于： 1234567var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;var string = \"2017-06-12\";var result = string.replace(regex, function (match, year, month, day) &#123; return month + \"/\" + day + \"/\" + year;&#125;);console.log(result);// =&gt; \"06/12/2017\" 反向引用 除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。 还是以日期为例。 比如要写一个正则支持匹配如下三种格式： 1232016-06-122016/06/122016.06.12 最先可能想到的正则是: 123456789var regex = /\\d&#123;4&#125;(-|\\/|\\.)\\d&#123;2&#125;(-|\\/|\\.)\\d&#123;2&#125;/;var string1 = \"2017-06-12\";var string2 = \"2017/06/12\";var string3 = \"2017.06.12\";var string4 = \"2016-06/12\";console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // trueconsole.log( regex.test(string4) ); // true 其中 / 和 . 需要转义。虽然匹配了要求的情况，但也匹配 &quot;2016-06/12&quot; 这样的数据。 假设我们想要求分割符前后一致怎么办？此时需要使用反向引用： 123456789var regex = /\\d&#123;4&#125;(-|\\/|\\.)\\d&#123;2&#125;\\1\\d&#123;2&#125;/;var string1 = \"2017-06-12\";var string2 = \"2017/06/12\";var string3 = \"2017.06.12\";var string4 = \"2016-06/12\";console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // trueconsole.log( regex.test(string4) ); // false 其可视化形式是： 注意里面的 \\1，表示的引用之前的那个分组 (-|\\/|\\.)。不管它匹配到什么（比如 -），\\1 都匹配那个同样的具体某个字符。 我们知道了 \\1 的含义后，那么 \\2 和 \\3的概念也就理解了，即分别指代第二个和第三个分组。 看到这里，此时，恐怕你会有几个问题。 括号嵌套怎么办？以左括号（开括号）为准。比如： 1234567var regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;var string = \"1231231233\";console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 我们可以看看这个正则匹配模式： 第一个字符是数字，比如说 &quot;1&quot;， 第二个字符是数字，比如说 &quot;2&quot;， 第三个字符是数字，比如说 &quot;3&quot;， 接下来的是 \\1，是第一个分组内容，那么看第一个开括号对应的分组是什么，是 &quot;123&quot;， 接下来的是 \\2，找到第2个开括号，对应的分组，匹配的内容是 &quot;1&quot;， 接下来的是 \\3，找到第3个开括号，对应的分组，匹配的内容是 &quot;23&quot;， 最后的是 \\4，找到第3个开括号，对应的分组，匹配的内容是 &quot;3&quot;。 此正则的可视化形式是： \\10 表示什么呢？另外一个疑问可能是，即 \\10 是表示第 10 个分组，还是 \\1 和 0 呢？ 答案是前者，虽然一个正则里出现 \\10 比较罕见。测试如下： 1234var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\10+/;var string = \"123456789# ######\"console.log( regex.test(string) );// =&gt; true TIP： 如果真要匹配 \\1 和 0 的话，请使用 (?:\\1)0 或者 \\1(?:0)。 引用不存在的分组会怎样？因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如 \\2，就匹配 &quot;\\2&quot;。注意 &quot;\\2&quot; 表示对 &quot;2&quot; 进行了转义。 123var regex = /\\1\\2\\3\\4\\5\\6\\7\\8\\9/;console.log( regex.test(\"\\1\\2\\3\\4\\5\\6\\7\\8\\9\") );console.log( \"\\1\\2\\3\\4\\5\\6\\7\\8\\9\".split(\"\") ); Chrome 浏览器打印的结果： 分组后面有量词会怎样？分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。比如如下的测试案例： 1234var regex = /(\\d)+/;var string = \"12345\";console.log( string.match(regex) );// =&gt; [\"12345\", \"5\", index: 0, input: \"12345\"] 从上面看出，分组 (\\d) 捕获的数据是 &quot;5&quot;。 同理对于反向引用，也是这样的。测试如下： 12345var regex = /(\\d)+ \\1/;console.log( regex.test(\"12345 1\") );// =&gt; falseconsole.log( regex.test(\"12345 5\") );// =&gt; true 非捕获括号 之前文中出现的括号，都会捕获它们匹配到的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分支。 如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。 此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)，例如本章第一个例子可以修改为： 1234var regex = /(?:ab)+/g;var string = \"ababa abbb ababab\";console.log( string.match(regex) );// =&gt; [\"abab\", \"ab\", \"ababab\"] 同理，第二例子可以修改为： 12345var regex = /^I love (?:JavaScript|Regular Expression)$/;console.log( regex.test(\"I love JavaScript\") );console.log( regex.test(\"I love Regular Expression\") );// =&gt; true// =&gt; true 相关案例 至此括号的作用已经讲完了，总结一句话，就是提供了可供我们使用的分组，如何用就看我们的了。 字符串 trim 方法模拟trim 方法是去掉字符串的开头和结尾的空白符。有两种思路去做。 第一种，匹配到开头和结尾的空白符，然后替换成空字符。如： 12345function trim(str) &#123; return str.replace(/^\\s+|\\s+$/g, '');&#125;console.log( trim(\" foobar \") );// =&gt; \"foobar\" 第二种，匹配整个字符串，然后用引用来提取出相应的数据： 12345function trim (str) &#123; return str.replace(/^\\s*(.*?)\\s*$/g, \"$1\");&#125;console.log( trim(\" foobar \") );// =&gt; \"foobar\" 这里使用了惰性匹配 *?，不然也会匹配最后一个空格之前的所有空格的 当然，前者效率高。 将每个单词的首字母转换为大写1234567function titleize (str) &#123; return str.toLowerCase().replace(/(?:^|\\s)\\w/g, function (c) &#123; return c.toUpperCase(); &#125;);&#125;console.log( titleize('my name is epeli') );// =&gt; \"My Name Is Epeli\" 思路是找到每个单词的首字母，当然这里不使用非捕获匹配也是可以的。 驼峰化1234567function camelize (str) &#123; return str.replace(/[-_\\s]+(.)?/g, function (match, c) &#123; return c ? c.toUpperCase() : ''; &#125;);&#125;console.log( camelize('-moz-transform') );// =&gt; \"MozTransform\" 其中分组 (.) 表示首字母。单词的界定是，前面的字符可以是多个连字符、下划线以及空白符。正则后面的 ? 的目的，是为了应对 str 尾部的字符可能不是单词字符，比如 str 是 &#39;-moz-transform &#39;。 中划线化12345function dasherize (str) &#123; return str.replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase();&#125;console.log( dasherize('MozTransform') );// =&gt; \"-moz-transform\" 驼峰化的逆过程。 HTML 转义和反转义12345678910111213141516// 将HTML特殊字符转换成等值的实体function escapeHTML (str) &#123; var escapeChars = &#123; '&lt;' : 'lt', '&gt;' : 'gt', '\"' : 'quot', '&amp;' : 'amp', '\\'' : '#39' &#125;; return str.replace(new RegExp('[' + Object.keys(escapeChars).join('') +']', 'g'),function (match) &#123; return '&amp;' + escapeChars[match] + ';'; &#125;);&#125;console.log( escapeHTML('&lt;div&gt;Blah blah blah&lt;/div&gt;') );// =&gt; \"&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt\"; 其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本章没多大关系。 倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下： 12345678910111213141516171819// 实体字符转换为等值的HTML。function unescapeHTML (str) &#123; var htmlEntities = &#123; nbsp: ' ', lt: '&lt;', gt: '&gt;', quot: '\"', amp: '&amp;', apos: '\\'' &#125;; return str.replace(/\\&amp;([^;]+);/g, function (match, key) &#123; if (key in htmlEntities) &#123; return htmlEntities[key]; &#125; return match; &#125;);&#125;console.log( unescapeHTML('&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;') );// =&gt; \"&lt;div&gt;Blah blah blah&lt;/div&gt;\" 通过 key 获取相应的分组引用，然后作为对象的键。 匹配成对标签要求匹配： 12&lt;title&gt;regular expression&lt;/title&gt;&lt;p&gt;laoyao bye bye&lt;/p&gt; 不匹配： 1&lt;title&gt;wrong!&lt;/p&gt; 匹配一个开标签，可以使用正则 &lt;[^&gt;]+&gt;， 匹配一个闭标签，可以使用 &lt;\\/[^&gt;]+&gt;， 但是要求匹配成对标签，那就需要使用反向引用，如： 1234567var regex = /&lt;([^&gt;]+)&gt;[\\d\\D]*&lt;\\/\\1&gt;/;var string1 = \"&lt;title&gt;regular expression&lt;/title&gt;\";var string2 = \"&lt;p&gt;laoyao bye bye&lt;/p&gt;\";var string3 = \"&lt;title&gt;wrong!&lt;/p&gt;\";console.log( regex.test(string1) ); // trueconsole.log( regex.test(string2) ); // trueconsole.log( regex.test(string3) ); // false 其中开标签 &lt;[\\^&gt;]+&gt; 改成 &lt;([^&gt;]+)&gt;，使用括号的目的是为了后面使用反向引用，而提供分组。闭标签使用了反向引用，&lt;\\/\\1&gt;。 另外，[\\d\\D]的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。 本章小结重点理解括号可以提供分组，我们可以提取数据，应该就可以了。","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"正则表达式位置匹配攻略","date":"2017-09-29T07:52:50.000Z","path":"2017/09/29/Regex-2/","text":"第二章 正则表达式位置匹配攻略正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 然而大部分人学习正则时，对于匹配位置的重视程度没有那么高。 本章讲讲正则匹配位置的相关知识点。 内容包括： 什么是位置？ 如何匹配位置？ 位置的特性 几个应用实例分析 什么是位置呢？ 位置（锚）是相邻字符之间的位置。比如，下图中箭头所指的地方： 如何匹配位置呢？ 在 ES5 中，共有 6 个锚： ^、$、\\b、\\B、(?=p)、(?!p) 相应的可视化形式是： ^ 和 $^（脱字符）匹配开头，在多行匹配中匹配行开头。 $（美元符号）匹配结尾，在多行匹配中匹配行结尾。 比如我们把字符串的开头和结尾用 &quot;#&quot; 替换（位置可以替换成字符的！）： 123var result = \"hello\".replace(/^|$/g, '#');console.log(result);// =&gt; \"#hello#\" 多行匹配模式（即有修饰符 m）时，二者是行的概念，这一点需要我们注意： 1234567var result = \"I\\nlove\\njavascript\".replace(/^|$/gm, '#');console.log(result);/*#I##love##javascript#*/ \\b 和 \\B\\b 是单词边界，具体就是 \\w 与 \\W 之间的位置，也包括 \\w 与 ^ 之间的位置，和 \\w 与 $ 之间的位置。 比如考察文件名 &quot;[JS] Lesson_01.mp4&quot; 中的 \\b，如下： 123var result = \"[JS] Lesson_01.mp4\".replace(/\\b/g, '#');console.log(result);// =&gt; \"[#JS#] #Lesson_01#.#mp4#\" 为什么是这样呢？这需要仔细看看。 首先，我们知道，\\w 是字符组 [0-9a-zA-Z_] 的简写形式，即 \\w 是字母数字或者下划线的中任何一个字符。而 \\W 是排除字符组 [^0-9a-zA-Z_] 的简写形式，即 \\W 是 \\w 以外的任何一个字符。 此时我们可以看看 &quot;[#JS#] #Lesson_01#.#mp4#&quot; 中的每一个井号 ，是怎么来的。 第 1 个，两边字符是 &quot;[&quot; 与 &quot;J&quot;，是 \\W 与 \\w 之间的位置。 第 2 个，两边字符是 &quot;S&quot; 与 &quot;]&quot;，也就是 \\w 与 \\W 之间的位置。 第 3 个，两边字符是空格与 &quot;L&quot;，也就是 \\W 与 \\w 之间的位置。 第 4 个，两边字符是 &quot;1&quot; 与 &quot;.&quot;，也就是 \\w 与 \\W 之间的位置。 第 5 个，两边字符是 &quot;.&quot; 与 &quot;m&quot;，也就是 \\W 与 \\w之间的位置。 第 6 个，位于结尾，前面的字符 &quot;4&quot; 是 \\w，即 \\w 与 $ 之间的位置。 知道了 \\b 的概念后，那么 \\B 也就相对好理解了。 \\B 就是 \\b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \\b，剩下的都是 \\B 的。 具体说来就是 \\w 与 \\w、 \\W 与 \\W、^ 与 \\W，\\W 与 $ 之间的位置。 比如上面的例子，把所有 \\B 替换成 &quot;#&quot;： 123var result = \"[JS] Lesson_01.mp4\".replace(/\\B/g, '#');console.log(result);// =&gt; \"#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4\" (?=p) 和 (?!p)(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。 比如 (?=l)，表示 &quot;l&quot; 字符前面的位置，例如： 123var result = \"hello\".replace(/(?=l)/g, '#');console.log(result);// =&gt; \"he#l#lo\" 而 (?!p) 就是 (?=p) 的反面意思，比如： 123var result = \"hello\".replace(/(?!l)/g, '#');console.log(result);// =&gt; \"#h#ell#o#\" 二者的学名分别是 positive lookahead 和 negative lookahead。 中文翻译分别是正向先行断言和负向先行断言。 ES5 之后的版本，会支持 positive lookbehind 和 negative lookbehind。 具体是 (?&lt;=p) 和 (?&lt;!p)。 也有书上把这四个东西，翻译成环视，即看看右边和看看左边。 但一般书上，没有很好强调这四者是个位置。 比如 (?=p)，一般都理解成：要求接下来的字符与 p 匹配，但不能包括 p 匹配的那些字符。 而在本人看来，(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。 位置的特性 对于位置的理解，我们可以理解成空字符 &quot;&quot;。 比如 &quot;hello&quot; 字符串等价于如下的形式： &quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;o&quot; + &quot;&quot;; 也等价于： &quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot; 因此，把 /\\^hello$/ 写成 /^^hello$$$/，是没有任何问题的： 123var result = /^^hello$$$/.test(\"hello\");console.log(result);// =&gt; true 甚至可以写成更复杂的: 123var result = /(?=he)^^he(?=\\w)llo$\\b\\b$/.test(\"hello\");console.log(result);// =&gt; true 也就是说字符之间的位置，可以写成多个。 TIP： 把位置理解空字符，是对位置非常有效的理解方式。 相关案例 不匹配任何东西的正则让你写个正则不匹配任何东西 easy，/.^/。 因为此正则要求只有一个字符，但该字符后面是开头，而这样的字符串是不存在的 数字的千位分隔符表示法比如把 &quot;12345678&quot;，变成 &quot;12,345,678&quot;。 可见是需要把相应的位置替换成 &quot;,&quot;。 思路是什么呢？ 弄出最后一个逗号使用 (?=\\d{3}$) 就可以做到： 123var result = \"12345678\".replace(/(?=\\d&#123;3&#125;$)/g, ',')console.log(result);// =&gt; \"12345,678\" 其中，(?=\\d{3}$) 匹配 \\d{3}$ 前面的位置。而 \\d{3}$ 匹配的是目标字符串最后那 3 位数字。 弄出所有的逗号因为逗号出现的位置，要求后面 3 个数字一组，也就是 \\d{3} 至少出现一次。 此时可以使用量词 +： 123var result = \"12345678\".replace(/(?=(\\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; \"12,345,678\" 匹配其余案例写完正则后，要多验证几个案例，此时我们会发现问题： 123var result = \"123456789\".replace(/(?=(\\d&#123;3&#125;)+$)/g, ',')console.log(result);// =&gt; \",123,456,789\" 因为上面的正则，仅仅表示把从结尾向前数，一但是 3 的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。 怎么解决呢？我们要求匹配的到这个位置不能是开头。 我们知道匹配开头可以使用 ^，但要求这个位置不是开头怎么办？ easy，(?!^)，你想到了吗？测试如下： 12345678var regex = /(?!^)(?=(\\d&#123;3&#125;)+$)/g;var result = \"12345678\".replace(regex, ',')console.log(result);// =&gt; \"12,345,678\"result = \"123456789\".replace(regex, ',');console.log(result);// =&gt; \"123,456,789\" 支持其他形式如果要把 &quot;12345678 123456789&quot; 替换成 &quot;12,345,678 123,456,789&quot;。 此时我们需要修改正则，把里面的开头 ^ 和结尾 $，修改成 \\b： 123456var string = \"12345678 123456789\",regex = /(?!\\b)(?=(\\d&#123;3&#125;)+\\b)/g;var result = string.replace(regex, ',')console.log(result);// =&gt; \"12,345,678 123,456,789\" 其中 (?!\\b) 怎么理解呢？ 要求当前是一个位置，但不是 \\b 前面的位置，其实 (?!\\b) 说的就是 \\B。 因此最终正则变成了：/\\B(?=(\\d{3})+\\b)/g。 可视化形式是： 格式化千分符表示法一个常见的应用就是货币格式化。 比如把下面的字符串：1888 格式化成：$ 1,888.00 有了前面的铺垫，我们很容实现如下： 12345function format (num) &#123; return num.toFixed(2).replace(/\\B(?=(\\d&#123;3&#125;)+\\b)/, \",\").replace(/^/, \"$$ \");&#125;;console.log( format(1888) );// =&gt; \"$ 1,888.00\" 验证密码问题密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。 此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。 那么，我们就来挑战一下。看看我们对位置的理解是否深刻。 简化不考虑“但必须至少包括 2 种字符”这一条件。我们可以容易写出： 1var regex = /^[0-9A-Za-z]&#123;6,12&#125;$/; 判断是否包含有某一种字符假设，要求的必须包含数字，怎么办？此时我们可以使用 (?=.*[0-9]) 来做。 因此正则变成： 1var regex = /(?=.*[0-9])^[0-9A-Za-z]&#123;6,12&#125;$/; 同时包含具体两种字符比如同时包含数字和小写字母，可以用 (?=.[0-9])(?=.[a-z]) 来做。 因此正则变成： 1var regex = /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]&#123;6,12&#125;$/; 解答我们可以把原题变成下列几种情况之一： 同时包含数字和小写字母 同时包含数字和大写字母 同时包含小写字母和大写字母 同时包含数字、小写字母和大写字母 以上的 4 种情况是或的关系（实际上，可以不用第 4 条）。 最终答案是： 12345678var regex = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]&#123;6,12&#125;$/;console.log( regex.test(\"1234567\") ); // false 全是数字console.log( regex.test(\"abcdef\") ); // false 全是小写字母console.log( regex.test(\"ABCDEFGH\") ); // false 全是大写字母console.log( regex.test(\"ab23C\") ); // false 不足6位console.log( regex.test(\"ABCDEF234\") ); // true 大写字母和数字console.log( regex.test(\"abcdEF234\") ); // true 三者都有 可视化形式是： 解惑上面的正则看起来比较复杂，只要理解了第二步，其余就全部理解了。 /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/ 对于这个正则，我们只需要弄明白 (?=.*[0-9])^ 即可。 分开来看就是 (?=.*[0-9]) 和 ^。 表示开头前面还有个位置（当然也是开头，即同一个位置，想想之前的空字符类比）。 (?=.*[0-9]) 表示该位置后面的字符匹配 .*[0-9]，即，有任何多个任意字符，后面再跟个数字。 翻译成大白话，就是接下来的字符，必须包含个数字。 另外一种解法“至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。 那么要求“不能全部都是数字”，怎么做呢？ (?!p) 出马！ 对应的正则是： 1var regex = /(?!^[0-9]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/; 三种“都不能”呢？ 最终答案是： 1234567var regex = /(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/;console.log( regex.test(\"1234567\") ); // false 全是数字console.log( regex.test(\"abcdef\") ); // false 全是小写字母console.log( regex.test(\"ABCDEFGH\") ); // false 全是大写字母console.log( regex.test(\"ab23C\") ); // false 不足6位console.log( regex.test(\"ABCDEF234\") ); // true 大写字母和数字console.log( regex.test(\"abcdEF234\") ); // true 三者都有 其可视化形式是： 本章小结重点掌握匹配位置的这 6 个锚，给我们的解决正则问题工具箱内添加了新工具。","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"正则表达式字符匹配攻略","date":"2017-09-28T02:36:26.000Z","path":"2017/09/28/Regex-1/","text":"第一章 正则表达式字符匹配攻略正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。 然而关于正则如何匹配字符的学习，大部分人都觉得这块比较杂乱。 毕竟元字符太多了，看起来没有系统性，不好记。本章就解决这个问题。 内容包括： 两种模糊匹配 字符组 量词 分支结构 案例分析 两种模糊匹配 如果正则只有精确匹配是没多大意义的，比如 /hello/，也只能匹配字符串中的 &quot;hello&quot; 这个子串。 123var regex = /hello/;console.log(regex.test(\"hello\"));// =&gt; true 正则表达式之所以强大，是因为其能实现模糊匹配。 而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊。 横向模糊匹配横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。 其实现的方式是使用量词。譬如 {m,n}，表示连续出现最少 m 次，最多 n 次。 比如正则 /ab{2,5}c/ 表示匹配这样一个字符串：第一个字符是 &quot;a&quot;，接下来是 2 到 5 个字符 &quot;b&quot;，最后是字符 &quot;c&quot;。 其可视化形式如下： 测试如下： 1234var regex = /ab&#123;2,5&#125;c/g;var string = \"abc abbc abbbc abbbbc abbbbbc abbbbbbc\";console.log( string.match(regex) );// =&gt; [\"abbc\", \"abbbc\", \"abbbbc\", \"abbbbbc\"] NOTE： 案例中用的正则是 /ab{2,5}c/g，其中 g 是正则的一个修饰符。表示全局匹配，即，在目标字符串中按顺序找到满足匹配模式的所有子串，强调的是“所有”，而不只是“第一个”。g 是单词 global 的首字母。 纵向模糊匹配纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。 其实现的方式是使用字符组。譬如 [abc]，表示该字符是可以字符 &quot;a&quot;、&quot;b&quot;、&quot;c&quot; 中的任何一个。 比如 /a[123]b/ 可以匹配如下三种字符串： &quot;a1b&quot;、&quot;a2b&quot;、&quot;a3b&quot;。 其可视化形式如下： 测试如下： 1234var regex = /a[123]b/g;var string = \"a0b a1b a2b a3b a4b\";console.log( string.match(regex) );// =&gt; [\"a1b\", \"a2b\", \"a3b\"] 以上就是本章讲的主体内容，只要掌握横向和纵向模糊匹配，就能解决很大部分正则匹配问题。 接下来，我们将具体展开来说。 字符组 需要强调的是，虽叫字符组（字符类），但只是其中一个字符。 例如 [abc]，表示匹配一个字符，它可以是 &quot;a&quot;、&quot;b&quot;、&quot;c&quot; 之一。 范围表示法如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。 比如 [123456abcdefGHIJKLM]，可以写成 [1-6a-fG-M]。用连字符 - 来省略和简写。 因为连字符有特殊用途，那么要匹配 &quot;a&quot;、&quot;-&quot;、&quot;z&quot; 这三者中任意一个字符，该怎么做呢？ 不能写成 [a-z]，因为其表示小写字符中的任何一个字符。 可以写成如下的方式：[-az] 或 [az-] 或 [a\\-z]。 即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。 排除字符组纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 &quot;a&quot;、&quot;b&quot;、&quot;c&quot;。 此时就是排除字符组（反义字符组）的概念。例如 [^abc]，表示是一个除 &quot;a&quot;、&quot;b&quot;、&quot;c&quot;之外的任意一个字符。字符组的第一位放 ^（脱字符），表示求反的概念。 当然，也有相应的范围表示法。 常见的简写形式有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。 字符组 具体含义 \\d 表示 [0-9]。表示是一位数字。记忆方式：其英文是 digit（数字）。 \\D 表示 [^0-9]。表示除数字外的任意字符。 \\w 表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。记忆方式：w 是 word 的简写，也称单词字符。 \\W 表示 [^0-9a-zA-Z_]。非单词字符。 \\s 表示 [ \\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s 是 space 的首字母，空白符的单词是 white space。 \\S 表示 [^ \\t\\v\\n\\r\\f]。 非空白符。 . 表示 [^\\n\\r\\u2028\\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号 … 中的每个点，都可以理解成占位符，表示任何类似的东西。 如果要匹配任意字符怎么办？可以使用 [\\d\\D]、[\\w\\W]、[\\s\\S] 和 [^] 中任何的一个。 以上各字符组对应的可视化形式是： 量词 量词也称重复。掌握 {m,n} 的准确含义后，只需要记住一些简写形式。 简写形式 量词 具体含义 {m,} 表示至少出现 m 次。 {m} 等价于 {m,m}，表示出现 m 次。 ? 等价于 {0,1}，表示出现或者不出现。记忆方式：问号的意思表示，有吗？ + 等价于 {1,}，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。 * 等价于 {0,}，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 以上量词对应的可视化形式是： 贪婪匹配与惰性匹配看如下的例子： 1234var regex = /\\d&#123;2,5&#125;/g;var string = \"123 1234 12345 123456\";console.log( string.match(regex) );// =&gt; [\"123\", \"1234\", \"12345\", \"12345\"] 其中正则 /\\d{2,5}/，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字。 但是其是贪婪的，它会尽可能多的匹配。你能给我 6 个，我就要 5 个。你能给我 3 个，我就要 3 个。反正只要在能力范围内，越多越好。 我们知道有时贪婪不是一件好事（请看文章最后一个例子）。而惰性匹配，就是尽可能少的匹配： 1234var regex = /\\d&#123;2,5&#125;?/g;var string = \"123 1234 12345 123456\";console.log( string.match(regex) );// =&gt; [\"12\", \"12\", \"34\", \"12\", \"34\", \"12\", \"34\", \"56\"] 其中 /\\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。 通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下： 惰性量词 贪婪量词 {m,n}? {m,n} {m,}? {m,} ?? ? +? + *? * TIP： 对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？ 以上惰性量词对应的可视化形式是： 多选分支 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。 具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。 例如要匹配字符串 &quot;good&quot; 和 &quot;nice&quot; 可以使用 /good|nice/。 可视化形式如下： 测试如下： 1234var regex = /good|nice/g;var string = \"good idea, nice try.\";console.log( string.match(regex) );// =&gt; [\"good\", \"nice\"] 但有个事实我们应该注意，比如我用 /good|goodbye/，去匹配 &quot;goodbye&quot; 字符串时，结果是 &quot;good&quot;： 1234var regex = /good|goodbye/g;var string = \"goodbye\";console.log( string.match(regex) );// =&gt; [\"good\"] 而把正则改成 /goodbye|good/，结果是： 1234var regex = /goodbye|good/g;var string = \"goodbye\";console.log( string.match(regex) );// =&gt; [\"goodbye\"] 也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。 案例分析 匹配字符，无非就是字符组、量词和分支结构的组合使用罢了。 下面找几个例子演练一下（其中，每个正则并不是只有唯一写法）： 匹配 16 进制颜色值要求匹配： 1234#ffbbad#Fc01DF#FFF#ffE 分析： 表示一个 16 进制字符，可以用字符组 [0-9a-fA-F]。 其中字符可以出现 3 或 6 次，需要是用量词和分支结构。 使用分支结构时，需要注意顺序。 正则如下： 1234var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;var string = \"#ffbbad #Fc01DF #FFF #ffE\";console.log( string.match(regex) );// =&gt; [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"] 其可视化形式： 匹配时间以 24 小时制为例。 要求匹配： 1223:5902:07 分析： 共 4 位数字，第一位数字可以为 [0-2]。 当第 1 位为 &quot;2&quot; 时，第 2 位可以为 [0-3]，其他情况时，第 2 位为 [0-9]。 第 3 位数字为 [0-5]，第4位为 [0-9]。 正则如下： 12345var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;console.log( regex.test(\"23:59\") );console.log( regex.test(\"02:07\") );// =&gt; true// =&gt; true NOTE： 正则中使用了 ^ 和 $，分别表示字符串开头和结尾。具体详细请参考第二章。 如果也要求匹配 &quot;7:9&quot;，也就是说时分前面的 &quot;0&quot; 可以省略。 此时正则变成： 1234567var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;console.log( regex.test(\"23:59\") );console.log( regex.test(\"02:07\") );console.log( regex.test(\"7:9\") );// =&gt; true// =&gt; true// =&gt; true 其可视化形式： 匹配日期比如 yyyy-mm-dd 格式为例。 要求匹配： 2017-06-10 分析： 年，四位数字即可，可用 [0-9]{4}。 月，共 12 个月，分两种情况 &quot;01&quot;、&quot;02&quot;、…、&quot;09&quot; 和 &quot;10&quot;、&quot;11&quot;、&quot;12&quot;，可用 (0[1-9]|1[0-2])。 日，最大 31 天，可用 (0[1-9]|[12][0-9]|3[01])。 正则如下： 123var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;console.log( regex.test(\"2017-06-10\") );// =&gt; true 其可视化形式： window 操作系统文件路径要求匹配： 1234F:\\study\\javascript\\regex\\regular expression.pdfF:\\study\\javascript\\regex\\F:\\study\\javascriptF:\\ 分析： 整体模式是: 盘符:\\文件夹\\文件夹\\文件夹\\ 其中匹配 &quot;F:\\&quot;，需要使用 [a-zA-Z]:\\\\，其中盘符不区分大小写，注意 \\ 字符需要转义。 文件名或者文件夹名，不能包含一些特殊字符，此时我们需要排除字符组 [^\\\\:*&lt;&gt;|&quot;?\\r\\n/] 来表示合法字符。 另外它们的名字不能为空名，至少有一个字符，也就是要使用量词 +。因此匹配 文件夹\\，可用[^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\。 另外 文件夹\\，可以出现任意次。也就是 ([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+\\\\)*。其中括号表示其内部正则是一个整体。具体详细请参考第三章。 路径的最后一部分可以是 文件夹，没有 \\，因此需要添加 ([^\\\\:*&lt;&gt;|&quot;?\\r\\n/]+)?。 最后拼接成了一个看起来比较复杂的正则： 123456789var regex = /^[a-zA-Z]:\\\\([^\\\\:*&lt;&gt;|\"?\\r\\n/]+\\\\)*([^\\\\:*&lt;&gt;|\"?\\r\\n/]+)?$/;console.log( regex.test(\"F:\\\\study\\\\javascript\\\\regex\\\\regular expression.pdf\") );console.log( regex.test(\"F:\\\\study\\\\javascript\\\\regex\\\\\") );console.log( regex.test(\"F:\\\\study\\\\javascript\") );console.log( regex.test(\"F:\\\\\") );// =&gt; true// =&gt; true// =&gt; true// =&gt; true 其中，在JavaScript 中字符串要表示字符 \\ 时，也需要转义。 其可视化形式： 匹配 id要求从 1&lt;div id=\"container\" class=\"main\"&gt;&lt;/div&gt; 提取出 id=&quot;container&quot;。 可能最开始想到的正则是： 1234var regex = /id=\".*\"/var string = '&lt;div id=\"container\" class=\"main\"&gt;&lt;/div&gt;';console.log(string.match(regex)[0]);// =&gt; id=\"container\" class=\"main\" 其可视化形式： 因为 . 是通配符，本身就匹配双引号的，而量词 * 又是贪婪的，当遇到 container 后面双引号时，是不会停下来，会继续匹配，直到遇到最后一个双引号为止。 解决之道，可以使用惰性匹配： 1234var regex = /id=\".*?\"/var string = '&lt;div id=\"container\" class=\"main\"&gt;&lt;/div&gt;';console.log(string.match(regex)[0]);// =&gt; id=\"container\" 当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下： 1234var regex = /id=\"[^\"]*\"/var string = '&lt;div id=\"container\" class=\"main\"&gt;&lt;/div&gt;';console.log(string.match(regex)[0]);// =&gt; id=\"container\" 本章小结掌握字符组和量词就能解决大部分常见的情形，也就是说，当你会了这二者，JavaScript 正则算是入门了。","tags":[{"name":"Regex","slug":"Regex","permalink":"http://xj8c.cc/tags/Regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://xj8c.cc/tags/正则表达式/"}]},{"title":"今日头条全站新闻文章数据爬取","date":"2017-09-27T06:23:48.000Z","path":"2017/09/27/ToutiaoNews/","text":"今日头条全站新闻文章数据爬取url:https://www.toutiao.com/api/pc/feed/ 拼接参数： category：见下category表格 utm_source： widen： max_behot_time： max_behot_time_tmp： tadrequire： as： cp： category 列表 标签 category值 推荐 __all__ 热点 news_hot 科技 news_tech 社会 news_society 娱乐 news_entertainment 游戏 news_game 体育 news_sports 汽车 news_car 财经 news_finance 搞笑 funny 段子 essay_joke 军事 news_military 国际 news_world 时尚 news_fashion 旅游 news_travel 探索 news_discovery 育儿 news_baby 养生 news_regimen 美文 news_essay 历史 news_history 美食 news_food … … json接口示例:https://www.toutiao.com/api/pc/feed/?category=news_hot 源代码下载ToutiaoNews","tags":[{"name":"今日头条","slug":"今日头条","permalink":"http://xj8c.cc/tags/今日头条/"},{"name":"爬虫","slug":"爬虫","permalink":"http://xj8c.cc/tags/爬虫/"},{"name":"HtmlAgilityPack","slug":"HtmlAgilityPack","permalink":"http://xj8c.cc/tags/HtmlAgilityPack/"},{"name":"Newtonsoft.Json","slug":"Newtonsoft-Json","permalink":"http://xj8c.cc/tags/Newtonsoft-Json/"}]},{"title":"HtmlAgilityPack爬取美女图片、每日一文文章、小说","date":"2017-09-07T01:23:53.000Z","path":"2017/09/07/HtmlAgilityPack/","text":"HtmlAgilityPack？HtmlAgilityPack 是 .NET 下的一个 HTML 解析类库。支持用 XPath 来解析 HTML 。命名空间： HtmlAgilityPack 爬取美女图片核心代码12345678910111213141516171819202122232425static void Main(string[] args)&#123; HtmlWeb web = new HtmlWeb(); string path = @&quot;F:\\pic\\&quot;; for (int i = 88; i &gt;= 1; i--) &#123; var url = &quot;http://jandan.net/ooxx/page-&quot; + i; HtmlDocument doc = web.Load(url); List&lt;HtmlNode&gt; nodeList = doc.DocumentNode.SelectNodes(&quot;//*[@class=\\&quot;commentlist\\&quot;]/li&quot;).AsParallel().ToList(); foreach (var item in nodeList) &#123; HtmlNode imghtml = item.SelectSingleNode(&quot;.//img&quot;); var imgsrc = &quot;http:&quot; + imghtml.Attributes[&quot;src&quot;].Value; var imgname = Guid.NewGuid().ToString() + imgsrc.Substring(imgsrc.Length - 4, 4); Console.WriteLine(imgsrc); DownPic(imgsrc, path + imgname); &#125; &#125;&#125; 爬取每日一文核心代码123456789101112var url = &quot;https://meiriyiwen.com/random/&quot;;HtmlWeb web = new HtmlWeb();HtmlDocument doc = web.Load(url);HtmlNode node = doc.DocumentNode.SelectSingleNode(&quot;//*[@id=\\&quot;article_show\\&quot;]&quot;);node.Descendants() .Where(n =&gt; n.Name == &quot;script&quot; || n.Name == &quot;style&quot; || n.Name == &quot;#comment&quot; || n.Id == &quot;bdshare&quot;) .ToList().ForEach(n =&gt; n.Remove()); var title = node.SelectSingleNode(&quot;//h1&quot;).InnerText;var author = node.SelectSingleNode(&quot;//*[@class=\\&quot;article_author\\&quot;]&quot;).InnerText;var article = node.SelectSingleNode(&quot;//*[@class=\\&quot;article_text\\&quot;]&quot;).InnerText.TrimStart(); 爬取小说核心代码123456789101112131415161718192021222324252627282930313233343536static void Main(string[] args)&#123; var domain = &quot;http://www.jueshitangmen.info&quot;; HtmlWeb web = new HtmlWeb(); HtmlDocument doc = web.Load(domain + &quot;/zhetian/&quot;); List&lt;HtmlNode&gt; nodeList = doc.DocumentNode.SelectNodes(&quot;//*[@class=\\&quot;panel\\&quot;]/ul/li&quot;).AsParallel().ToList(); foreach (var item in nodeList) &#123; HtmlNode html = item.SelectSingleNode(&quot;.//span/a&quot;); var title = html.InnerText; var url = html.Attributes[&quot;href&quot;].Value; HtmlDocument document = web.Load(url); HtmlNode node = document.DocumentNode.SelectSingleNode(&quot;//*[@class=\\&quot;content\\&quot;]&quot;); node.Descendants() .Where(n =&gt; n.Name == &quot;script&quot; || n.Name == &quot;style&quot; || n.Name == &quot;#comment&quot;) .ToList().ForEach(n =&gt; n.Remove()); var content = node.InnerText.Trim(); Console.WriteLine(title + &quot;\\r\\n&quot;); Console.WriteLine(content); StreamWriter stream = new StreamWriter(@&quot;F:\\Article\\遮天\\&quot; + title + &quot;.txt&quot;); stream.WriteLine(title + &quot;\\r\\n&quot;); stream.WriteLine(content); stream.Close(); stream.Dispose(); &#125;&#125; 源代码下载HtmlAgilityPackDemo","tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://xj8c.cc/tags/爬虫/"},{"name":"HtmlAgilityPack","slug":"HtmlAgilityPack","permalink":"http://xj8c.cc/tags/HtmlAgilityPack/"}]},{"title":"ReactNative开发中一些有用的资源","date":"2017-07-18T08:47:42.000Z","path":"2017/07/18/ReactNative-resource/","text":"一些有用的资源文档英文（官方）： https://facebook.github.io/react-native 中文： http://reactnative.cn 社区GitHub： https://github.com/facebook/react-native stackoverflow: http://stackoverflow.com/questions/tagged/react-native 椰子壳: https://www.yeziker.com 示例AppExamples： https://github.com/facebook/react-native/tree/master/Examples/UIExplorer F8App： https://github.com/fbsamples/f8app 组件react-native-elements： https://github.com/react-native-training/react-native-elements react-native-vector-icons： https://github.com/oblador/react-native-vector-icons NativeBase： https://github.com/GeekyAnts/NativeBase react-native-video： https://github.com/react-native-community/react-native-video Realm： https://github.com/realm/realm-js react-native-maps： https://github.com/airbnb/react-native-maps react-native-app-intro： https://github.com/FuYaoDe/react-native-app-intro react-native-chart： https://github.com/tomauty/react-native-chart","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"ReactNative样式总览","date":"2017-07-17T08:46:47.000Z","path":"2017/07/17/ReactNative-styles/","text":"边框：123456颜色borderColor: colorborderBottomColor: colorborderLeftColor: colorborderTopColor: colorborderRightColor: color 123456圆角borderRadius: numberborderBottomLeftRadius: numberborderBottomRightRadius: numberborderTopLeftRadius: numberborderTopRightRadius: number 12345678宽度borderWidth: numberborderBottomWidth: numberborderLeftWidth: numberborderRightWidth: numberborderTopWidth: number样式borderStyle: enum(&apos;solid&apos;, &apos;dotted&apos;, &apos;dashed&apos;) 边距：123456789101112131415161718内边距padding: numberpaddingBottom: numberpaddingLeft: numberpaddingRight: numberpaddingTop: numberpaddingHorizontal: number (左右内边距)paddingVertical: number (上下内边距)外边距margin: numbermarginBottom: numbermarginLeft: numbermarginRight: numbermarginTop: numbermarginHorizontal: number (左右内边距)marginVertical: number (上下外边距) 文字1234567891011color: colorfontFamily: stringfontSize: numberfontStyle: enum(&apos;normal&apos;, &apos;italic&apos;)fontWeight: enum(&apos;normal&apos;, &apos;bold&apos;, &apos;100&apos;, &apos;200&apos;, &apos;300&apos;, &apos;400&apos;, &apos;500&apos;, &apos;600&apos;, &apos;700&apos;, &apos;800&apos;, &apos;900&apos;)textDecorationColor: color (文本修饰颜色)textDecorationLine: enum(&apos;none&apos;, &apos;underline&apos;, &apos;line-through&apos;, &apos;underline line-through&apos;) textDecorationStyle: enum(&apos;solid&apos;, &apos;double&apos;, &apos;dashed&apos;, &apos;dotted&apos;)letterSpacing: numberlineHeight:numbertextAlign: enum(&apos;auto&apos;, &apos;left&apos;, &apos;right&apos;, &apos;center&apos;, &apos;justify&apos;) 布局12345678910111213141516backgroundColor: colorflex: numberflexDirection: enum(&apos;row&apos;, &apos;row-reverse&apos;, &apos;column&apos;, &apos;column-reverse&apos;)flexWrap: enum(&apos;wrap&apos;, &apos;nowrap&apos;) justifyContent: enum(&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;space-between&apos;, &apos;space-around&apos;) alignItems: enum(&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) alignSelf: enum(&apos;auto&apos;, &apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) position: enum(&apos;absolute&apos;, &apos;relative&apos;)right: numberleft: numbertop: numberbottom: numberwidth: numberheight: number 图形变换12345scaleX:水平方向缩放scaleY:垂直方向缩放rotation:旋转translateX:水平方向平移translateY:水平方向平移 阴影说个悲惨的故事，阴影只能在ios用1234shadowColor: colorshadowOffset: &#123;width: number, height: number&#125; shadowOpacity: numbershadowRadius: number","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"打包你的App","date":"2017-07-16T08:45:13.000Z","path":"2017/07/16/ReactNative-build/","text":"打包应用假设你的应用做完了，总不能还在后台开着packager就把应用发布出去吧。很明显，我们需要让应用可以离线，下边所要讲的就是一个让应用脱离packager的过程 生成签名没签名直接打包应用是不行的，我们需要实现生成一个签名。在Linux下，我们执行这条命令： 1keytool -genkey -v -keystore RN-key.keystore -alias RN-key-alias -keyalg RSA -keysize 2048 -validity 10000 然后会让你设置最少6位的密码，密码一定要记好，作者君的建议是两个密码最好不要设置成一样的~ 至于Windows，我们得进到JDK目录下执行此命令，或者使用一些傻瓜式的签名生成软件。 修改gradle变量将生成的RN-key.keystore放到android/app文件夹中，然后修改在android目录下的gradle.properties， 1234MYAPP_RELEASE_STORE_FILE=RN-key.keystoreMYAPP_RELEASE_KEY_ALIAS=RN-key-alias MYAPP_RELEASE_STORE_PASSWORD=your passwordMYAPP_RELEASE_KEY_PASSWORD=your password 添加配置修改android/app目录下的build.gradle，在defaultConfig代码块下增加： 12345678signingConfigs &#123; release &#123; storeFile file(&quot;RN-key.keystore&quot;) storePassword your password keyAlias RN-key-alias keyPassword your password &#125; &#125; 在buildTypes中的release下添加： 1signingConfig signingConfigs.release 整体就像这样： 打包应用进入项目所在目录，执行以下命令（packger应该处于开启状态）： 1cd android &amp;&amp; ./gradlew assembleRelease Windows用户不用写./，漫长的等待过后，我们便可以在android/app/build/outputs/apk下找到我们的应用了，并且这个可以发布到各大应用市场。 混淆及安全为了安全（也为了缩小apk大小），我们需要启用代码混淆。进入android/app目录，然后修改build.gradle文件，将def enableProguardInReleaseBuilds = false改为def enableProguardInReleaseBuilds = true 如果不准备同时支持ARM和X86，那么将enableSeparateBuildPerCPUArchitecture改为true可以给安装包减少4mb大小~ 修改icon进入android/app/src/main/res目录，我们可以看到有这么几个子目录： 然后把这四个目录下的图片换成别的就可以啦，尺寸要对上哟~ 修改应用名称假设我们想将应用的名字换成茯苓要怎么办呢？很简单，还是在res目录，我们进入values目录，修改strings.xml即可: 123&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;茯苓&lt;/string&gt;&lt;/resources&gt;","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"掌握React Native的Fetch Api","date":"2017-07-15T08:43:47.000Z","path":"2017/07/15/ReactNative-net/","text":"网络这一章呢，不会只讲网络哦~ Mock ApiMock Api是一项非常棒的服务，它可以帮助我们快速的模拟后端的REST Api并且不需要你自己的服务器，甚至代码都不用写，它的网址是http://www.mockapi.io/， 可以注册也可以使用GitHub帐号登陆。点击+来创建一个项目： 填写项目名称和Api前缀(随便写就行)： 接下来点击Create Resource来创建资源： 然后填写资源名称，以及修改Schema，为了方便，我们就留下id和name： 然后点击next按钮，这一步完了之后，我们就可以通过xxxxxxx.mockapi.io/api/user使用REST Api了。 Fetch在React Native中，我们可以使用Fetch来进行网络请求，由于Fetch API天然支持Promise规范，所以我们的代码可以变得很优雅。 执行Get操作应该是最为简单的了，我们看下代码： 12345fetch(&apos;http://xxx.mockapi.io/api/user&apos;) .then((response) =&gt; &#123; console.log(response); &#125;) .catch((err) =&gt; console.error(err);) 这样便可以在控制台打印出user下的所有内容。你可能会想：喵喵喵？React Native还有控制台？ 当然有啦，不过我们得打开远程调试，首先打开菜单： 然后选择Debug Js Remotely，之后便会自动打开Chrome。自己打开Chrome的控制台便可以看到console.log的内容了。 实际应用中，我们会在组件渲染的时候把数据丢到状态或别的地方，然后使用这些数据(一般会用作列表渲染)。不管怎么说，不会直接console就是了。 然后是Post： 123456789101112fetch(&apos;http://xxxx.mockapi.io/api/user&apos;, &#123; method: &apos;POST&apos;, headers: &#123; &apos;Accept&apos;: &apos;application/json&apos;, &apos;Content-Type&apos;: &apos;application/json&apos;, &#125;, body: JSON.stringify(&#123; name: &apos;meow&apos;, &#125;)&#125;) .then(xxxx) .catch((err) =&gt; console.error(err)) 我们可以加个then来处理在Post过程中要做的事情，并用catch来获取异常。 至于Put和Delete参考Post就好啦~","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"是时候用上React Navigation了","date":"2017-07-14T08:42:18.000Z","path":"2017/07/14/ReactNative-navigation/","text":"导航器一个应用（普通的那种），总是有好多个界面，只有一个界面的应用怎么能留得住用户呢？（虽然有很多界面的也不一定留得住）所以说，做应用一般不会只做一个页面。我们知道，网页之间可以自由跳转，通过一个&lt;a&gt;&lt;/a&gt;就可以搞定了，但是开发应用不是写网页，React Native中也没有&lt;a&gt;，那当我们需要做界面跳转的时候该怎么办呢？答案是使用Navigator组件。哈哈，逗你的，在0.42版本前使用Navigator来实现导航效果没问题，不过呢，自从0.43版本之后React Native将停止维护这个组件了，因为出现了更好用的React Navigation（半官方）。首先我们来安装它： 1npm install --save react-navigation 然后重新启动你的应用 作者君在安装这个库的时候，它的版本是beta7,有一个小bug需要处理一下，删掉node_modules/react-navigation/src/views/Header.js的第12行， 12import ReactComponentWithPureRenderMixin from &apos;react/lib/ReactComponentWithPureRenderMixin&apos;;` 不然直接红屏报错。 安装完毕后，我们来一个简单的例子，首先我们需要引入它： 1import &#123; StackNavigator &#125; from &apos;react-navigation&apos;; 然后写两个组件，一个叫HelloScreen，一个叫UserScreen： 12345678910111213141516171819202122232425262728293031class HelloScreen extends Component &#123; static navigationOptions = &#123; title: &apos;Hello&apos;, &#125;; render() &#123; const &#123; navigate &#125; = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;&#123;&apos;\\n&apos;&#125;&lt;/Text&gt; &lt;Text&gt;按下边的按钮&lt;/Text&gt; &lt;Button onPress=&#123;() =&gt; navigate(&apos;User&apos;)&#125; title=&quot;Go&quot; /&gt; &lt;/View&gt; ); &#125;&#125; class UserScreen extends Component &#123; static navigationOptions = &#123; title: &apos;这里是~&apos;, &#125;; render() &#123; return ( &lt;View&gt; &lt;Text&gt;&#123;&apos;\\n&apos;&#125;&lt;/Text&gt; &lt;Text&gt;嘿，猜猜这里是谁？&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 其实在按钮里面写方法并不优雅，翻过了issues之后觉得都不是很好，所以这里就期待一下官方的变化吧 这两个组件和正常的组件差不多，不过是多了些东西罢了。其中，navigationOptions数组里可以放些配置信息，一般用来配置Header部分。HelloScreen里的const { navigate } = this.props.navigation是为了可以在组件中使用navigate方法。navigate(...)理解成跳转到那个界面就好。不过，光有这两个组件可看不出来什么，我们还需要一个StackNavigator来使导航可以正常运作。（可以把这个当成一个特殊的组件，更好理解）： 1234const MyApp = StackNavigator(&#123; Home: &#123; screen: HelloScreen &#125;, User: &#123; screen: UserScreen &#125;,&#125;); 这里的Home和User是路由别名，在使用navigate时需要用到。然后改一下注册的组件，就像下边那样： 1AppRegistry.registerComponent(&apos;AppName&apos;, () =&gt; MyApp); 好啦，我们刷新一下应用： 然后点一下Go按钮： 就像这样，几行代码轻轻松松便实现了导航效果，甚至连头部都帮你做好了~ 参数传递很多时候，我们需要像要跳转的界面传递些参数，比如，某条数据的id，用户的名字。我们只需要把上边的例子小小的修改一下就可以传递参数了： 12//修改navigate方法navigate(&apos;User&apos;, &#123; id: &apos;233333333&apos;, name: &apos;nico&apos; &#125;); 然后接受参数： 123456789render() &#123; const &#123; params &#125; = this.props.navigation.state; return ( &lt;View&gt; &lt;Text&gt;&#123;&apos;\\n&apos;&#125;&lt;/Text&gt; &lt;Text&gt;嘿，这里是&#123;params.name&#125;，id是：&#123;params.id&#125;&lt;&lt;/Text&gt; &lt;/View&gt; ); &#125; 这样就实现参数的传递啦，快刷新一下看看效果吧~ 定制头部前边说过，navigationOptions里面会放些配置信息，我们可以用这个来定制头部，比如说在右边加一个按钮： 1234static navigationOptions = &#123; title: &apos;hahaha&apos;, headerRight: &lt;Button title=&quot;你好&quot; /&gt;,&#125; 理论上来说，它会在右边显示一个按钮，但是并不行，一脸茫然的作者君去翻了下GitHub，发现别人也遇到了这些问题，然后默默的更新了一下react-navigation，从beta7升到了beta9： 1npm update react-navigation 然后刷新一下应用就可以发现按钮乖乖的显示在那里了： 除了按钮，你还可以丢个之类的过去，都是可以的。 Tab Navigator如果需要Tab导航，我们使用其内置的TabNavigator即可，用法和StackNavigator差不多，只要在最后使用TabNavigator即可就像这样： 123const XXX = TabNavigator(&#123; ......&#125;) 如果想要混用StackNavigator和TabNavigator则稍稍麻烦一点，首先，我们写两个新的组件： 1234567891011class HiScreen extends Component &#123; render() &#123; return &lt;Text&gt;Hi&lt;/Text&gt; &#125;&#125;class WorldScreen extends Component &#123; render() &#123; return &lt;Text&gt;World&lt;/Text&gt; &#125;&#125; 然后使用TabNavigator： const TabScreen = TabNavigator({ Hi: { screen: HiScreen }, World: { screen: WorldScreen },}); 这里的Hi，world会被作为选项卡（Tab）的名字，然后修改MyApp: 1234const MyApp = StackNavigator(&#123; Home: &#123; screen: TabScreen &#125;, User: &#123; screen: UserScreen &#125;,&#125;); 刷新一下应用，会发现公用的头部是空白的： 没关系，我们来添加一下： 123TabScreen.navigationOptions = &#123; title: &apos;这里是Tab&apos;&#125;; 和别的导航组件，你也可以丢个按钮进去： 最后，我们来写一个可以跳转到UserScreen的按钮(别忘记navigate)： //HiScreen const { navigate } = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;Hi&lt;/Text&gt; &lt;Button onPress={() =&gt; navigate(&apos;User&apos;, { id: &apos;233333333&apos;, name: &apos;nico&apos; })} title=&quot;Go&quot; /&gt; &lt;/View&gt; ) 然后刷新一下看看是否成功吧~","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"带你了解ListView及FlatList","date":"2017-07-13T08:31:08.000Z","path":"2017/07/13/ReactNative-ListView-FlatList/","text":"ListView与FlatList当你需要给用户在一个页面展示一堆数据的时候，一个一个去渲染对性能来说真的不好，所以我们使用React Native内置的列表来渲染数据。在0.43版本之前，我们一直使用ListView来渲染数据，不过它的性能经常被人吐嘈，社区里也不断提出解决方案。就连Realm都内置了一个性能更好些的ListView。不过自从官方发布了0.43版之后，这种局面应该会离我们远去了，因为官方给出了更好的方案FlatList。不过，ListView虽然老旧了一些，但依然还有学习的必要，所以我们从ListView开始学起 ListView对于ListView来说，我们需要一个数据源，这样ListView才有渲染视图的原料。这些数据可以放到一个数组里面(从Realm取出的数据可以直接用ListView渲染)，首先定义取值策略，我们一般采用这种方式(上下数据不相等时更新数据)： 1const ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); 然后我们来创建一个数组来储存数据： 123456789101112131415161718const data = [ &#123; id: 1, name: &apos;meow&apos; &#125;, &#123; id: 2, name: &apos;meow2&apos; &#125;, &#123; id: 3, name: &apos;meow3&apos; &#125;, &#123; id: 4, name: &apos;meow4&apos; &#125; ] 准备好后，我们开始使用ListView，别忘记引用它： 1234import &#123; ...., ListView&#125; from &apos;react-native&apos;; 然后随便找个视图丢个ListView进去，然后用刚才初始化好的ds来接受数据并使用renderRow渲染数据： 1234&lt;ListView dataSource=&#123;ds.cloneWithRows(data)&#125; renderRow=&#123;(rowData) =&gt; &lt;Text&gt;id:&#123;rowData.id&#125;，name：&#123;rowData.name&#125;&lt;/Text&gt;&#125;/&gt; 没加任何样式，不过数据愉快的渲染出来了： 我们可以用列表渲染文字，图片，在列表里嵌套组件等等，还可以像寻常组件一样为其添加各种样式。因为写样式就像寻常组件一样，所以这里就不再说了。 除了传递rowData，还可以传递sectionID, rowID来获取section id和 row id，如果对这两个参数感兴趣就自己动手做下试验。 再提一个和性能有关的属性initialListSize，这个属性可以指定首屏渲染多少数据，避免造成性能损耗。 1234&lt;ListView...initialListSize=&#123;123&#125;/&gt; FlatListFlatList是一个高性能的列表，为什么要使用它我们在开篇介绍已经讲过，下面我们来看一个简单的例子： 1234&lt;FlatList data=&#123;data&#125; renderItem=&#123; (&#123; item &#125;) =&gt; &lt;Text&gt;&#123;item.id&#125;&lt;/Text&gt; &#125;/&gt; 这里的data是在ListView例子中用过的data，不过呢，这段代码并不能运行，因为FlatList需要每行都有一个不同的key，所以我们需要炮制一下data。至于这个提示，先看前半句： 之前在创建data的时候我们用了const，为了后边能够修改data，我们将const改成let。然后写一小段代码为data添加key： 123for (let i = 0; i &lt; data.length; i++) &#123; data[i].key = i&#125; 然后data就可以丢到FlatList中使用了(使用新组件别忘记引入)。另外，在现在的版本中data只能是一个普通数组，不可以是别的复杂数据结构(为了简单)。 接下来，我们来看FlatList支持的属性。 FlatList默认竖式布局，但是只要设置horizontal属性为true，列表就会变成横的： 1horizontal=&#123;true&#125; 刚才为data添加key的那一步其实并没有必要，因为有keyExtractor属性，我们可以通过这一属性来指定key，拿刚才的data来举例： 1keyExtractor=&#123; (item, index) =&gt; item.id &#125; 然后是三个比较像的组件ListHeaderComponent，ItemSeparatorComponent，ListFooterComponent，在这三个属性中，我们向其中分别会放头部组件，分隔组件，尾部组件。举一个简单的例子： 123ListHeaderComponent=&#123;()=&gt;&#123;return &lt;Text&gt;我是头部&lt;/Text&gt;&#125;&#125;ItemSeparatorComponent=&#123;()=&gt;&#123;return &lt;Text&gt;我是分隔组件&lt;/Text&gt;&#125;&#125;ListFooterComponent=&#123;()=&gt;&#123;return &lt;Text&gt;我是尾部&lt;/Text&gt;&#125;&#125; 实际使用的时候记得把组件单独拿出来，这里这么写只是为了方便。FlatList为了优化内存占用并保证流畅滑动会在屏幕外异步绘制列表内容（看不到的地方用空白代替items），所以如果用户滑动过快就会看到空白内容，对于这个问题，我们可以使用getItemLayout属性来有优化，不过你得知道内容的行高才能用： 1234//xxx是行高getItemLayout=&#123;(data, index) =&gt; ( &#123; length: xxx, offset: xxx * index, index &#125;)&#125; 介绍的最后一个组件在当前版本（0.43）有点小问题onEndReached有时候会不触发，所以只好期待下一个版本喽 onEndReached是当列表滑到尾部会调用的一个属性（距离尾部不足这个onEndReachedThreshold的大小），我们可以用它来更新列表数据什么的： 123onEndReached=&#123;()=&gt;&#123;//更新数据&#125;&#125; 与onEndReachedThreshold是个好基友，我们在里边放些数字，如果滑动列表就好触发onEndReached的话，我们需要设置onEndReachedThreshold的值为01onEndReachedThreshold=&#123;0&#125;","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"存储：与AsyncStorage相比，Realm更应该作为重点掌握内容","date":"2017-07-12T08:28:22.000Z","path":"2017/07/12/ReactNative-storage/","text":"储存本章提要 1.AsyncStorage 2.Realm一个应用总是要存些东西的，我们要怎么做才能把数据存起来呢？我们这里有两个选择，一个是使用官方提供的AsyncStorage另一个是使用小型数据库。 当数据量不大，结构很简单的时候，我们来使用AsyncStorage这个key-value储存系统，当数据量较大的时候，我们就需要使用小型数据库了，这里我们会学习一个叫做Realm的数据库。首先，我们来看看AsyncStorage吧~ AsyncStorage与数据打交道，免不了对数据进行增加，删除，更改和查找。我们来看看如何用AsyncStorage实现这些。 增加数据： 123456789101112`` save(key, value) &#123; AsyncStorage.setItem(key,value).then( (errs)=&gt;&#123; if (!errs) &#123; //xxx &#125;else &#123; //xxx &#125; &#125;) &#125;`` 在这里，我们使用了promise，这样会使代码看起来舒服很多。虽然看起来很多，实际上，只要知道 1AsyncStorage.setItem(key,value) 就可以了，我们用setItem来将key和value存储起来，看到这里想必你已经知道了为什么AsyncStorage是key-value系统了。 由于有了key，所以我们可以用key进行查询： 1234567891011121314get(key) &#123; AsyncStorage.getItem(key) .then( (result)=&gt; &#123; if (!result) &#123; //xxx &#125; //返回结果 &#125; ).catch((error)=&gt; &#123; //错误处理 &#125;&#125; 数据我们存完了，但是如果数据没用了怎么办？删掉呗。和查询数据很像，删除也需要用到key： 12345678910del(key) &#123; AsyncStorage.removeItem(key). then( ()=&gt;&#123; //删除成功 &#125; ).catch((error)=&gt; &#123; //错误处理 &#125;&#125; 至于修改数据，其实写法和增加数据一样，当你需要修改一项数据的时候，直接传入key和一个新的值就可以了。 Realm前面的AsyncStorage只能存些小东西，数据量一大就开始捉襟见肘了，到了这种时候就该用Realm了。其实用SQLite也行，不过不怎么好用，索性就不用了。当初作者君在用Realm的时候版本号才是0.14转眼间就到1.0.0了，所以请放心的使用Realm吧。 Realm并不是React Native自己就有的，所以我们需要安装Realm： 1npm install --save realm 安装好后大概是这样： 然后执行 1react-native link realm 装完Realm之后得重新构建一下App： 1react-native run-android Tips：由于网络的问题呢，可能会构建失败，多试几次就可以构建完成了 接下来测试一下Realm是不是安装成功了，先是引入Realm： 1import Realm from &apos;realm&apos;; 下面是Realm官方文档的例子的： 123456789101112131415161718export default class &lt;project-name&gt; extends Component &#123; render() &#123; let realm = new Realm(&#123; schema: [&#123;name: &apos;Dog&apos;, properties: &#123;name: &apos;string&apos;&#125;&#125;] &#125;); realm.write(() =&gt; &#123; realm.create(&apos;Dog&apos;, &#123;name: &apos;Rex&apos;&#125;); &#125;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Count of Dogs in Realm: &#123;realm.objects(&apos;Dog&apos;).length&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; &lt;project-name&gt;是你的项目名称，别弄错了。然后刷新一下，界面上的数字就会加1。如果程序可以顺利运行，Realm就已经安装好了。 先简单的解释一下上面的代码，首先我们新建了一个叫做Dog的Schema，下面的write是写入数据，组件中的realm.objects(&#39;Dog&#39;).length会返回Dog中的数据个数。每次刷新App，都会写入一条数据，所以数字会加一。 有了一个简单的认识之后，让我们来详细的了解Realm吧！ Schema在使用Realm的时候离不开Schema，一个大些的App一般会用到多个Schema，所以在正式使用Realm的时候不能像上面的例子一样敷衍，我们需要进行一个简单的封装。新建一个叫Schema.js文件，它可以在app文件夹下（没有app文件夹就自己新建一个）， 在文件头部引入Realm： 1import Realm from &apos;realm&apos;; 然后创建一个叫Todo的class： 1class Todo extends Realm.Object &#123;&#125; 不喜欢这个名字的话，你可以自己随便起一个名字。 然后来写Schema： 12345678Todo.schema = &#123; name:&apos;Todo&apos;, primaryKey: &apos;id&apos;, properties: &#123; title: &#123;type: &apos;string&apos;&#125;, id: &#123;type: &apos;string&apos;, indexed: true&#125;, &#125;&#125; 这里我们用id来作为主键，由于这个id具有唯一性，我们一会儿会写一个小程序来生成id。 然后导出模块： 1234export default new Realm(&#123;schema: [Todo]&#125;)``` 如果你需要多个Schema，在后面加上就好： export default new Realm({schema: [Todo, Category, xxx, xxx]})1234然后在你需要使用储存的地方引入Schema.js。比如这样引入： import realm from ‘./Schema’;//注意文件位置12然后写一个生成id(为了不生成重复的id，我们使用guid，别管这是啥，只要知道这东西一般不会重复就好了)的函数： const guid = () =&gt; { return ‘xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx’ .replace(/[xy]/g, (c) =&gt; { var r = Math.random() * 16 | 0, v = c == ‘x’ ? r : (r &amp; 0x3 | 0x8); return v.toString(16); });}1234接下来，我们来看如何去用Realm（也就是增删改查）。我们来写一个输入框来收集数据： 1234![PNG](https://meowv.github.io/images/6.4.png) 不出意外的话，下边会有一个黄色的提示（前边的章节有说过），先不要管它，我们一会儿解决。为了储存数据，我们需要把输入的文字放到state里面，上面的`onChangeText`就是干这个的，对了，别忘记加一个叫title的状态： constructor(props){ super(props); this.state = { text: null }; }12Ok，搞定这些后我们来写一个写入数据的方法，我们起名叫write，write应该写在constructor下边： write(){ realm.write(()=&gt;{ realm.create(‘Todo’,{ title: this.state.title, id: guid() }); }); }1234写入数据需要用到`realm.write()`和`realm.create()`，Todo是Schema，后边跟着的是要写入的数据，title是从state中取出来的，然后我们调用`guid()`来生成一个不重复的id。接下来把这个方法绑到按钮上，实现点击添加数据： this.write() }/&gt;1234别忘记写this哦，write是内部的方法，不用this会引用不到的。我们可以在下边写一个文本来显示Todo中数据的条数，就和上面的例子一样，我们在Button下面写个换行符： {‘\\n’}12然后把数据放到state里： this.state = { text: null, data: realm.objects(‘Todo’)};12在换行符下面继续写： { this.state.data.length }12然后才是重点，Realm是可以使数据实时更新的，只要增加一个监听就好了，我们把这个监听写在构造里面： this.state = {…}realm.addListener(‘change’, () =&gt; { this.forceUpdate()});1234然后输入一个数据，保存，下面的数字就可以实时的变化了~然后我们来看查询是怎样的，界面的话把上面的代码复制过去，改几个字就好： 12然后把find放到state里，正如我们之前做过的一样： this.state = { text: null, find: null, data: realm.objects(‘Todo’)};12然后我们写一个叫find的方法,这个方法稍稍有些复杂： find () { realm.objects(‘Todo’) .filtered(‘title = ‘ + ‘“‘ + this.state.find + ‘“‘) .forEach(result =&gt; ToastAndroid.show(result.id, ToastAndroid.SHORT));}123456789101112我们借助了一个叫做`ToastAndroid`的组件来实现显示查找结果的id，所以别忘记引入这个组件。`filtered`是一个过滤器，我们在里面写查询代码，注意喽，查询的值应该是一个字符串所以在外面包裹了双引号。由于返回的结果稍稍有些复杂，所以我们用`forEach`来处理一下，使其获得id。效果应该是这个样子的：![PNG](https://meowv.github.io/images/6.5.png) 至于修改和删除就很简单了，所以这里只给出核心代码，作者君知道你很聪明，所以来想想具体怎么用把~修改： realm.write(() =&gt; { realm.create(‘Todo’, { id: xxx, title: xxx }, true);});12删除： realm.write(() =&gt; { const todo = realm.objects(‘Todo.filtered(‘id = xxxxx’); realm.delete(todo);});``` 小提示： 唔？ID真的没有用吗？具体可以起到什么作用呢？ 想明白这两点，修改和删除就没问题了。另外，有没有发现修改，增加，删除都是在write中进行的呢？","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"React Native中的样式，Flexbox布局及其他内容","date":"2017-07-11T08:25:59.000Z","path":"2017/07/11/ReactNative-style-layout/","text":"是时候说说样式与布局了本章提要 样式 布局 Dimensions 样式在前几章说了一些样式，是不是有点懵了呢？没关系，我们一起看看样式在React Native中的使用。 在React Native中，写样式和写CSS差不多，只不过是把-的连接方式换成了小驼峰式。又把;换成了,，有的时候要把值加上分号，比如这样：1background-color: green; ---&gt; backgroundColor: &apos;green&apos;, 实际上，React Native的样式算是CSS的一个子集，当发现有些样式不能用的话不要惊讶，试着换用别的方式来实现就好~ 作者君总结了一些常用的样式放到了附录里，可以作为写样式时的参考。 我们知道，代码总是会越写越多，样式也一样。所以为了效率，为了样式的整洁，我们写样式用StyleSheet.create比较好，不过只是写着玩玩的话，怎么写都好。下面我们来看看这种定义样式的方法 1234567891011const styles = StyleSheet.create(&#123; content: &#123; backgroundColor: &apos;#fff&apos;, height: 50, width: 100 &#125;, text: &#123; color: &apos;blue&apos;, textAlign: &apos;center&apos; &#125;&#125;) 然后在组件中这样使用即可: 1234&lt;View style=&#123;styles.content&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;哈，我是小整洁&lt;/Text&gt; .....&lt;/View&gt; 这样写后，你的代码可读性会提高不少，毕竟样式都像： 1&lt;Text style=&#123;&#123; fontStyle:&apos;italic&apos;, fontSize: 20,... &#125;&#125; 就会变得乱糟糟一团团了。 布局Flexbox在React Native中，你可以愉快的使用Flexbox布局，完全不用考虑兼容性（放心，绝对不需要考虑IE6）,如果在浏览器端写过的话，在React Native上继续写这种布局会很是得心应手的。如果没接触过也没关系，这里会很详细的讲的（毕竟很重要）。 首先，我们先瞅瞅Flexbox布局需要用到什么样式： 1flex, flexDiretion, justifyCotent, alignItems, alignSelf, flexWrap, flexShrink, flexGrow 嗯，先把这些列在这里，有个大概印象就成，我们一会儿再说。 对于Flexbox来说，有一个很重要的概念————轴。理解了轴的概念，使用Flexbox也不会有什么问题了。 对于一个平面来说，它有两个轴，横轴和纵轴，就是下面这样： Flexbox用操作这两个轴的方式来完成布局，不过不叫横纵而是叫主次。 当横轴为主轴时，次轴是纵轴： 当纵轴为主轴时，次轴是横轴： 看完预备知识，我们可以看看Flexbox是怎么用的了。 首先，要有一个flex容器，如果不指定高度和宽度，它会占满能够占领的最大空间，如果给了高度和宽度，那么会占满你给它的空间。 我们用flex告诉React Native说这是一个使用了弹性布局的组件，就像这样：1&lt;View style=&#123;&#123; flex:1 &#125;&#125;&gt;&lt;/View&gt; flex后面的数字可以简单的理解为比例 不过呢，我们一般不会只写个flex: 1，我们还得写一些别的东西，就像下面这样： 12&lt;View style=&#123;&#123; flex: 1, flexDirection: &apos;column&apos;, justifyContent:&apos;center&apos;, alignItems:&apos;flex-end&apos; &#125;&#125;&gt;&lt;/View&gt; 除了flex: 1，剩下的其实就是用来操作横纵轴的。用flexDirection声明主轴是纵轴，次轴是横轴，用justifyContent声明元素处在主轴的中心位置，用alignItems声明元素处在次轴的末尾。 我们在View容器里填充一些元素进去，就可以很直观的看到效果： 12345&lt;View style=&#123;&#123; flex: 1, flexDirection: &apos;column&apos;, justifyContent:&apos;center&apos;, alignItems:&apos;flex-end&apos; &#125;&#125;&gt; &lt;Text style=&#123;&#123; backgroundColor:&apos;blue&apos;&#125;&#125; &gt;1&lt;/Text&gt; &lt;Text style=&#123;&#123; backgroundColor:&apos;red&apos; &#125;&#125;&gt;2&lt;/Text&gt; &lt;Text style=&#123;&#123; backgroundColor:&apos;green&apos; &#125;&#125;&gt;3&lt;/Text&gt;&lt;/View&gt; 效果是这样（虽然比较建议你自己敲一下代码，但是还是把图放在这里比较好）： 至于为啥这个图看起来有些大，是因为作者君把整个模拟器的屏幕截过来了，毕竟要突出元素在主轴中间的效果嘛。 这些还不是全部，毕竟不可能每个整体都是统一的，内部总是要有些不一样的。拿上面的那个例子来说：如果我不想让每个元素都在次轴的末尾，那该怎么办呢？ 很简单，这个时候我们就可以使用alignSelf了。alignSelf可以使容器里的元素和父样式不一样，我们来简单的改造一下上面的例子： 1&lt;Text style=&#123;&#123; backgroundColor:&apos;green&apos;, alignSelf:&apos;flex-start&apos; &#125;&#125;&gt;3&lt;/Text&gt; 这样就可以使第三个Text在前面了。就像这样： 我们再说回flex。我们知道，flex后面是接数字的，数字是这个容器所占的比例，也就是说，后面的数字越大，容器所占比例也就越大。 不过，如果只有flex: 1的话，它会自己占领所有地盘，谁叫没有其它的容器和它抢地盘呢。 position对于一个App来说，不可能只用到Flexbox，还得用到其他的布局方式。 首先来看绝对布局absolute，绝对布局这名字听起来挺霸气的，实际上也确实霸气，规定元素在那里，那元素就得在那里待着。我们使用top,bottom,left,right来声明元素的上下左右距容器有多少距离，从而将元素定在那个位置。我们在用绝对布局的时候需要告诉元素它的布局方式是绝对布局，就像这样： 1&lt;Text style=&#123;&#123; position: &apos;absolute&apos;, width: 50, height: 50 &#125;&#125;&gt;&lt;/Text&gt; 只不过我们得事先声明元素的宽度和高度，不然样式会变得很奇怪，然后来定位元素的位置： 1&lt;Text style=&#123;&#123; position: &apos;absolute&apos;, width:50, height: 50, bottom: 20, left:10 &#125;&#125;&gt;233&lt;/Text&gt; 就像这样： 还有一点得注意，我们需要给父容器一个合适的高度和宽度，比如这样： 1234&lt;View style=&#123;&#123; height:500,width:500 &#125;&#125;&gt; &lt;Text style=&#123;&#123; position: &apos;absolute&apos;, bottom: 20, left:10, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt; &lt;Text style=&#123;&#123; position: &apos;absolute&apos;, bottom: 20, left:80, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt;&lt;/View&gt; 既然有绝对布局，就有相对布局，只不过可能会有些难用。你可以把相对布局理解成一个流，只不过bottom,right不能用。可以使用top,left更改元素在流中的上，左偏移大小（top,left初始值为0）。下面是个例子： 12345&lt;View style=&#123;&#123;height:500,width:500&#125;&#125;&gt; &lt;Text style=&#123;&#123; position: &apos;relative&apos;, left:10, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt; &lt;Text style=&#123;&#123; position: &apos;relative&apos;, left:60, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt; &lt;Text style=&#123;&#123; position: &apos;relative&apos;, left:120, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt;&lt;/View&gt; Dimensions在React Native中，我们不能用width: 60%之类的方式来进行布局，那该怎么办嘞？嗯，我们可以换个方式，那就是Dimensions，我们来请Dimensions出场： 123import &#123; Dimensions&#125; from &apos;react-native&apos;; 然后获取宽度和高度，这里我们用解构赋值的方式： 1const &#123; width, height &#125; = Dimensions.get(&quot;window&quot;); 然后就可以在样式中使用喽： 1&lt;View style=&#123;&#123; width: width * 0.5 ,height: height * 0.5 &#125;&#125;&gt;&lt;/View&gt;","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"React Native常用的组件","date":"2017-07-10T08:24:39.000Z","path":"2017/07/10/ReactNative-module/","text":"一些一定要知道的组件本章提要 View组件 Text组件 Button组件 Image组件 第三方组件 很多组件是开发应用的基石，如果没有这些组件，那么是写不出来一个应用的，在这一章，我们来学习一些一定要知道的组件。在使用组件的时候，忘记引入组件是不行的，我们来看一下怎么引入组件。 123456import &#123; Text, View, Button, ...其它的组件名字&#125; from &apos;react-native&apos;; 这样就可以依次引入Text，View和Button组件了~ View组件这么说吧，第一个就介绍View组件是有原因的。View组件可是最最基础的组件，我们经常需要拿View组件当容器使用~View自己没有固定的样式，我们需要自己为它定义样式。 1&lt;View style=&#123;&#123; backgroundColor:&apos;green&apos;, height:50, width:50 &#125;&#125;&gt;&lt;/View&gt; 这样，在屏幕上便可以出现一个绿色的，边长为50dp的正方形 样式什么的，我们会在下一章讲到，在这里简单看看就好。 Text组件一般来说，一个应用总是离不开文字的，在React Native中，文字外面需要套上Text组件才可以，我们可以通过Text组件控制文字大小及颜色，文字行数，还可以通过点击Text组件来触发一些动作（函数）。栗子如下： 123&lt;Text numberOfLines=&#123; 1 &#125; style=&#123;&#123; fontSize:20, color:&apos;green&apos; &#125;&#125;&gt;略略略,略略略略略略，略略略略略略略略略，略略略略略略略略略略略略&lt;/Text&gt; 我们通过numberOfLines来控制行数，超过设定的行数便会在设定好的最后一行显示省略号。通过fontSize和color设定了文字的大小及颜色。效果如下： Button组件Button组件大概是在0.37版加入的，在那之前按钮什么的要自己写，如果对官方出的这个不满意的话，那就自己写或找一些第三方组件吧~我们写两个按钮当作栗子： 1234&lt;View&gt; &lt;Button color=&quot;green&quot; title=&quot;我是一个正常的按钮&quot;/&gt; &lt;Button disabled=&#123;true&#125; title=&quot;我是一个不可用的按钮&quot;/&gt;&lt;/View&gt; 由于写了两个组件，所以要在外面包裹一层容器，这里我们用View。这两个按钮一个是正常状态，一个是不可用状态，我们通过控制disabled属性来控制是否可用(默认false)。按钮中的文字写在title里，color属性可以控制颜色。由于按钮需要和onPress一起用，所以会有一个这样的警告： 不过暂时没什么问题，咱先不用管，以后用到的时候再写~ Image组件在以前，用React Native引用组件总是很坑，不过现在比以前好多了。由于作者君木有苹果电脑，所以不怎么清楚IOS版是怎么用的，我们就只说安卓的吧。图片的来源有两种，一种是本地图片，一种是网络图片，这两种图片在引入的时候稍稍有些差别，我们先看引入本地图片的例子： 1&lt;Image source=&#123;require(&apos;./images/avatar.png&apos;)&#125; style=&#123;&#123; height:50, width:50 &#125;&#125; /&gt; 我们在项目根目录创建一个叫images的文件夹，并在里面放一个叫avatar的图片。然后require图片地址，使用图片组件要给它宽和高，不然无法正常显示。还有，如果图片没显示的话，记得重新执行 1react-native run-android 然后是网络图片: 1&lt;Image source=&#123;&#123;uri: &apos;http://qiniu.com/xxx/png&#125;&#125; style=&#123;&#123; height:50, width:50 &#125;&#125; /&gt; 在使用网络图片的时候，要将require改成uri，而且不写高度和宽度也没问题~ 第三方组件当你觉得官方组件有限，自己写又心好累，这时该怎么办呢？ 当然是使用第三方组件啦~React Native社区越来越大，我们可以用的组件也越來越多，在这里，作者君推荐两个搜索组件的地方： js.coach(https://js.coach/react-native) GitHub(https://github.com/) 其实js.coach的组件来源也是GitHub 23333","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"启动你的第一个React Native 应用","date":"2017-07-09T08:20:15.000Z","path":"2017/07/09/ReactNative-run/","text":"启动你的App本章提要 1.搭建React Native环境 2.启动App 1.搭建React Native环境啊哈，我们即将近距离接触React Native了。不过，我们得在这之前安装一下React Native环境。首先，我们来安装Node.js环境。如果你的系统是Windows，那么到Node.js官网上下载安装包，一路next就行了。如果是Linux或MacOS，那么作者君推荐使用神奇的nvm。nvm的地址是:https://github.com/creationix/nvm按照说明安装即可。 然后执行 1nvm install x.xx.x(要安装的版本号) 这样Node.js就安装完毕了。 接下来，我们来安装Java环境。去Oracle的官网上下载安装包http://www.oracle.com/technetwork/java/javase/downloads/index.html然后安装。 同样的，Windows用户一路next然后设置JAVA_HOME环境变量即可。对于Linux和MacOS用户来说，会稍稍麻烦一些。首先把安装包解压到opt目录，然后在/etc/profile里加上1234export JAVA_HOME=/opt/(这里是安装包解压后的路径，别填错)export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 最后别忘了执行一下source /etc/profile 如果执行java -version可以正常输出的话，那么恭喜啦，对很多人来说不怎么好装的Java环境被你安装好了哟 然后安装安卓环境，我们先去Google的开发者网站https://developer.android.google.cn/studio/index.html 上下载Android Studio。安装好Android Studio，我们需要安装SDK及SDK Tools。首先，我们来安装SDK。在SDK Platforms，选择Show Package Details，然后勾选Android 6.0下的Google APIs，Android SDK Platform 23，Intel x86 Atom_64 System Image还有Google APIs Intel x86 Atom_64 System Image。接下来，在SDK Tools窗口中选择Show Package Details，然后选中有23.0.1的选项并下载。最后，我们需要在/etc/profile中写入环境变量 1export ANDROID_HOME=&apos;/home/elven/Android/Sdk&apos; Windows用户也需要设置ANDROID_HOME这个环境变量。 如果是老司机的话，Android Studio是不需要安装的，不过为了及时，方便的更新SDK，还是装上吧。 再来三步，环境就安装好啦，如果感觉有些焦灼，给自己冲杯茶，咖啡或果汁是很好的选择~ 接下来，我们需要安装React Native。在终端中执行 1npm install react-native-cli -g 然后安装Yarn 1npm install yarn -g 最后安装Watchman，按照这里(https://facebook.github.io/watchman/docs/install.html#build-install )的说明一步步安装。如果有报错的话，多半是有什么没装，按照报错里的信息装一下就Ok了。另外，Windows系统不需要安装Watchman（其实是Watchman不能在在这个系统运行） 到这里，开发环境就搭建好了。 2.启动App在启动App之前，我们得创建一个新的项目（啥都没有拿什么启动，哈哈）在终端输入 1react-native init 项目名 等待一会儿，进入项目目录。好了，拿出你的小手机和数据线并与电脑相连。新开一个终端，然后进入项目目录，执行 1react-native start 回到原来的终端，执行 1react-native run-android 如果是Windows的话，只要执行run-android这条命令就可以，packager可以自行启动，这里分开是为了保证App可以正常启动。 闭一会儿眼睛，稍稍休息下之后，你就会在手机上看到启动好的App了！ 作者君猜，你可能不知道项目中的index.android.js里的最后一句是什么意思，所以就在代码里小小的解释一下: 1AppRegistry.registerComponent(&apos;项目名称&apos;, () =&gt; 组件名称);","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"ReactNative基础","date":"2017-07-08T08:18:48.000Z","path":"2017/07/08/ReactNative-base/","text":"React Native基础本章提要 1.初识JSX 2.组件 3.Props和State 1.初识JSXReact Native抛弃了HTML，所以只好用JSX喽，在这里，我们来简单的了解一下JSX。JSX是一个JS的语法糖，写起来就像XML。嗯，如果你不知道什么是XML的话，就脑补HTML吧，它们都需要一些标签。比如这样： 1&lt;Text&gt;&lt;/Text&gt; 还有这样：1&lt;Image /&gt; 怎么样，有没有一丝熟悉的感觉？JSX就是这样简单，我们只需要一个&lt;加上组件名字和/&gt;就可以了（其中Text，Image就是组件名） 2.组件在React Native中，有这么几种组件，无状态组件，正常的组件和高阶组件。 高阶组件以后补上 无状态组件，顾名思义，就是没有状态的组件，写一个无状态组件就和写一个函数一样简单。由于无状态组件的性能较高，我们一般会在App性能优化的时候使用无状态组件。下面是一个无状态组件的例子： 12345const Hello = () =&gt; &#123; return ( &lt;Text&gt;我是一个无状态组件&lt;/Text&gt; )&#125; 其中，Hello是组件的名字，这里有个友情提示，在React Native中，组件的名字最好都是首字母大写，这样可以避免一些奇怪的BUG。然后在return中写组件的内容，注意，使用文字的时候，一定要在文字外面套上Text组件，否则会红屏报错。如果想要用Props(属性)，要传一个props参数，就像这样 1const Hello = (props) =&gt; &#123;...&#125; 如果不知道什么是Props的话，别着急，一会儿会说到的。 接下来是正常的组件。正常的组件能做的事情比无状态组件多了不少 (´・ω・`)。写起来是酱紫的，稍微复杂一点：12345678910111213class Hello extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; return ( &lt;View&gt; &lt;Text&gt;Hi,很高兴认识你&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125; 这是一个比较完整的组件，包含了Props和State(状态)。在正常组件中使用state和props，我们需要使用constructor来初始化一下~这里的super(props)是为了可以在constructor使用this.props，当然，如果不需要这些，则不用写（虽然没写，但是按照ES6规范，class需要有一个constructor，所以constructor会被自动加上）。就像这样： 123456789class Hello extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text&gt;略略略/Text&gt; &lt;/View&gt; ) &#125;&#125; 3.Props和State嗯哼，刚才稍微提了一下Props和State，是不是很想知道这俩是啥嘞~别着急，我这就说(´・ω・`)Props的意思是属性，在React中，我们可以实现组件的复用(毕竟不复用组件太浪费了)。为了实现组件的复用，我们希望可以对组件做些定制，这个时候，我们就需要使用Props了。往组件中传些不同的参数，从而使组件具有不同的功能。我们称这些参数为Props。如果不太理解，没关系，来看这个栗子。 设计师为衣服厂设计了一些衣服，但是为了照顾到不同的人群，所以要有不同的型号。高的，矮的，胖的，瘦的。虽然有不同的型号，但是是同一款衣服，我们可以认为高矮胖瘦是参数，衣服的款式是一个组件。 我们来看一下Props怎么用。首先写一个叫做Eat的组件： 1234567class Eat extends Component &#123; render() &#123; return ( &lt;Text&gt;我想吃&lt;/Text&gt; ) &#125;&#125; 在组件里使用Props，我们需要一对花括号{}(写其他的JS语句也需要花括号)就像这样: 123return ( &lt;Text&gt;我想吃&#123;this.props.food&#125;&lt;/Text&gt;) 在props后面跟着的是属性的名字 接下来，我们写另一个组件Dinner，并引入Eat组件： 1234567class Dinner extends Component &#123; render() &#123; return ( &lt;Eat /&gt; ) &#125;&#125; 然后使用props: 1&lt;Eat food=&apos;鱼&apos; /&gt; 这样最终会显示我想吃鱼，这里的鱼是food的值。到这里，Props的栗子就结束了，我们来看看State。 一般来说，组件是需要和用户进行交互的，组件会随着随着交互而发生变化，这里的变化指的是State也就是状态。 下面是一个用到了状态的组件: 1234567891011121314class NeedState extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; text: &apos;&apos; &#125;; &#125; render() &#123; return ( &lt;View&gt; &lt;Text onPress=&#123;() =&gt; &#123; this.setState(&#123; text: &apos;状态变了&apos; &#125;)&#125; &#125;&gt;点我！&lt;/Text&gt; &lt;Text&gt;期待会发生的事情&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125; 首先，我们需要constructor函数来初始化状态，别忘记用this.state写入状态的名字。onPress可以帮我们在点了某个组件之后执行一定的动作。我们在这里用它来触发setState来改变状态。 如果没有什么奇怪的错误的话，点击点我这个文本之后，下面的文字会变成状态变了。 State大概就是这么用的，没什么难度。在使用React Native的过程中，我们会时常用到Props和State，所以记下它们的用法还是很有必要的。","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"ReactNative介绍","date":"2017-07-07T08:17:29.000Z","path":"2017/07/07/ReactNative-introduce/","text":"React Native介绍虽然，你可能已经对React Native有一定的了解了，但是按照惯例，还是要简单介绍一下。 React是由Facebook的工程师们在2013年开源的一款前端框架，现在已成为最火热的前端框架之一。React Native则是使用React来开发移动应用的方式。React Native底层使用JS与原生进行通信，这使得其性能比Hybird强了不少，如果觉得Hybird使你的应用变得卡顿，那么投入React Native的怀抱是一个好的选择~ React Native在底层通过一套机制天然的支持ES6,这意味着你可以在你的应用中愉快的使用ES6语法，而不用头疼兼容问题。 使用React Native意味着更快的调试速度，当你在配置中开启一些选项时，React Native可以做到保存后自动更新，摆脱耗时巨长的编译过程。还可以在Chrome中获取调试信息，这使排除异常的过程更加轻松。 React Native具有自动更新的能力。前一阵子苹果警告了一些使用热更新的应用，不用担心，这并不是针对React Native，那些被警告的应用使用了有害的API，而React Native热更新是从网络获取JS bundle，不会影响安全性。 虽然React Native很棒，但是有些事情还是要知道的。 1.React Native抛弃了HTML，所以需要使用一种叫做JSX的东西，如果觉得有些畏惧，那么请放心，JSX还是很易于掌握的。 2.React Native并非万能，有些事情它不能做到。举个栗子，如果我想做一个桌面小部件，那么我在这个时候就需要一些原生知识了。 3.React Native不能完全取代原生应用，它们之间应当是相辅相成的。","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://xj8c.cc/tags/ReactNative/"}]},{"title":"我的实习记录","date":"2017-05-31T16:00:00.000Z","path":"2017/06/01/my-internship-record/","text":"2017年7月1、签订劳动合同，转正，实习期结束 2、React-Native 学习研究 2017年6月19日星期一 — 2017年6月23日星期五1、重装系统/开发环境 2、动态表单设计开发完成 3、请假两天回武汉领毕业证、办理党员组织关系手续 4、表单Bootstrap美化 2017年6月5日星期三 — 2017年6月9日星期五1、AC项目上线前的数据增量整理导出导入，Bug修改，业务功能刚改等 2、动态报名表单实现 可创建表单，将创建的表单解析成html，根据创建的表单进行报名登记数据 3、因公司内部原因，居家办公一周，6月15日恢复公司上班 2017年5月31日星期三 — 2017年6月2日星五1、动态表单研究 2、微信编辑器修改出版 3、AC项目需求更改，写业务代码 2017年5月22日星期一 — 2017年5月27日星期六1、仿活动行表单自定义设计器-简版 2、AC项目遗漏问题解决 3、服务器折腾、Hexo+Github折腾 2017年5月15日星期四 — 2017年5月19日星期五1、AC bug修复、需求更改 上线 2、微信编辑器研究，demo 3、自我学习 2017年4月29日星期六 — 2017年5月3日星期三休假2017年5月4日星期四 — 2017年5月12日星期五AC汽车项目需求变更，第二版改版 2017年4月24日星期一 — 2017年4月28日星期五1、AC汽车项目bug修改 2、WordPress数据导出、XML处理、导入数据至sqlserver 3、AC汽车项目第一版完成，需求更改，确定需求，五一放假之后具体实施 4、微信商城相关项目被打回，bug很多，功能没完成、重做重改 2017年4月17日星期一 — 2017年4月23日星期天1、AC汽车项目开发，我主要负责前台，由另一名同事负责后台 2、终端连锁、EMBA、门店托管、产业研究院、论坛活动、盈利商家、咨询、调研、专栏、作者…… 3、19,20,21号晚上加班至9点+、22,23号周末全天加班完成全部开发工作 4、终端连锁：按公司名称搜索、按公司首字母筛选搜索、首次加载10条信息，点击加载更多、详情内容页面 5、门店托管：首次加载5条信息，点击加载更多、是否接手判断、详情内容页面 6、论坛活动：首次加载5条信息，点击加载更多、内容详情页面、依据开始时间结束时间判断活动状态(已开始、已结束、还剩多少天开始) 7、盈利商家：首次加载12条信息，点击加载更多、内容详情页面、合作状态、按类型分类搜索 8、商家入驻、我要联系、我要报名、我要接手、我要合作、发布项目的表单提交 9、调研，专栏，作者：依据现有项目进行二次修改，分类显示不同的页面，调研话题的显示、作者列表、属于作者的文章列表…… 9、banner轮播图，上一页，下一页、新浪腾讯微博分享、微信二维码、返回顶部、全站伪静态…… 10、耗时的功能点：json数据时间格式转换问题、时间的计算问题(临界值)、表单验证提示(SMValidator)、分类搜索功能 2017年4月5日星期三 — 2017年4月7日星期五请假回校答辩2017年4月10日星期一 — 2017年4月14日星期五1、微信商城购买页调整，可在后台设置是否允许开发票，如果订单只含有不可开发票商品，”我要发票”不显示，增加前后收货地址、Email、后台收货地址修改功能，增加显示开发票的金额，购买前必须注册，如果商品为虚拟物品，详情页给出提示：”本商品为虚拟商品，一经售出，概不退换。” 2、AC汽车项目需求更改，数据库创建，开发准备工作 3、当然我在瞎扯API接口开发 2017年3月27日星期一 — 2017年4月1日星期六1、微信商城虚拟物品交付邮件查收打开监控 2、微信商城虚拟物品交付下载地址点击监控 3、程序处理两张图片叠加在一起 4、资讯站采埃孚ZF技术专栏信息展示 5、新闻发布关键发布和定时发布为空验证检查 6、AC汽车项目产品开发会议，需求讲解 7、AC汽车项目开发计划表，4-5天，一个工作日完成 8、AC汽车项目数据库 Table Schema、document created 9、微信商城发送邮件切换至商用系统(Webpower) 10、Web Service 使用学习、接口调用 2017年3月22日星期三 — 2017年3月24日星期五1、入职培训 2、DotNetFrame框架搭建 3、自己学习 4、入职培训考试 - 92 2017年3月21日星期二1、文章关键词报表查询及导出 2、GasgooNewsAuto 资讯站遗漏专题页 2017年3月20日星期一1、电脑中毒，系统重装 2、微信商城项目首页样式更改，热门商品全部显示 2017年3月17日星期五1、资讯站发布新闻分类默认选中功能 2、微信商城维护加载优化 2017年3月16日星期四自我学习看框架源码 2017年3月15日星期三1、索喜专题企业聚焦图片轮播 2、文档转换(word，txt)为PDF 2017年3月14日星期二1、UEditor编辑器图片等比例缩放定制功能 √ 2、UEditor编辑器插入视频在线预览 2017年3月13日星期一1、ASP.NET MVC 2、UEditor编辑器图片等比例缩放功能 3、UEditor编辑器上传视频多终端显示 2017年3月10日星期五1、PC版快速专题 上下翻页状态修复 √ 2、商城项目图片处理、优化 √ 3、每周例会，项目汇报/ReactJS技术分享 √ 2017年3月9日星期四1、PC版快速专题链接增加 √ 2、商城项目图片处理 2017年3月8日星期三1、PC版快速专题 √ 2、li多列图片上下页功能 jQuery分页插件jPages 2017年3月7日星期二1、资讯运营报表 √ 2、Vue.js 3、PC版专题页 2017年3月6日星期一1、资讯站头尾部链接添加 2、报表查询及导出 2017年3月3日星期五1、二维码的显示与隐藏 2、本地加入图片随机展示 3、会议项目汇报，微信小程序技术分享，每周例会主题技术分享 4、Ueditor 上传图片等比例缩放 2017年3月2日星期四1、WEB API访问数据库，json接口 √ 2、.NET WEB API跨域方法配置 √ 3、ajax跨域解析，随机展示图片 √ 2017年3月1日星期三1、原生js实现随机显示图片 2、WEB API 2017年2月28日星期二1、提交实现发送邮件功能 2、高峰论坛移动端专题 签入到SVN 3、jQuery与javascript代码互转示例 2017年2月27日星期一1、正式入职上海盖世网络技术有限公司 2、开发环境配置 3、页面查看更多/收起功能 2017年2月10日星期五提辞职申请，项目整理，第一家实习公司生涯结束 2017年2月9日星期四原生js+css3实现下拉刷新效果 2017年2月8日星期三 - 请病假1天2017年2月7日星期二自我学习，聚餐，简历更新，着手离职 2017年2月6日星期一1、开年第一天上班，例会 2、电脑出问题，重装系统，配置开发环境 3、同事离职，项目交接整理 2017年1月22日星期日最后一天上班，我要回家过年了 2017年1月21日星期六江汉区交通大队网站年前最终版本发布 2017年1月20日星期五前往总公司吃年饭领红包 2017年1月19日星期四江汉区交通大队网站页面修改、IE提示 2017年1月18日星期三江汉区交通大队网站线上测试、改Bug，外出部署项目 2017年1月17日星期二江汉区交通大队网站开发完成，数据填充，线上发布 2017年1月16日星期一江汉区交通大队网站用户签收通知、整合项目 2017年1月13日星期五江汉区交通大队网站后台每日值班、签收用户增删改查登录功能完成 2017年1月12日星期四江汉区交通大队网站后台三层框架、后台登录、签收弹窗、每日值班模块完成 2017年1月11日星期三江汉区交通大队第二版网站党建、新闻、政务、大队长信箱模块完成 2017年1月10日星期二1、麦都网站bug修改 2、江汉区交通大队第二版网站首页完成 2017年1月9日星期一1、麦都网站bug修改 2、网站维护 2017年1月6日星期五1、麦都网站前后台全部完成、发布线上测试 2、至科cktit.com域名接入备案 2017年1月5日星期四1、麦都网站后台课程介绍模块全部完成 2、URL重写实现前台伪静态化 2017年1月4日星期三1、麦都网站后台多层项目搭建，后台整体框架、登录模块、课程介绍 2、购买域名cktit.com相关 3、2016年年终总结 4、至科人员检测资格查询系统后台二维码信息修改 2017年1月3日星期二麦都网站前端页面(自适应PC及手机)全部完成 2016年12月30日星期五麦都网站课程介绍、师资力量、考试资讯完成 2016年12月29日星期四麦都网站前台首页、关于我们完成 2016年12月28日星期三麦都网站前台首页 头部导航、轮播图、简介、讲师、课程介绍栏目 2016年12月27日星期二1、响应式导航 2、麦都网站前台响应式布局解决方案 3、Bootstrap栅格化布局 2016年12月26日星期一1、Sass CSS预处理器 2、Linq… 2016年12月23日星期五1、Linq To SQL 2、NoSql、MongoDB数据库基础 2016年12月22日星期四1、Google Code Prettify 代码高亮使用 2、ASP.NET MVC5官方教程(中文版).pdf(看完) 3、深入理解Bootstrap 2016年12月21日星期三1、ASP.NET MVC5(7层架构) 注册、登录、注销、修改密码功能实现 2、Entity Framework6 Code First 相关 2016年12月20日星期二MVC5 &amp;&amp; EF6 2016年12月19日星期一1、试验室信息管理系统修改意见、PPT 2、ASP.NET MVC 实例学习 2016年12月16日星期五1、至科人员检测资格查询系统添加返回和打印按钮 2、ASP.NET Razor语法 2016年12月15日星期四1、江汉区交警大队网站前台全部完成 2016年12月14日星期三1、江汉区交警大队网站旧版后台代码修改 2、江汉区交警大队网站新版前台代码政务、服务、关于三个页面完成 2016年12月13日星期二江汉区交警大队网站前台代码首页和新闻页面完成 2016年12月12日星期一1、PDF《CSS揭秘》研读 2、江汉区交警大队网站前台代码 2016年12月9日星期五1、Asp.Net 缓存、本地化和全球化、监控和诊断、单元测试、测试驱动开发TDD、配置与部署 2、将博CMS 3、HTTPS网站加密 4、CSS三栏布局 2016年12月8日星期四1、江汉区交警大队网站功能修改 2、瞎JB扯文章详情页面接入百度分享并支持https、自动获取文章内容添加到关键字及描述 2016年12月7日星期三1、前往武汉江汉区交警大队出差,项目部署,需求,改版方案… 2016年12月6日星期二1、江汉区交警大队网站每日值班功能完成 2、留言功能实现 3、首页漂浮窗 2016年12月5日星期一1、至科网站导航修改兼容IE9+ 2、Entity Framework模式、ASP.NET MVC Ajax/分页/认证与授权 2016年12月2日星期五1、网站在线打包成App平台 2、C#的匿名函数 3、江汉区交警大队网站内容以及页面修改 4、网站漂浮窗实现 2016年12月1日星期四1、C#的Attribute 2、C#的预处理指令 3、C#的反射机制 4、C#的正则表达式 2016年11月30日星期三1、C#文件读写操作 IO 2、C#委托 Delegate 3、C#异常处理 ExceptionHandle 4、C#事件处理机制 Event 5、C#索引器 Indexer 6、C#泛型 Generic 7、ASP.NET MVC Introduce 2016年11月29日星期二1、Asp.Net MVC学习 2、武汉至科检测技术有限公司网站、武汉东方建设集团建筑设计院网站、武汉至科检测技术有限公司论坛 3个网站功能清单整理 2016年11月28日星期一1、喵呜网 站点搬家 备份MySQL数据库 打包整个站点代码文件,通过FTP工具将其下载至本地 修改配置文件 上传至新服务器,导入MySQL数据库 解析IP地址,刷新本地DNS缓存 访问成功,搬家完成 2、中电云集-云主机助手 工具 3、Bootstrap Application 4、CSS绝对底部方案 2016年11月25日星期五1、npm包管理工具 2、Markdown语法 2016年11月24日星期四1、图片裁剪生成不同尺寸 2、全屏背景轮播循环案例 3、检测资格查询系统信息上传 2016年11月23日星期三1、SAE Sina 2、C# ConsoleApplication 2048 2016年11月22日星期二1、HTML5 2、至科网站导入报告、页面改写维护 3、借助Flash完成图片批量上传 2016年11月21日星期一1、Github项目整理、静态资源上传 2、Bolg更新 3、前端插件学习以及整理 2016年11月18日星期五1、Layui 文档学习、Demo练习 2、至科网站报告添加跟踪维护、技术指导 3、本地在线学习/网校搭建 2016年11月17日星期四1、json序列化、反序列化 2、在线搭建网校的方案 3、JSHelper运用 2016年11月16日星期三1、Git命令学习 2、网站Rewrite防盗链配置文件 3、至科网站报告查询更新至线上 4、本地网校平台搭建解决方案 2016年11月15日星期二1、自制html源码查看工具 2、VUE.JS、Jquery文字提示插件 3、Git命令学习 4、看书jQuery开发从入门到精通 2016年11月14日星期一1、集团网站logo修改 2、优仕德网站footer修改 3、自适应全屏banner Demo 2016年11月11日星期五1、在线学习平台搭建解决方案 2、武汉东方建设集团网站维护修改 2016年11月10日星期四1、Excel数据导入SQLServer完成 2、报告查询码提取器小工具 2016年11月9日星期三1、HTML5 Canvas 2、Excel数据导入SQLServer 3、上传报告页面代码编写 2016年11月8日星期二1、Lims框架 2、至科报告添加 3、HTML5 localStorage 本地存储与读取 4、有关二级域名的知识学习以及全站https加密处理等 2016年11月7日星期一1、七牛云存储SDK 2、C#上传图片至七牛云 2016年11月4日星期五1、登陆页面重写、优化 2、框架搭建 2016年11月3日星期四1、url重写研究,页面伪静态技术 2、Vue.js学习 2016年11月2日星期三1、 Liger UI API 2、代码发布，上传上线 3、JS算法案例学习 4、C#后台代码优化功能点实现 2016年11月1日星期二1、 Liger UI API 2、NextEasy .net快速开发平台 3、一般处理程序 2016年10月31日星期一1、 Liger UI框架搭建修改 2、 Asp.net URL重写 3、一般处理程序+html+ajax 2016年10月28日星期五1、jQuery Liger UI框架 2、Bootstrap 3、Webqic快速开发平台 2016年10月27日星期四1、jQuery学习、案例代码编写 2、RoadFlow框架修改 3、jQuery Liger UI API、Demo学习 4、jQuery Liger UI框架搭建 2016年10月26日星期三1、权限管理框架申请及其查看 2、Sina SAE 3、.Net多图上传案例 4、源码学习 2016年10月25日星期二—科目四考试(结束驾考生涯，驾驶证到手)2016年10月24日星期一1、搭建在线慕课平台框架选择和方案的整理 2、权限管理框架 3、FineUI 通用权限管理框架（AppBoxPro） 4、FuneUI ASP.NET 控件库 Demo 2016年10月21日星期五1、优仕德交互效果修改 2、整合代码，转移至新服务器 3、H+后台UI框架 2016年10月20日星期四1、后台UI 2、Sina SAE 3、优仕德项目 4、jquery实例运用 5、前端知识点总结 2016年10月19日星期三1、360等国产浏览器兼容性 2、优仕德项目导航显示效果js修改、页面修改、搜索框百度搜索js 3、githup学习 2016年10月18日星期二1、至科检测接入加密UKID登录 2、Bug修改 2016年10月17日星期一1、至科检测工作流登录页面3种方案 2、优仕德Bug修改 2016年10月14日星期五1、文件断点续传技术 2、至科人员检测Bug修改、页面重写、兼容主流浏览器 3、优仕德教育项目Bug修改、页面调整维护 4、Hexo+GitHub学习研究 5、IE不支持placeholder属性的解决方案研究 6、Validator、jquery全选/反选 Demo 2016年10月13日星期四—考试科目三2016年10月12日星期三1、优仕德项目招考信息列表详情页 2、优仕德项目分页PageHelper 2016年10月11日星期二1、Html、css编码规范html页面编写 2、Webservice 3、Html全屏背景自适应效果demo 4、优仕德项目后台详情页面 2016年10月10日星期一1、培训机构HTML代码 全部完成 2、项目发布 2016年10月9日星期日培训机构HTML代码完成90% 2016年10月8日星期六1、发布至科监测类项目简报网站至服务器 2、至科报告协助上传、维护 3、培训机构HTML代码 2016年9月30日星期五1、微信公众号处理 2、地图标注 3、网页结构分析、代码编写 2016年9月29日星期四1、百度地图标注接入数据库、本地查询案例 2、微信公众号 3、至科网站维护小Bug修改 2016年9月28日星期三1、百度地图自定义标注研究 2、结合数据库动态添加标注案例 3、动态解析数组学习 2016年9月27日星期二1、地图标注研究以及案例 2、至科报告查询代添加 2016年9月26日星期一1、至科微信公众号菜单添加 2、后台UI框架 2016年9月23日星期五1、ASPOSE.WORD 操作Word Demo 2、PHP基础语法学习 3、微信公众号开发学习 4、文档，文件，项目整理 2016年9月22日星期四1、WeX5 App 打包 2、Oracle 基础学习 3、.Net 奇淫巧技 2016年9月21日星期三1、WeX5 Baas.Net环境部署完成 2、Base.Net后端开发学习 3、研究微信公众号开发 4、 微擎平台搭建学习 2016年9月20日星期二1、WeX5 hybrid APP开发学习 2、WeX5 Baas.Net环境部署，需要VS2015最新版本 3、本地应用打包学习、观看WeX5 在线学习文档 4、2048 APP案例 2016年9月19日星期一1、WebAPP学习 2、移动端框架jquery.mobil 3、网站维护 4、WebAPP 火车票查询案例 2016年9月18日星期日1、上线集团网站 2、至科网站维护 2016年9月5日—2016年9月14日请假练车考试科目二2016年9月2日星期五1、源码整理归档，数据库备份 2、Asp.Net Mvc学习 2016年9月1日星期四1、Asp.Net MVC 学习 2、电子宣传册在线制作 2016年8月31日星期三1、电子宣传册 2、集团网站Bug修改、维护 3、Entity Framework学习、EF三层搭建，增删改查案例 2016年8月30日星期二1、WebApp方案 2、WeX5开源移动开发框架 3、Entity Framework了解学习 2016年8月29日星期一1、电子宣传册 2、网站维护 3、ASP.NET MVC学习 2016年8月26日星期五1、Hadoop核心架构研究抄录 2、C#语法糖(自动属性、隐式类型、匿名类型、Lambad表达式…) 3、C#，T4模板学习 2016年8月25日星期四1、集团网站维护、时间修改 2、至科网站维护、文字修改 3、电子宣传册 2016年8月24日星期三1、检测单位上岗人员检测资格查询系统完善 2、Node.js 3、集团网站新闻时间修改、维护 2016年8月23日星期二1、继续集团网站备案 2、QR-Code二维码生成 3、至科检测资格信息管理系统 4、工作室网站美化调整 2016年8月22日星期一1、至科网站导航检测报告真伪查询修改 2、检测人员资格查询后台界面修改调整 3、短信验证提交容联审核通过，根据审核通过模板Id修改短信验证，现都可查询 4、添加无验证查询页面用于二维码扫描查询 5、集团网站接入阿里云备案 2016年8月19日星期五1、集团网站、设计院网站、至科网站维护 2、至科检测人员资格信息管理系统 3、.Net Ajax应用与学习 2016年8月18日星期四1、设计院网站Bug修改，信息替换，导航调整，招聘英才列表显示调整 2、至科网站Bug修改，热点检测项目滚动特效，图片修改，添加试验室信息管理系统链接，查询系统下报告查询添加验证码限制查询功能 3、至科检测人员资格信息管理系统页面修改，增加图片验证码限制功能 2016年8月17日星期三1、至科人员资格查询系统上线 2、至科、设计院、路博特网站更新需求、Bug修改 3、至科、设计院网站后台增加上传新闻图片功能 4、极验验证码 2016年8月16日星期二1、至科检测资格信息查询系统本地发布进行后台测试 2、检测资格查询系统Bug修改 3、H5 &amp; CSS3 实战书看完 2016年8月15日星期一1、至科检测资格信息查询系统静态页面完成 2、表单验证js完成 3、后台用户查询登录三层代码完成 4、登录页面保存用户信息至数据库完成 5、手机验证码发送并校验完成 6、点击弹窗显示和关闭 7、修改路博特页面文字错误 8、美化至科检测资格信息查询系统后台 9、至科检测资格信息查询系统前后台完成，可接入容联短信平台进入测试阶段 2016年8月12日星期五1、学习node.js 2、至科、集团、路博特网站代码修改整理 3、转达任务至团队人员，转发邮件 4、上传代码，上线网站 5、至科资格检测信息管理系统对接 2016年8月8日—2016年8月11日请假回家休息第十六周总结本周完成工作 1.集团网站Bug修改 2.路博特网站框架、数据库搭建 3.三层代码以及解决方案模块 4.容联短信验证接口代码实现、文档说明 5.各个版本代码整理、备份管理… 本周工作总结 本周主要完成了集团网站的Bug修改，经过测试之手，网站存在很多Bug，都是在开发过程中疏忽的。软件测试这个环节在软件行业中是至关重要的，很多人认为软件开发中贡献最大的人是开发人员，这个观点不能否认，但是软件测试人员也扮演着非常重要的角色。经此次开发过程遇到的一些问题，学到了不少经验。在填充数据的时候遇到一个SQL错误，.Net SqlClient Data Provider，经过查阅资料，分析原因，最后得以解决并且进行记录(SQL错误：.Net SqlClient Data Provider)… 下周工作计划 下周请假，回家好好休息，上班后好好工作。 2016年8月5日星期五1.集团网站后台公益事业、活动剪辑详情页面 2.容联短信验证接口代码实现、文档说明 3.事业单位等培训机构网站 4.路博特网站交接、后台页面图标logo、链接更换 5.集团网站Bug修改完毕 6.至科、集团网站源码发送 2016年8月4日星期四1.容联短信接口文档学习 2.Demo,暂时只可以实现接收收短信，未进行验证。 2.集团网站Bug修改 2016年8月3日星期三1.集团网站Bug修改 2.Lbt网站3层代码完成 3.后台解决方案模块完成 2016年8月2日星期二1、集团网站Bug修改 2、Lbt网站简介模块完成 3、各种琐事… 2016年8月1日星期一1、集团网站完成 2、上传Lims管理系统 3、Lucene.Net+盘古分词学习 4、Lbt数据库 5、Model代码 第十五周总结本周完成工作 1.集团网站后台功能已全部实现 2.前台数据绑定完成90%左右 本周工作总结 集团网站从前台到后台，收获颇多。 本周开始着手写集团网站后台代码，因为是自己写的前台页面，所以对整个页面的架构是一目了然的。 首先根据前台页面创建了网站数据库。让后利用代码生成器生成网站Model层代码，对于代码生成的好处就是可以减轻工作量，因为网站涉及到30来个数据表，如果是手写Model层代码会耗费大量的时间。 根据生成的Model层代码手写Dal与Bll层增删改查的代码。这个耗费了我大量的时间。可以说在三成架构中，网站的Dal层其实就是网站的灵魂，所有的增删改查分页查询等等都离不开Dal层。 分页用的存储过程，存储过程的好处有很多，运行速度快，可以接收参数、输出参数、返回单个值或者多个结果集以及返回值。这样网站相对来说会比较稳定。 然后在后台开发中，用到了多图上传，因为之前没有做过，便在网上学习了一下多图上传的案例，总的来说我有两种解决方案，一种是多图上传的插件，这个比较强大，学习了一下弄懂了其原理，另外一种便是循环上传图片，因为多图上传还是需要一张一张的上传，这个比较简单，由于时间和效率的原因，我采用了循环上传。 最后一个便是缩略图生成，这个在网上找的现成的生成缩略图的一个方法，看了一下代码，可以高按照度或者宽度的比例来生成对应的缩略图，而且也不会对图片造成变形。直接调用，在前台资质资格、集团荣誉、领导关怀三个模块用上了。 一个工作日的时间，完成了集团网站后台所用逻辑代码，以及前台90%的数据绑定。 下周工作计划 1.网站数据添加完毕 2.交由测试人员进行测试 3.配合测试人员进行Bug修改 4.完善手头上的工作，休假一星期 2016年7月29日星期五1.工程业绩模块 ① 竣工工程 - 增删改查、分页列表、分类查询、前台数据绑定 ② 在建工程 - 增删改查、分页列表、分类查询、前台数据绑定 ③ 设计工程 - 增删改查、分页列表、前台数据绑定 2.企业文化模块 ① 公益事业 - 增删改查、多图上传、前台数据绑定、轮播显示 ② 活动剪辑 - 增删改查、多图上传、前台数据绑定、轮播显示 3.联系我们 - 全部完成 4.友情链接 - 全部完成 5.后台首页 - 文字更换、logo修改、页面修改美化优化 6.后台修改密码功能完成 7.后台整体页面搭建完成 8.前台数据绑定完成 2016年7月28日星期四1.集团网站工程业绩模块 ① 竣工工程后台增删改查，图片上传，列表显示，分类查询 ② 在建工程后台增删改查，图片上传，列表显示，分类查询 ③ 设计工程后台增删改查，图片上传，列表显示 2.集团网站企业文化模块 ① 公益事业后台增删改查，多图上传并显示 ② 活动剪辑页面添加完成 2016年7月27日星期三1.集团网站联系我们模块 ① 在线留言完成 ② 联系方式(站点信息)完成 2.友情链接前台数据绑定 3.学习多图上传，实时预览代码 2016年7月26日星期二1.友情链接模块增删改查 2.企业文化模块 ① 企业理念Update ② 党团建设增删改查 3.人力资源模块 ① 简历投递上传下载 ② 学习平台增删改查 4.联系我们页面搭建完毕 2016年7月25日星期一一、集团网站 1.新闻中心模块 添加、后台列表展示、删除、分页查询、分类型查询完成 2.科技创新模块 ① 技术中心、科研领域修改功能完成 ② 科技成果添加、后台展示、删除、分页查询、分类型查询完成 3.人力资源模块 ① 人才战略修改功能完成 ② 人才聚集添加、后台带缩略图展示、删除、分页查询完成 ③ 人才招聘添加、后台展示、删除、分页查询完成 二、至科网站 1.整理上线所缺数据文档 2.修改至科网站Logo及导航菜单颜色 三、路博特网站 1.路博特主机域名绑定 2.上线路博特静态页面网站 第十四周总结本周完成工作 1.至科网站上线工作(代码整理、数据填充…)完成 2.路博特网站所有HTML静态页面完成 3.路博特网站后台数据库搭建完成 4.路博特网站后台3层框架代码搭建完成 5.路博特 网站域名备案成功 6.集团网站所有HTML静态页面完成 7.集团网站项目计划流程图 8.集团网站后台数据库搭建完成 9.集团网站后台登录模块、关于集团模块完成 本周工作总结 本周在三个网站之间来回切换，至科网站上线工作完成，只差备案成功，上传代码，算是告一段落。 公司内部网站改版，独立完成了PC版及手机自适应版静态页面路博特网站，一并完成后台数据库的搭建及网站3层框架的搭建。 主要时间还是花在集团网站上，集团网站页面众多，虽说有部分重复页面，但是也还是达到了36个页面。花费了我很多时间来完成，美工多次外出办公回来传达需求，修修改改终于在周四完成了所有页面，然后马不停蹄创建数据库，搭建后台框架进行项目计划安排分析。现已经完成登录模块、关于集团模块的后台代码。 下周工作计划 1.全身心投入到集团网站后台开发当中去，按计划表进行开发，在周末之前完成所有后台逻辑代码 2.配合完成至科网站上线及备案工作… 2016年7月22日星期五集团网站后台 1、Model层所有代码完成 2、登录模块完成 关于集团模块 1、集团简介、董事长致辞、组织结构三大模块Update完成 2、资格资质、集团荣誉、领导关怀，标题，多图上传，列表展示，存储过程分页查询完成 新闻中心模块—新闻中心模块界面搭建完成，数据访问层(Dal)代码完成 2016年7月21日星期四1、Lbt网站数据库搭建完毕 2、Lbt网站三层框架搭建 3、集团网站项目计划图 4、集团网站数据库搭建完毕 5、集团网站三层框架搭建 6、集团网站后台页面框架搭建 2016年7月20日星期三1、集团网站静态页面全部完成 ① 领导关怀页面完成 ② 技术中心页面完成 ③ 活动剪辑详情页完成 ④ 公益事业、公益事业详情页完成 ⑤ 科研领域完成 ⑥ 简历投递完成 ⑦ 学习平台、学习平台详情页完成 2、集团网站后台数据库搭建 2016年7月19日星期二1、集团网站修改添加页面 ① 工法标准改为工法，增加技术规章类型 ② 水利建设工程改为园林绿化 ③ 工程业绩模块增加设计工程页面 ④ 工地整理工程改为土地整理工程 ⑤ 后台数据库搭建 2、路博特 网站域名备案成功，新增设计院 网站打印核验单初审通过，待邮寄核验单。 2016年7月18日星期一1、至科网站上线数据填充 2、集团网站页面添加和修改 3、分配至科网站数据填充任务给ZouXueXia 4、jquery插件学习及使用 第十三周总结本周有事请假了一天，首先这一周完成了路博特静态网站，PC版和手机版自适应页面 路博特网站备案告一段落，静等管局审核完成 着手至科网站上线任务，修改了至科网站的一些bug和新增了一些功能(登录UKID验证) 集团为网站因需求而进行修改压面，添加页面 计划下周将至科网站上线全部完成，开始集团网站前后台和路博特网站后台代码编写 2016年7月15日星期五请假一天… 2016年7月14日星期四1、完善路博特网站页面 2、路博特数据库搭建 3、至科网站：新闻中心-至科空间模块完成 4、至科网站：服务项目模块修订整改 5、后台测试数据删除，数据库测试数据清空 6、整合至科网站源码、部署版代码，随时可以上线 7、集团网站：人力资源-添加人才聚集模块、首页-banner图更换… 2016年7月13日星期三1、路博特网站静态页面全部完成 2、至科网站页面信息修改 3、至科后台登录加入UKID数据验证 4、最新版至科网站发布与上传 2016年7月12日星期二路博特网站 首页、走进路博特、解决方案、解决方案详情页、新闻资讯、加入我们、联系我们-页面完成 新闻资讯详情页，无样式模板 产品与解决方案公用一个页面。暂时没有多余的项目，建议导航目前只放一个解决方案，产品保留，需要的时候可以加上。 2016年7月11日星期一1、提交备案信息(管局审核中)，等待审核结果 2、学习Node.js 3、整理有关OA、CRM、ERP…解决方案的展示文字 4、整理路博特网站相关资料 第十二周总结这周完成了公司集团网站的所有静态页面，这是我在公司做的第三个项目了。感觉好累，现在有点力不从心，没有刚开始的激情了。 大夏天，好友同学们都回家避暑去了，然而我已经很早就没有暑假可言了。 马上出来实习就三个月了，好想回家，从过年到现在都没有回过家，想回去看看。 2016年7月8日星期五1、教育局Js代码加密 2、Node.js学习 3、集团网站导航修改 2016年7月7日星期四1、打印网站备案核验单 2、修改集团网站静态页面 ① 工程业绩模块：竣工工程、在建工程修改为图文展示样式 ② 工程业绩详情页 3、网站所有信息及联系方式修改 4、数据库：(用户、新闻中心、新闻类型、工程业绩、业绩类型、联系我们-在线留言、联系我们-联系方式）表创建 2016年7月6日星期三湖北武汉，暴雨，休息一天 2016年7月5日星期二1、集团网站静态页面全部完成 2、放弃之前路博特域名，进行新网站备案 3、网站备案，核减单待打印上传 4、集团网站需修改部分信息 2016年7月4日星期一1、集团网站 - html页面 ① 新闻中心模块完成 ② 科技创新模块完成 ③ 人力资源模块完成 ④ 企业文化模块完成 ⑤ 联系我们模块完成 2、集团网站页面美化 第十一周总结本月工作内容 1、设计院网站 2、至科网站 3、集团网站 4、路博特网站 5、有关域名备案等相关工作 本月工作总结 1、设计院网站两个版本的前台页面 2、分工合作，完成设计院数据库设计，后台代码编写 3、至科网站前台页面 4、至科网站后台代码编写 5、经测试修改两个网站存在的Bug，达到可以上线的版本 6、正在进行集团网站前台页面的代码编写 7、域名备案等工作 8、工作需求中的自我学习(Asp.Net存储过程、JS各种动画效果、H5+CSS3全新前端代码、寻找论坛BBS源码、Asp.Net富文本框使用案例) 下月工作计划 1、集团网站前端页面 2、集团网站后台代码 3、路博特网站前端页面 4、路博特网站后台代码 5、工作中的其它任务 6、自我学习 4月份来公司，至今也已两个多月了。 马上就是3个月了，学到了很多，也领悟了很多。 7月份想要请假休息几天回家一趟，感觉有点疲惫。 2016年7月1日星期五1、集团网站首页全部完成 2、关于集团模块(集团简介、董事长致辞、组织结构、资质资格、集团荣誉、领导关怀页面)完成 3、工程业绩页面(竣工工程模块) 4、提交工信部域名注销备案申请 2016年6月30日星期四1、集团网站首页 2、域名注册证书 2016年6月29日星期三1、跟进花生壳域名过户，填写过户原因 2、修改至科网站导航样式、联系我们页面 3、JS速度动画、透明度动画、缓冲动画、多物体动画、链式动画、同事运动案例，万能运动框架编写 4、集团网站首页代码编写 2016年6月28日星期二1、联系花生壳办理域名过户… 2、查看，对比后，提供企业邮箱的两种方案 3、寻找Asp.Net版BBS源码 2016年6月27日星期一1、修改设计院和至科两个网站的bug 2、JS划入划出特效学习 第十周总结本周完成工作 1、两个网站的bug修改 2、至科网站的后台编码，前台数据绑定，功能模块全部完成 3、提交了设计院网站的最终版本 4、报告查询模块查询报告 5、整合了至科网站最终版本含源码版和部署版 本周达到了预期结果： 1、设计院的网站告一段落，全部完成 2、至科网站前后台全部完成，经测试修改整合也已完成改版 正在进行中的事情： 1、路博特网站 2、集团网站 下周工作计划 1、编写集团网站静态页面 2、后台管理系统 3、路博特网站 2016年6月24日星期五1、安排今日任务 ① ChenXia：集团网站设计、以第一版为主 ② ZouXueXia：设计院网站和至科网站总体测试 ③ PengYun：路博特网站前台/后台(从后台开始) ④ MySelf：集团网站前台页面HTML代码，跟进设计，提出建议，修改方案 2、分享完整的富文本框编辑器Demo 3、整理总结文件上传与下载的功能知识点 4、整合至科网站最终版本含源码版和部署版 5、Web前端css工作流，代码技巧，语法糖学习 6、集团网站首页头部logo、右侧搜索、导航栏 2016年6月23日星期四1、修改至科测试所提交的Bug 2、发布最新版本提供测试人员进行反测 3、反测bug修改，测试完成，发布服务器，至科网站到达一个节点 4、修复文件下载模块，文件下载无法打开问题。 2016年6月22日星期三1、协助网站备案，邮寄核验单 2、整合设计院网站最终版本含源码版和部署版 3、修改至科网站测试所存在的bug 4、更改至科网站所有时间统一为年月日形式 5、报告查询中修改报告信息时显示所有信息 6、报告查询添加日志管理模块，协同完成 2016年6月21日星期二1、报告查询之增加查询码功能模块 ① 增加查询码字段，修改3层数据 ② 完成带有查询码功能的增删改查 ③ 依据报告编号使用不可逆算法MD5加密截取其中5位字符串保存至数据库 ④ 前台报告查询功能初步实现 2、至科网站整体调试修改，总体功能需求全部实现 3、部署至科网站提交给测试人员进行测试 4、设计院网站域名备案信息等若干问题 2016年6月20日星期一1、申诉路博特域名账号密码相关信息，找出问题所在 2、联系花生壳官方客服，找到修改账号密码解决办法 3、至科网站任务规划 4、至科网站后台报告查询模块增删改查 5、至科网站前后报告查询模块查询功能 ① 依据报告编号精确查询 ② 为空提示 ③ 不存在给出提示 ④ 正确显示查询信息 ⑤ 依据后台填写报告内容，填多少信息，查出来就是多少信息 6、接收路博特设计网页设计方案，分析效果，实现难度，不合理之处… 7、至科后台部分修改 ① 友情链接模块修改 ② 所有页面防止不登录直接访问 第九周总结写总结，坚持的也有两个月了，收货颇多。 这周同学聚餐了，喝的酩酊大醉，还记得大一那会，懵懵懂懂，一转眼大学都已经快要结束了。 这周写了美工设计的所有psd页面，写完前端继续协助做后端。改了测试给的上个网站的bug。希望在下周完结手头上的所有事。因为报考了驾校一直没时间去练车，准备在忙完手上的项目请假一个星期回学校去练车，一直拖下去也不是办法。 今天父亲节，突然想家了，半年多了还没回去过，等待下一个小长假，我想回家看看。 …不想写了，烦！ 2016年6月17日星期五1、至科网站页面修改，添加新功能 2、后台主页添加时钟 3、修改密码功能 4、后台查询报告模块 5、动态添加检测参数信息 6、查询报告模块添加功能 7、至科待办事项分配 2016年6月16日星期四1、查看提交的测试缺陷报告 2、分析缺陷报告中的bug 3、修改设计院网站bug及规避bug 4、合并整合至科网站代码 5、报告查询页面 6、报告查询表数据库设计 7、数据字典整理 8、至科后台图片替换，页面添加修改美化 2016年6月15日星期三1、装系统 2、搭建论坛 3、创建设计院网站下载中心、友情链接两个表 4、根据需求手写model、dal、bll三层代码 5、完成后台下载中心之上传文件功能 6、后台下载中心文件管理功能 7、文件信息列表分页、删除功能 8、前台所有页面转换为aspx页面 2016年6月14日星期二1、人力资源模块完成 2、联系我们模块完成 3、添加禁止选中页面内容脚本(可选) 4、添加禁止鼠标右键脚本(可选) 5、至科页面全部实现完成 6、至科页面思维导向图 7、服务器中配置MVC项目 8、和PengYun交流后台页面搭建及代码实现 9、至科后台代码，文件上传与下载Demo 2016年6月13日星期一1、修复设计院网站bug 2、至科网站 1.关于至科模块，公司简介、荣誉资质、试验室、工程业绩4个页面完成 ① 图片瀑布流布局 ② 图片大图弹窗浏览 2.服务项目模块，地基基础工程检测、建筑幕墙工程检测、钢结构工程检测、主体结构检测、节能检测、工程设备检测6大页面完成 3.下载中心模块，委托单下载、规范下载2个页面完成 4.新闻中心模块，公司新闻、行业新闻、新闻详情3个页面完成 5.整个网站禁止复制内容 第八周总结刚刚过完端午，相信大家都有吃粽子吧，呃…反正我没吃。 这一周，总感觉是上一周，可能是玩了三天，糊涂了，这一周完成了一个项目。 整个项目的一大半由我一人完成，其中包括：前台静态页面，利用HTML5+CSS+JavaScript编写、提供一套后台UI、后台6) 三层框架搭建、整体优化布局、登录模块、新闻资讯、招聘英才、数据库三个表的设计。。。 今天周日，因为放了三天假，所以今天正常上班，又接手了一个新的项目，和上一个项目类似，可又不类似，总之是多了很多细节，看似简单的页面，却要调试很久。各种特效，用户交互效果也很多。写了一天多一共写了三个页面，第三个页面还没有完全完成。有点吃不消了，作为一共.Net开发，却被公司用来写前端页面，写完前端页面又要继续跟踪后台代码。。。一个网站十几个页面，全由我一个人完成，没日没夜的写。 是不是应该和经理提出…嗯，我需要一个助手，页面太多了吃不消。希望有人能帮我分担一下。这样我也不用那么累。是吧？ 2016年6月12日星期日1、至科网站 – 首页 ① 首页总体代码完成 ② 至科集团简介、热点检测项目、新闻资讯三大小模块完成 ③ 底部二维码/公司信息/友链 2、关于至科/公司简介页面完成 3、荣誉资质页面 – 难点 4、查看设计院网站测试bug并修改 5、和PengYun对接至科网站后台功能 6、对至科网站图片内容、大小提出疑问并让美工修改 2016年6月9日星期四 - 2016年6月11日星期六 - 端午节放假2016年6月8日星期三1、修改设计院网站遗留Bug ① 后台上传图片给出建议像素提示 ② 服务项目模块每页显示12条数据 ③ 修改翻页无效问题 ④ 修复上传图片重名的弊端 2、至科网站 – 首页 ① 首页总体设计 ② 头部加入收藏JS效果 ③ 炫酷3D导航栏 ④ 首页banner图轮播 ⑤ 首页内容区布局 2016年6月7日星期二1、整合设计院网站 2、开发文档编写 3、设计院后台图片处理 4、所有代码整理，美化 5、至科网页样式交涉分析 2016年6月6日星期一1、设计院网站 2、修改密码功能 3、后台页面修改 4、快捷编辑 5、存储过程分页 第七周总结七七四十九了。本周接手了公司的一个项目，相对来说比较忙，今天还加了一整天班。 这一周完成了美工所设计的第二版设计院PSD，整整十几个页面加部分JS特效，修修补补总算完成。然后写完页面继续跟着做后台。截至周日，我所负责的两个模块，新闻信息发布和招聘英才后台增删改查，前台显示，分页查询等等已圆满完成。 期间，遇到好几个坑，然后又自己填坑，所有数据访问都是自己手写，以往都是添加和显示在不同的页面，这一次这个后台添加和显示在同一个页面，是一个Tab切换效果。涉及到修改传值到添加那里显示出来。久久不能解决，最后静下心来想了想解决方案，然后成功解决。 然后就是利用了存储过程，写了一个数字分页查询。现在，对于我来说，一个项目的增删改查已经不是问题了。从前台到后台，都能信手拈来，这种感觉很好。不过还是有些不足，很多技术还是不会，希望能继续接触一些前沿的技术，达到.net行业的标准。今天很累，在公司写了一天代码。天气热加上上火，真是难受。 就先总结到这里吧，2016年6月5日22:33分。 2016年6月3日星期五设计院网站第二版终结 学习网页相关知识 设计院后台招聘信息模块 2016年6月2日星期四设计院网站设计 2016年6月1日星期三1、设计院网站 2、近期工作总结 3、开会内容 ① 教育局项目 ② Lims项目 ③ OA ④ 设计院网站 ⑤ 手提袋 ⑥ 至科网站改版升级(报告查询) ⑦ Lbt网站改版升级 2016年5月31日星期二1、设计院网站数据库 2、设计院网站页面 3、设计院网站后台 2016年5月30日星期一1、SQL架构+数据导入导出 2、学习JS解析json 3、C#.Net解析json 4、响应式Web设计 HTML5和CSS3实战 5、H5全新语义化元素整理总结 第六周总结这周过得比较快，只上了三天班，请假了两天。周一完成了设计院网站的第一个html版本，周二周三回学校去了。 转眼间，马上就要毕业了。回学校照了个毕业照，然后毕业证头像采集，让室友陪我打了几把LOL，哈哈，原来我是真的很坑。 这周接触了一个新的UI，FineUI。基于 jQuery / ExtJS 的 ASP.NET 一个控件库，由来自中国的程序员 三生石上 和 RingoDing 创建并维护。在博客园中看到的，然后一路跟随到FineUI官网，并瞅了瞅，感觉还不错。利用其拖拖拽拽就完成了一个demo。不过好归好，在其华丽的背后总有那么些不足之处，这还是服务器端控件，严重的拖慢了网页加载速度，而且异常的臃肿。就不与其它UI作比较了，毕竟各有各的优势。 嗯，还有就是我在腾讯云买了一个服务器。最低配置的那种，不过对我来说可以用了。我将自己做过的项目都挂上去了，拿来测试、瞎折腾还是可以的。 马上第七周了，这一周应该会很忙，设计院的网站开始做了，框架已经搭建好，只等数据库设计完成了。然后我还要更改网站样式，因为第一版略显丑态，不太合适，美工又重新设计了新的样式。黑暗的世界马上来临。 2016年5月27日星期五1、搭建设计院后台3+层框架 2、数据库搭建分析 3、后台UI修改 4、折腾服务器，将自己的项目上传至服务器 2016年5月26日星期四1、分析设计院网页实现方法 2、学习FineUI 3、利用FineUI完成登录Demo 2016年5月25日星期三上午毕业证头像采集，下午照了毕业照 2016年5月24日星期二请假的第一天，今天返校了 2016年5月23日星期一1、完成设计院网站的设计 2、响应式Web设计学习 3、看书《H5和CSS3实战》 第五周总结第五周了，公司走了个同事，是我在第一周总结中提到的一个学长。在之前，他就跟我说过，他干不长，不喜欢公司的这种模式，他认为学不到东西。所以他告诉我，他忍不住了，要辞职了。两个字，呵呵~ 这周，感觉过得蛮快，周一跟经理一起出去了一趟，早早地起了床，真正体验到了一把，客户就是上帝。对，没错，我们去见客户了，本来是去部署项目的，可是，压根不是我想的那样，被打回来了，客户的随便一句话，可能在他认为就一个小小的东西，我们都要修改半天。…后来还好，虽然还有不少问题，但是第二天如期上线了。 不知不觉，已经到五月下旬了，来这个公司是4月18号到今天也有一个月零4天了。差不多什么也都摸清楚了，鉴于第一份实习工作，还是老老实实待下去，既呆之则安之。 最近老是忧心忡忡的，也不知道怎么回事，仔细想想，也就那回事，每天上班下班挤公交，回到小窝睡大觉。 可能是报考了驾校的原因，因为是之前没工作在学校报的，考了科一，直到现在车碰都没碰过。两个字：惆怅。现在也没时间回去学，不知道什么时候能拿到驾照！ 明天又是星期一，是我最不喜欢的一天，因为明天早上的车有个特点，那就是特别堵特别堵特别堵。。。 2016年5月20日星期五1、继续编写页面 2、开会总结 ① 教育局登记系统成效及不足 2016年5月22日星期天 1、下午公司加班写了个页面 2、开会 ① GuoHongYu，教育局登记系统 ② JiDaoMiao，至科检测工作流平台 ③ Me，设计院网站 2016年5月19日星期四1、OA debug 2、编写信义东方网页 2016年5月18日星期三1、JS特效学习 2、幼儿园系统后台界面美化 3、提交一个月工作感受 4、晚上会议 ① 月度总结 ② 工作日志，计划性 ③ 设计图定稿 ④ Lims系统 ⑤ OA 2016年5月17日星期二1、解决幼儿园系统时间转换问题 2、电脑死机蓝屏进不了系统，重装系统 3、学习前端知识 4、和ChenXia沟通设计样式，分析实现效果 5、晚上会议 ①项目部署完成，教育局报名系统告一段落 ②测试人员~ ③多浏览器的兼容性 ④敏捷开发 ⑤接下来重点Lims产品、设计院网站 ⑥每天的工作日志、工作状态、工作计划 ⑦需求分析… 2016年5月16日星期一1、跟随外出学习 2、帮助中心 3、引导页面窗口调整 4、报名页面弹窗提示 5、服务到期功能 第四周总结差不多也一个月了，第四周也结束了。本周主要围绕公司两大项目走，事情特别多，加了很多班，周日加了一整天班，周六陪女朋友一天。 报名系统周一上线，希望能够完美通关。不然又要苦了我们这些实习生，一个多星期的修修补补，功能完善，测试，改bug…乐此不疲。 还有就是公司内部的工作流项目，确立了新的需求，利用开源框架roadflow二次开发，个人感觉虽然节省了很多时间，但是来改人家的框架是多么不容易的一件事，有种生拽硬拉的感觉。特别不爽。不过，对于实习生的我来说，只能处理项目的边边角角。啦啦啦~ 本周公司发了我第一个月为期10天的实习工资，中间出了很多小波折，希望下个月发工资的时候可以解决。 2016年5月15日星期日1、帮助中心页面 2、报名改登记 3、修改图片文字 4、测试… 2016年5月13日星期五1、教育局报名系统代码 2、学会填写报销单，报销加班打车费用！ 3、测试教育局报名系统 4、至科代码 5、编写两个html页面 2016年5月12日星期四1、处理图片显示逻辑，房产证和购房合同上传了哪张就显示哪张，没上传显示默认图 2、增加居住证图片显示，没上传显示默认图 3、教育局和学校各页面图片显示，默认图片的处理 4、教育局报名系统2016年秋季小学起始报名登记工作开始啦展示框 5、教育局报名系统沌口片区和汉南片区登记入口页面 2016年5月11日星期三1、至科系统的上传与下载 2、iis不安全端口解决方案 3、学习教育局报名系统 4、晚上会议 ① 针对教育局报名系统的bug做出任务划分 ② 教育局报名系统的逻辑梳理 ③ 图片显示问题 2016年5月10日星期二1、弹窗获取当前所选中radio的值 2、文件的上传与下载 3、数据绑定案例 4、教育局报名系统测试 5、Cookie之登录页面记住我 2016年5月9日星期一1、熟悉教育局报名系统代码 2、至科代码 3、JS控制table点击按钮增加行 4、子窗体的子窗体给父窗体传值问题 第三周总结好快，实习第三周结束了。 这周主要是针对公司的一个教育报名系统进行整改，测试。本周加了两天班，这是我第一次加班，不打卡，不记考勤，周六早早地到了公司，等了半个多小时才进去。中午经理和我们一起吃了饭，当然是他买单。 本来周末两天是想要回学校的，但是计划赶不上变化，时间都奉献了。 每天都在和那个特别烂的报名系统打交道，感觉好烦躁。 嗯，今天是母亲节，祝全天下伟大的母亲节日快乐。 这周就先这样把，明天又是一个新的开始，接下来，要给经理提交一份有关福利待遇的建议方案。 打算在本月18号之前写一份“满月”体验报告。 从上月18号到今天是第20天。 漫漫职场程序路，何时才能到尽头？ 2016年5月8日星期日1、教育局报名系统测试 2、修改教育局报名系统存在的bug 3、撰写有关福利待遇的建议方案 4、浏览博客园网站，收听.NET FM，聆听时下前沿技术 5、加班加到21:35，没什么想说的了 2016年5月7日星期六1、今天加班 2、鼓捣OCR图像文字识别技术，demo案例 3、教育局报名系统整合，界面美化 4、整理教育局报名系统测试账号 2016年5月6日星期五1、去掉上传按钮，统一进行上传 2、上传图片采用GUID+文件名命名，避免重名 3、学会目录分离算法，避免和解决大量文件保存在同一个目录下的问题，通过目录分离算法来保证在不同的图片保存在不同的目录下。 4、界面美化 5、研究“以图搜图”技术,现有两种方案，具体实现有待研究 ① 感知哈希算法 ⑴ 缩小图片尺寸将图片缩小到8x8的尺寸, 总共64个像素. 这一步的作用是去除各种图片尺寸和图片比例的差异, 只保留结构、明暗等基本信息. ⑵ 转为灰度图片将缩小后的图片, 转为64级灰度图片 ⑶ 计算灰度平均值计算图片中所有像素的灰度平均值 ⑷ 比较像素的灰度将每个像素的灰度与平均值进行比较, 如果大于或等于平均值记为1, 小于平均值记为0. ⑸ 计算哈希值将上一步的比较结果, 组合在一起, 就构成了一个64位的二进制整数, 这就是这张图片的指纹. ⑹ 比图片指纹得到图片的指纹后, 就可以对比不同的图片的指纹, 计算出64位中有多少位是不一样的. 如果不相同的数据位数不超过5, 就说明两张图片很相似, 如果大于10, 说明它们是两张不同的图片. ② OCR图像文字识别技术 因为户口本、房产证、出生证明等图片上的文字是固定的，所以可以获取户口本、房产证、出生证明等图片上的文字信息来验证图片正确与否。 2016年5月5日星期四1、上午会议 ① ChenZong对公司做介绍，现状，规划 ② 上市，产品 ③ 绩效问题 ④ 研发大楼 ⑤ 千万级智能建筑项目 ⑥ 分公司(十堰、宜昌~) ⑦ 待遇问题 2、完成GuoHongYu安排的任务，整合修改的代码 3、测试教育局报名系统 4、报名系统存在问题 ① 获取片区信息，有部分小区显示不存在 ② 选择特定小区“万科金域蓝湾小区”下面不隐藏 ③ 特定小区“滨湖小区”下一步没反应 ④ 所有选择房产证和购房合同页面，选择房产证没问题，选择购房合同，则会弹出提示输入门牌号和房产证 2016年5月4日星期三1、整个上午开会 ① 主题分享之图文技术点应用解析 ② 确定无特别情况，每周四晚组织《学习会》 ③ 近期的工作重点：两个系统 ④ 绩效考核办法讲解 ⑤ 教育局需求分析 ⑥ 公司娱乐活动建议型方案 ⑦ 现有问题总结，解决方案 2、图片修改“报名”改“登记” 3、图片上传问题异常解决 4、下拉框上传不刷新 5、教育局报名系统页面微调，兼容性 2016年5月3日星期二1、至科检测工作流平台 2、搭建多层结构的博客项目 3、前台登录页面 4、后台登录模块 5、联系人列表aspx版增删改查 6、晚上会议 ① 教育局报名系统测试报告点评 ② 教育局报名系统bug修改，需求分析 ③ LoadRunner压力测试 ④ 以图搜图技术 2016年5月2日星期一今天是休假最后一天，(^o^)/YES! 第二周总结一晃半个月就这样过去了，第二周过的是那样的快，今天是五一劳动节，按国家规定我们放假三天。在紧凑的工作生活中又带来些许的放松，我刚从学校回到住处。对的，自己一个人太无聊，我跑到学校去了，去见见我那室友们。 看看上面的每日任务，这周说真的，并没有学到什么，这周下发的任务很少基本上没有，所有就选择了自己安排，总的来说，学了点jQueryEasyUI、搞了一个用一般处理程序+HTML+ajax完成的增删改查小案例，哦！还有那个SQL的存储过程分页，跟进了公司的一个教育局管理系统，完成了其中的两个小模块。其它的小事就不往上面写了，大概就是这样把！ 渐渐地天气热了起来，夏天给人的感觉总是那么浮躁。不知为何，现在的我根本静不下心来了，没有了在学校的那种拼劲，慢慢的我感觉到自己松懈了，偏偏上班了却又没有那种特别明确的目标了。在学校的时候就想着找个公司好好实习，好好学技术，努力提升自己的价值。反而现在到了公司却有种迷茫的感觉。是自己的问题？抑或是公司的问题？ 仔细想了想，应该还是个人原因，就拿目前的我和之前的我对比一下：现在晚上早早地上了床，大概每晚10点多左右，就算睡不着也躺在床上。之前在学校，基本上都是12点过后才上床睡觉的，不是在敲代码，就是在看视频。 不能因为现在有了一个落脚地，就因此松懈啊！还是要不断的学习才可以，既然选择了程序员这条路，就要不遗余力的去编码，去学习，学习如逆水行舟不进则退啊！除非你想一直只拿2K的薪水。这不是我想要生活，我要过上高质量的生活水平，现在的我还是远远不够的，埋头苦干才是硬道理，技术才是王道，奔跑吧，阿星！ 不在沉默中暴发，就在沉默中灭亡！ 2016年4月29日星期五1、教育局报名系统测试 2、教育局报名系统完善图片上传功能 3、一般处理程序联系人列表的增删改查案例 4、分页展示信息列表 5、至科检测工作流平台表单、流程设计 2016年4月28日星期四1、至科检测工作流平台表单、流程设计 2、Html页面+ 一般处理程序留言评论案例 3、一般处理程序联系人列表的增删改查案例 4、存储过程分页 2016年4月27日星期三1、教育局系统遮罩层图片显示功能模块 2、至科检测工作流平台表单、流程设计 3、ajax异步请求实现注册 2016年4月26日星期二1、修改网站流量统计页面代码 2、学习在线投票功能案例 3、学习jQueryEasyUI，搭建页面，进行增删改查操作 4、晚上会议 ①教育局报名系统业务流程，项目介绍等 ②Lims产品介绍 2016年4月25日星期一1、观看WebApp相关资料和视频 2、学习登录注册Demo后台逻辑 3、学习观看新闻管理系统Demo 4、学习文件上传下载Demo 5、晚上会议 ①针对自己的学习情况，谈谈对公司上司及自己的一些看法 ②Boss对我们存在的一些问题进行讲解答疑 ③对教育局管理系统和至科实验室信息管理系统的切入、学习 ④教育局管理系统项目转化为产品的打算、预想 ⑤观看《青春代码》微电影 第一周总结这是我的第一次正式工作，我现在是一名大二的学生。这个时间段应该是在学校无忧无虑的过着安稳的日子的，可是我却已经出来实习了。至于为什么这么早出来找工作其实有很多原因的，有个人原因也有学校的原因，总之吧，在学校我感觉我已经学不到东西了，所以还不如早点出来锻炼锻炼自己。这个过程真的蛮艰难的，对于一个初入职场的小白来说是这样的。2016年4月15日，我的3个舍友牺牲了自己的时间帮我提行李到我所租房子的地方，打扫卫生，整理房间…真的很感谢他们，东西比较多，如果是我一个人拿的话，估计会更艰难，为表感谢，我请他们去饭店吃了一顿。 我住的这个地方，距离我工作的地方，不堵车的话大概半小时的公交路程。接下来的两天，我熟悉了这里的环境，合租房，公共卫生间，真的有很多的不方便。我找的这个地方地段比较好，但是这也恰恰增加了我的经济负担，往往地段比较好的位置，消费都是比较高的。 每天上班都要走很远的路程，武汉这个地方，这两年到处都在修路，真是非常的不方便。第一天上班的前一晚我特别兴奋，大晚上的在床上翻来覆去一直睡不着，早上提前了一个小时到公司，非常尴尬，因为是打卡式的，我进不去，只好在外边转了几圈直到8点左右我才上去进行一系列的入职流程。公司的上班时间是8:30–5:30，有了第一天的经验，我早上一般都是6点半起床，进行洗漱后7点准时出发，走到公交站大概7:30左右，不管堵不堵车，一个小时的缓冲时间是肯定可以到公司的。 在公司按部就班的进行实习学习，我的领导个人感觉还是蛮nice的，比较人性化，喜欢和我们交流，有好几次中午都是和我们几个实习生一起走路去吃饭。一起和我实习的是我的一个学长，当时也是蛮诧异的，他和我是同一天进入这个公司的，当时还感叹了一下，这个世界其实有时候还是蛮小的。 不管怎么样，这是我的第一份工作，我希望自己能够做好，不断增强自己，早日达到标准。 2016年4月22日星期五1、熟悉教育局报名管理系统后台逻辑 2、完成GuoHongYu分配的任务 3、学习三层架构 2016年4月21日星期四1、完成图片上传之前本地预览功能 2、上午会议 ① Jin日里程碑提交规范 ② Lims观后感或者测试报告点评 ③ 近期任务：配合GuoHongYu安排的任务、学习 ④ C#开发编码规范 3、学习RoadFlow工作流引擎，教育局报名管理系统 4、来游戏•复盘设计方案分析 5、研究H5 APP开发 - WeX5 2016年4月20日星期三1、继续观看信息系统，并写观后感 2、仿淘宝图片大图显示js代码特效 3、图片上传之前本地预览功能 2016年4月19日星期二1、登陆系统练习 2、在线观看至科实验室信息管理系统 2016年4月18日星期一1、第一天上班，配置电脑，熟悉环境 2、登录系统练习","tags":[{"name":"实习","slug":"实习","permalink":"http://xj8c.cc/tags/实习/"}]},{"title":"毕业答辩汇报材料","date":"2017-03-30T04:47:00.000Z","path":"2017/03/30/graduation-report-material/","text":"1.实习公司： ① 武汉路博特工程科技有限公司 — 2016.4.18 — 2017.2.10 ② 上海盖世网络技术有限公司 — 2017.2.27 — 至今 2.公司简介： ① 武汉路博特工程科技有限公司是一家专注于海量信息处理的专业技术服务公司，致力于将先进信息技术和管理手段应用到工程管理、企业管理、政务及商务管理中，为各行业用户提供系统集成软件和IT服务，能为企事业单位提供系统的管理软件产品和软、硬件整体解决方案，能提供专业开发系统、产品并含有特殊复杂算法需求的专业软件… ② 上海盖世网络技术有限公司是一家全球领先的汽车产业综合服务提供商，致力于促进全球汽车供应链的有序良性健康发展，帮助中国企业提升竞争力，进入国际舞台；促进中国汽车供应链的产业升级，从加工制造到智能智造。通过盖世在汽车行业的与业理解、产业深度和整合资源的能力，为企业发展提供一站式服务。 3.项目： 武汉东方建设集团有限公司(whdfjs.com) 武汉东方建设集团建筑设计院(dfjssj.com) 武汉至科检测技术有限公司(zktit.com) 武汉路博特工程科技有限公司(lubok.cn) 武汉市江汉区交通大队公安局(公安专线,外网无法访问) 武汉优仕德教育发展有限公司(61.183.201.164:85) 武汉麦都教育咨询有限公司(61.183.201.164:86) 武汉至科检测技术有限公司检测人员资格查询系统(61.183.201.164:83) 至科试验室信息管理系统(61.183.201.164:82) 程序员版2048、当然我在瞎扯(Android App) 4.收获： C#高级编程知识(IO操作、设计模式、委托、多线程、反射…) 数据库开发(存储过程、触发器、视图、离线数据集、数据安全…) DotNet(Lucence.Net、Log4Net、Dapper、页面静态化、高效缓存、URL重写、RSS、无刷新上传、微信页面开发、微信手机商城、WebApi、Asp.Net MVC、EF、Nuget…) 前端(H5+CSS3、Http协议、JavaScript、jQuery、Vue.js、Node.js、Npm、网站部署、web调优…) 版本管理工具(Git、SVN、GitHub) 5.遇到的问题： 举例1：个性化Ueditor(百度编辑器) 修改外观皮肤、定制组件、插入视频实现预览功能、上传图片实现自动存入CDN域名、上传图片实现等比例缩放。 举例2：Web端上传文件转换PDF功能 用户上传的文件有：txt、Word、Excel、PPT、图片、PDF。自动转换用户上传的文件为PDF(难点)，在后台管理中进行审核(通过与不通过)，进而在前台显示转换的PDF内容。 6.打算： 顺利毕业，早日拿到毕业证和公司申请转正，完成每日工作内容的同时不断学习不断进步。作为一名软件开发人员，应该时刻关注互联网的新技术、新产品、新方向。现如今主要是学好技术，提升自己的能力，为公司工作的同时充实自己。接下来准备学习项目架构方面的知识，接触ASP.NET CORE，慢慢向云计算、大数据方面发展。","tags":[{"name":"毕业答辩","slug":"毕业答辩","permalink":"http://xj8c.cc/tags/毕业答辩/"}]},{"title":"2016年终总结","date":"2017-01-04T01:59:56.000Z","path":"2017/01/04/2016-year-end-summary/","text":"一、工作总结2016年对我来说意义非凡，结束掉学生生涯正式步入职场，进入“路博特”，开始我的编码生活。这一年不仅学到了更多的专业知识同时也长了不少见识。从入职到现在已有八个多月的时间，在公司担任.Net研发一职。 总的来说2016年实现了个人的预期目标，以下是2016年预期目标一览。1.2016年4月18日入职“武汉路博特工程科技有限公司” 2.2016年6月熟练掌握三层架构开发网站 3.2016年9月ASP.NET MVC学习并入门 4.2016年10月25日结束驾考生涯，驾驶证到手 5.2016年11月可利用Entity Framework开发简单网站 6.2016年12月对前端有了新的认识可开发自适应PC和手机屏幕的网页 下面重点总结在公司开发过的网站以及参与过的项目。刚进公司主要是熟悉环境，了解行情，快速进行学习，适应公司的发展需要。最开始参与了一个教育局报名管理系统，负责了其部分JS特效及一些后台功能的实现。然后客串测试直至项目顺利上线。在这个小小的项目中，体会到了团队协同、效率、编码能力、测试等的至关重要。 由于个人前端能力突出，紧接着便被安排编写设计院网站，在完成前端所有页面之后协同开发后台在短短不到一周的时间完成该项目。但是遗留下的问题却有很多，因为经验不足导致Bug众多。深深体会到维护一个项目远远比开发一个项目要难得多。从这个项目过渡，接下来的时间开发了至科网站、集团网站、路博特网站、至科检测人员资格查询系统前台、优仕德项目网站、江汉区交警大队网站、麦都教育网站等等公司一系列有关前台的页面。并且主导了域名的注册、备案、上线以及后期的维护工作。 以上便是我2016入职以来的工作总结。 二、自我评价优点：1.环境适应能力强，能够很快适应新的工作环境 2.具备团队合作意识，善于协调团队分工合作 3.能够虚心接受他人的意见与建议，对符合的予以采纳 4.各方面的知识都有涉猎，学习能力较快，接受新事物能力强 5.能够在最短时间内完成Leader下发的任务，并自由合理分配时间 6.在编程开发过程中，对项目有自己的见解以及问题解决方案 缺点：1.后半年积极度不高，比较懒散 2.涉猎知识较多，但是都不精通 3.个人能力和团队能力有限，不能更加完美的解决现有项目问题 4.情绪化比较严重，不能合理控制自己的心情 对自己的要求：1.合理控制自己的时间 2.在现有项目的基础上，完善不足之处 3.学而知不足，专一研究DotNet技术，由此进行发散学习 三、建议意见1.员工归属感需增强，实行奖惩制度，提高福利待遇 2.希望公司可以大幅度提供住宿，家较远的员工可以给予公交补贴 3.技术方面，向框架式开发渐进，框架开发速度快，效率高。急需一套属于公司内部的网站开发框架。","tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://xj8c.cc/tags/年终总结/"}]},{"title":"C＃7.0中有哪些新特性？","date":"2016-08-31T02:19:57.000Z","path":"2016/08/31/csharp7/","text":"以下将是 C# 7.0 中所有计划的语言特性的描述。随着 Visual Studio “15” Preview 4 版本的发布，这些特性中的大部分将活跃起来。现在是时候来展示这些特性，你也告诉借此告诉我们你的想法！C＃7.0 增加了许多新功能，并专注于数据消费，简化代码和性能的改善。或许最大的特性就是元祖和模式匹配，元祖可以很容易地拥有多个返回结果，而模型匹配可以根据数据的“形”的不同来简化代码。我们希望，将它们结合起来，从而使你的代码更加简洁高效，也可以使你更加快乐并富有成效。请点击 Visual Studio 窗口顶部的反馈按钮，告诉我们哪些是你不期待的特性或者你关于提升这些特性的思考。还有许多功能没有在 Preview 4 版本中实现。接下来我会描述一些我们发布的最终版本里将会起作用的特性，和一些一旦不起作用机即会删除掉的特性。我也是支持对这些计划作出改变，尤其是作为我们从你那儿得到反馈的结果。当最终版本发布时，这些特性中的一些将会改变或者删除。 如果你好奇这些特性的设计过程，你可以在 Roslyn GitHub site 上找到很多设计笔记和讨论。希望 C＃7.0 能带给你快乐！输出变量在当前的 C＃ 中，使用输出参数并不像我们想的那样方便。在你调用一个无输出参数的方法之前，首先必须声明一个变量并传递给它。如果你没有初始化这些变量，你就无法使用 var 来声明它们，除非先指定完整的类型：12345public void PrintCoordinates(Point p)&#123; int x, y; // have to &quot;predeclare&quot; p.GetCoordinates(out x, out y); WriteLine($&quot;(&#123;x&#125;, &#123;y&#125;)&quot;);&#125; 在 C＃7.0 中，我们正在增加输出变量和声明一个作为能够被传递的输出实参的变量的能力：12345public void PrintCoordinates(Point p)&#123; p.GetCoordinates(out int x, out int y); WriteLine($&quot;(&#123;x&#125;, &#123;y&#125;)&quot;);&#125; 注意，变量是在封闭块的范围内，所以后续也可以使用它们。大多数类型的声明不建立自己的范围，因此在他们中声明的变量通常会被引入到封闭范围。Note：在 Preview 4 中，适用范围规则更为严格：输出变量的作用域是声明它们的语句，因此直到下个版本发布时，上面的示例才会起作用。由于输出变量直接被声明为实参传递给输出形参，编译器通常会告诉他们应该是的类型（除非有冲突过载），所以使用 var 来代替声明它们的方式是比较好的：1p.GetCoordinates(out var x, out var y); 输出参数的一种常见用法是Try模式，其中一个布尔返回值表示成功，输出参数就会携带所获的结果：1234567891011public void PrintStars(string s)&#123; if (int.TryParse(s, out var i))&#123;WriteLine(new string(&apos;*&apos;, i));&#125; else&#123;WriteLine(&quot;Cloudy - no stars tonight!&quot;);&#125;&#125; 注意：这里i只用在 if 语句来定义它，所以 Preview 4 可以将这个处理的很好。我们计划允许以 a* 为形式的“通配符”作为输出参数，这会让你忽略了你不关心参数：1p.GetCoordinates(out int x, out *); // I only care about x Note：在 C#7.0 中是否会包含通配符还不确定。模式匹配C＃ 7.0 引入了模式概念。抽象地讲，模式是句法元素，能用来测试一个数据是否具有某种“形”，并在被应用时，从值中提取有效信息。C＃7.0 中的模式示例： C 形式的常量模式（C是C#中的常量表达式），可以测试输入是否等于C T X 形式的类型模式（T是一种类型、X是一个标识符），可以测试输入是否是T类型，如果是，会将输入值提取成T类型的新变量X Var x 形式的 Var 模式（x是一个标识符），它总是匹配的，并简单地将输入值以它原本的类型存入一个新变量X中。 这仅仅是个开始 - 模式是一种新型的 C＃ 中的语言元素。未来，我们希望增加更多的模式到 C# 中。在 C＃7.0，我们正在加强两个现有的具有模式的语言结构： is 表达式现在具有一种右手侧的模式，而不仅仅是一种类型 switch 语句中的 case 语句现在可以使用匹配模式，不只是常数值在 C＃的未来版本中，我们可能会增加更多的被用到的模式。 具有模式的 IS 表达式下面是使用 is 表达式的示例，其中利用了常量模式和类型模式：1234567public void PrintStars(object o)&#123; if (o is null)return; // constant pattern &quot;null&quot; if (!(o is int i))return; // type pattern &quot;int i&quot; WriteLine(new string(&apos;*&apos;, i));&#125; 正如你们看到，模式变量（模式引入的变量）和早前描述的输出变量比较类似，它们可以在表达式中间声明，并在最近的范围内使用。就像输出变量一样，模式变量是可变的。注：就像输出变量一样，严格范围规则适用于Preview 4。模式和 Try方法可以很好地协同：1if (o is int i || (o is string s &amp;&amp; int.TryParse(s, out i)) &#123; /* use i */ &#125; 具有模式的 Switch 语句我们正在归纳 Switch 语句：可以设定任何类型的 Switch 语句（不只是原始类型）模式可以用在 case 语句中Case 语句可以有特殊的条件下面是一个简单的例子：12345678910111213141516switch(shape)&#123; case Circle c: WriteLine($&quot;circle with radius &#123;c.Radius&#125;&quot;); break; case Rectangle s when (s.Length == s.Height): WriteLine($&quot;&#123;s.Length&#125; x &#123;s.Height&#125; square&quot;); break; case Rectangle r: WriteLine($&quot;&#123;r.Length&#125; x &#123;r.Height&#125; rectangle&quot;); break; default: WriteLine(&quot;&lt;unknown shape&gt;&quot;); break; case null: throw new ArgumentNullException(nameof(shape));&#125; 关于新扩展的 switch 语句，有几点需要注意：Case 语句的顺序现在变得重要：就像 catch 语句一样，case 语句的范围现在可以相交，第一个匹配上的会被选中。此外，就像 catch 语句一样，编译器通过去除明显不会进入的 case 来帮助你。在此之前，你甚至不需要告诉判断的顺序，所以这并不是一个使用 case 语句的巨大的改变。默认的语句还是最后被判断：尽管 null 的 case 语句在最后语句之前出现，它也会在默认语句被选中之前被测试。这是与现有 Switch 语义兼容的。然而，好的做法通常会将默认语句放到最后。Switch 不会到最后的 null 语句：这是因为当前 IS 表达式的例子具有类型匹配，不会匹配到 null。这保证了空值不会不小心被任何的类型模式匹配上的情况;你必须更明确如何处理它们（或放弃它而使用默认语句）。通过一个 case 引入模式变量:标签仅在相应的 Switch 范围内。元组这是一个从方法中返回多个值的常见模式。目前可选用的选项并非是最佳的：输出参数：使用起来比较笨拙（即使有上述的改进），他们在使用异步方法是不起作用的。System.Tuple&lt;…&gt; 返回类型：冗余使用和请求一个元组对象的分配。方法的定制传输类型：对于类型，具有大量的代码开销，其目的只是暂时将一些值组合起来。通过动态返回类型返回匿名类型：很高的性能开销，没有静态类型检查。在这点要做到更好，C＃7.0 增加的元组类型和元组文字：1234(string, string, string) LookupName(long id) // tuple return type&#123; ... // retrieve first, middle and last from data storage return (first, middle, last); // tuple literal&#125; 这个方法可以有效地返回三个字符串，以元素的形式包含在一个元组值里。这种方法的调用将会收到一个元组，并且可以单独地访问其中的元素：12var names = LookupName(id);WriteLine($&quot;found &#123;names.Item1&#125; &#123;names.Item3&#125;.&quot;); Item1 等是元组元素的默认名称，也可以被一直使用。但他们不具有描述性，所以你可以选择添加更好的：1(string first, string middle, string last) LookupName(long id) // tuple elements have names 现在元组的接收者有多个具有描述性的名称可用：12var names = LookupName(id);WriteLine($&quot;found &#123;names.first&#125; &#123;names.last&#125;.&quot;); 你也可以直接在元组文字指定元素名称：1return (first: first, middle: middle, last: last); // named tuple elements in a literal 一般可以给元组类型分配一些彼此无关的名称：只要各个元素是可分配的，元组类型就可以自如地转换为其他的元组类型。也有一些限制，特别是对元组文字，即常见的和告警错误，如不慎交换元素名称的情况下，就会出现错误。Note：这些限制尚未在 Preview 4 中实现。元组是值类型的，它们的元素是公开的，可变的。他们有值相等，如果所有的元素都是成对相等的（并且具有相同的哈希值），那么这两个元组也是相等的（并且具有相同的哈希值）。这使得在需要返回多个值的情况下，元组会非常有用。举例来说，如果你需要多个 key 值的字典，使用元组作为你的 key 值，一切会非常顺利。如果你需要在每个位置都具有多个值的列表，使用元组进行列表搜索，会工作的很好。Note：元组依赖于一组基本类型，却不包括在 Preview 4 中。为了使该特性工作，你可以通过 NuGet 获取它们：右键单击 Solution Explorer 中的项目，然后选择“管理的NuGet包……”选择“Browse”选项卡，选中“Include prerelease”，选择“nuget.org”作为“Package source”搜索“System.ValueTuple”并安装它。解构消耗元组的另一种方法是将解构它们。一个解构声明是一个将元组（或其他值）分割成部分并单独分配到新变量的语法：123(string first, string middle, string last) = LookupName(id1);// deconstructing declarationWriteLine($&quot;found &#123;first&#125; &#123;last&#125;.&quot;); 在解构声明中，您可以使用 var 来声明单独的变量：1(var first, var middle, var last) = LookupName(id1); // var inside 或者将一个单独的 var 作为一个缩写放入圆括号外面： 1var (first, middle, last) = LookupName(id1); // var outside 你也可以使用解构任务来解构成现有的变量 1(first, middle, last) = LookupName(id2); // deconstructing assignment 解构不只是应用于元组。任何的类型都可以被解构，只要它具有（实例或扩展）的解构方法：1public void Deconstruct(out T1 x1, ..., out Tn xn) &#123; ... &#125; 输出参数构成了解构结果中的值。（为什么它使用了参数，而不是返回一个元组？这是为了让你针对不同的值拥有多个重载）。12345678class Point&#123; public int X &#123; get; &#125; public int Y &#123; get; &#125; public Point(int x, int y) &#123; X = x; Y = y; &#125; public void Deconstruct(out int x, out int y) &#123; x = X; y = Y; &#125;&#125;(var myX, var myY) = GetPoint(); // calls Deconstruct(out myX, out myY); 这是一种常见的模式，以一种对称的方式包含了构建和解构。对于输出变量，我们计划在解构中加入通配符，来化简你不关心的变量：1(var myX, *) = GetPoint(); // I only care about myX Note：通配符是否会出现在C＃7.0中，这仍是未知数。局部函数有时候，一个辅助函数可以在一个独立函数内部起作用。现在，你可以以一个局部函数的方式在其它函数内部声明这样的函数：12345678910111213public int Fibonacci(int x)&#123; if (x &lt; 0)throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x)); return Fib(x).current; (int current, int previous) Fib(int i) &#123; if (i == 0)return (1, 0); var (p, pp) = Fib(i - 1); return (p + pp, p); &#125;&#125; 闭合范围内的参数和局部变量在局部函数的内部是可用的，就如同它们在 lambda 表达式中一样。举一个例子，迭代的方法实现通常需要一个非迭代的封装方法，以便在调用时检查实参。（迭代器本身不启动运行，直到 MoveNext 被调用）。局部函数非常适合这样的场景：12345678910111213141516public IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; filter)&#123; if (source == null)throw new ArgumentNullException(nameof(source)); if (filter == null)throw new ArgumentNullException(nameof(filter)); return Iterator(); IEnumerable&lt;T&gt; Iterator() &#123; foreach (var element in source) &#123; if (filter(element)) &#123; yield return element; &#125; &#125; &#125;&#125; 如果迭代器有一个私有方法传递给过滤器，那么当其它成员意外的使用迭代器时，迭代器也变得可用（即使没有参数检查）。此外，还会采取相同的实参作为过滤器，以便替换范围内的参数。注意：在 Preview 4，局部函数在调用之前，必须被声明。这个限制将会被松开，以便使得局部函数从定义分配中读取时，能够被调用。文字改进C＃7.0 允许 _ 出现，作为数字分隔号：12var d = 123_456;var x = 0xAB_CD_EF; 你可以将 _ 放入任意的数字之间，以提高可读性，它们对值没有影响。此外，C＃7.0 引入了二进制文字，这样你就可以指定二进制模式而不用去了解十六进制。1var b = 0b1010_1011_1100_1101_1110_1111; 引用返回和局部引用就像在 C# 中通过引用来传递参数（使用引用修改器），你现在也可以通过引用来返回参数，同样也可以以局部变量的方式存储参数。12345678910111213public ref int Find(int number, int[] numbers)&#123; for (int i = 0; i &lt; numbers.Length; i++) &#123; if (numbers[i] == number) &#123; return ref numbers[i];// return the storage location, not the value &#125; &#125; throw new IndexOutOfRangeException($&quot;&#123;nameof(number)&#125; not found&quot;);&#125; int[] array = &#123; 1, 15, -39, 0, 7, 14, -12 &#125;;ref int place = ref Find(7, array); // aliases 7&apos;s place in the arrayplace = 9; // replaces 7 with 9 in the arrayWriteLine(array[4]); // prints 9 这是绕过占位符进入大数据结构的好方法。例如，一个游戏也许会将它的数据保存在大型预分配的阵列结构中（为了避免垃圾回收机制暂停）。方法可以将直接引用返回成一个结构，通过它的调用者可以读取和修改它。也有一些限制，以确保安全：你只能返回“安全返回”的引用：一个是传递给你的引用，一个是指向对象中的引用。本地引用会被初始化成一个本地存储，并且不能指向另一个存储。异步返回类型到现在为止，C＃ 的异步方法必须返回 void，Task 或 Task。C＃7.0 允许其它类型以这种能从一个方法中返回的方式被定义，因为它们可以以异步方法被返回的方式来定义其它类型。例如我们计划建立一个 ValueTask 结构类型的数据。建立它是为了防止异步运行的结果在等待时已可用的情境下，对 Task 进行分配。对于许多实例中设计缓冲的异步场景，这可以大大减少分配的数量并显著地提升性能。Note：异步返回类型尚未在 Preview 4 中提供。更多的 expression bodied 成员：expression bodied 的方法和属性是对 C# 6.0 的巨大提升。C# 7.0 为 expression bodied 事件列表增加了访问器，结构器和终结器。1234567891011class Person&#123; private static ConcurrentDictionary&lt;int, string&gt; names = new ConcurrentDictionary&lt;int, string&gt;(); private int id = GetId(); public Person(string name) =&gt; names.TryAdd(id, name); // constructors ~Person() =&gt; names.TryRemove(id, out *); // destructors public string Name &#123; get =&gt; names[id]; // getters set =&gt; names[id] = value; // setters &#125;&#125; Note：这些额外增加的 expression bodied 的成员尚未在 Preview 4 中提供。这是社区共享的示例，而不是 Microsoft C# 编译团队提供的，还是开源的！Throw 表达式在表达式中间抛出一个异常是很容易的：只需为自己的代码调用一个方法！但在 C＃7.0 中，我们允许在任意地方抛出一个表达式：12345678910111213class Person&#123; public string Name &#123; get; &#125; public Person(string name) =&gt; Name = name ?? throw new ArgumentNullException(name); public string GetFirstName() &#123; var parts = Name.Split(&quot; &quot;); return (parts.Length &gt; 0) ? parts[0] : throw new InvalidOperationException(&quot;No name!&quot;); &#125; public string GetLastName() =&gt; throw new NotImplementedException();&#125; Note：Throw 表达式尚未在Preview 4中提供。","tags":[{"name":"C#","slug":"C","permalink":"http://xj8c.cc/tags/C/"}]},{"title":"武汉路博特工程科技有限公司实习“满月”工作感受","date":"2016-05-18T07:27:30.000Z","path":"2016/05/18/internship-experience/","text":"今天是2016年5月18日，时间过得真快，自上个月18号到今天来公司刚好一个月。这一个月的学习生活，让我学到了很多，不管是技术上还是生活阅历上都得到了很大的提升。在公司，和大家相处的都很融洽，大家一起吃饭，一起加班，一起讨论技术。在团队中，有高学历，有低学历，但是大家并不会因为学历的原因而疏远。刚进公司什么都不懂，慢慢的适应了现有的环境，每天上班下班加班，乐此不疲。 祝经理，人很随性，对上班工作没有具体的硬性要求，弹性工作，正是我想要的。刚到公司的第一个星期，感觉很轻松，每天到点下班，有很多空余的时间，随着时间的推移，慢慢的有任务了，变得忙起来，每天要加班完成任务。正是这样，才让我得到了提升。从前端到后端再到测试，全接触。在我来XXX面试的时候，我已经收到其他公司的offer，之所以选择XXX，我主要从公司环境和公司氛围以及面试者(祝经理)来判定的。我当初既然选择了这里，我就会一如既往的在这里继续学习下去。我对公司的第一印象还是不错的，那么在这里不仅可以得到技能上的提升，还能收获身心的愉悦。说说这一个月在公司做的事情吧，其实也没什么，每天的工作日报都已经写得很详细了。第一，主要参与了一个教育局登记系统的项目，完成了几个JS的特效，充当了几次测试，熟悉了一下后天逻辑，完成了几个小的功能点。第二，一个公司自主二次开发的工作流平台，这个主要熟悉了一下流程，不做详解，接下来的重点既是这个。第三，学会若干技术点，比如iis安装部署等若干问题，文件的共享、访问，代码调试技巧等等。还有就是，一些非技术性技能，应该叫软技能吧！待人处事啊，处理工作中的问题啊，填写报销单啊之类的。最后就总结一下自己的不足和接下来的计划吧。工作上，有些许不足，不完美的地方。比如，在测试教育局登记系统的时候没有充分测试，有时候为了图速度，准确率不高。测试就是一个心细的活，像我这样可能会适得其反。还有比如JS效果的实现，在我本地是实现了，那么在服务器上了？在不同的浏览器上面呢？没有做好相应的兼容性，都是我的问题所在。接下来，我首先会完成公司安排下发的任务，在完成任务的同时，考虑更多的后果，不同的情况，做好相应的测试，确保万无一失。在自己完成任务的同时，学会帮助他人。因为帮助他人就是提升自己。还有就是按照自己的学习计划每天学习，不断进步。有不懂先自己研究，研究不出来问问同事。希望接下来的日子，能够共同成长进步！","tags":[{"name":"实习感受","slug":"实习感受","permalink":"http://xj8c.cc/tags/实习感受/"}]},{"title":"ASP.NET知识点面试篇","date":"2016-04-16T09:13:19.000Z","path":"2016/04/16/asp.net-knowledge-point-interview/","text":"列举ASP.NET页面之间传递值的几种方式？1，使用QueryString，如：…Test?id=1 Redirect()..2，使用Session变量3，使用Server.Transfer4，Cookie传值 什么是code-Behind技术就是代码隐藏，在ASP.NET中通过ASPX页面指向cs文件的方法实现显示逻辑和处理逻辑的分离，这样有助于web应用程序的创建。比如分工，美工和编程的可以各干各的，不用再像以前asp那样代码和HTML代码混在一起，难以维护。请解释ASP.NET中的web页面与其隐藏类之间的关系一个ASP.NET页面一般都应对一个隐藏类，一般都在ASP.NET页面的声明中指定了隐藏类例如一个页面Test.aspx的页面声明如下：1&lt;%@ Page language=&quot;c#&quot; Codebehind=&quot;Test.aspx.cs&quot; AutoEventWireup=&quot;false&quot; Inherits=&quot;T1.Test&quot; %&gt; Codebehind=”Test.aspx.cs”表明经编译此页面时使用哪一个代码文件Inherits=”T1.Test”表示运行时使用哪一个隐藏类aspx页面会编译生成一个类，这个类从隐藏类继承通过超链接怎样传递中文参数？用URL编码，通过QueryString传递，用urlencode编码，urldecode解码Server.Transfer和Response.Redirect的区别是什么？Server.Transfer仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示转向后的地址；Response.Redirect则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中看到跳转后的链接地址。Server.Transfer是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的相应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪里来的，所以它的地址栏还是原来的地址。这个过程中浏览器和web服务器之间经过一次交互。Response.Redirect就是服务端根据逻辑，发送一个状态吗，告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求。这个过程中浏览器和web服务器之间经过了两次交互。说出一些常用的类，接口常用的类：StreamReader、WebClient、Dictionary、StringBuilder、SqlConnection、FileStream、File、Regex、List常用的接口：IDisposable、IEnumerable、IDbConnection、IComparable、ICollection、IList、IDictionarypost、get的区别get的参数会显示在浏览器地址栏中，而post的参数不会显示在浏览器地址栏中使用post提交的页面再点击刷新按钮的时候浏览器一般会提示“是否重新提交”，而get则不会用get的页面可以被搜索引擎抓取，而用post的则不可以用post可以进行文件的提交，而用get则不可以用post可以提交的数据量非常大，而用get可以提交的数据量则非常小(2K)，受限于网页地址的长度。Application、Cookie和Session两种会话有什么不同？Application是用来存取整个网站全局的信息，而Session是用来存取与具体某个访问者关联的信息。Cookie是保存在客户端的，机密信息不能保存在Cookie中，只能放小数据；Session是保存在服务器端的，比较安全，可以放大数据。http状态吗各是什么意思？302：重定向301：永久重定向404：页面不存在500：服务器内部错误Session有什么重大的BUG，微软提出了什么方法加以解决？iis中有由于有进程回收机制，系统繁忙的话Session会丢失，iis重启也会造成Session丢失。这样用户就要重新登录或者重新添加信息到Session中。可以用StateServer或SqlServer数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的end事件。但是我认为这不是bug，只能说是In-Proc方式存储Session的缺陷，缺陷和bug是不一样的，In-Proc方式存储Session会由服务器来决定什么时候释放Session，这是By Design，In-Proc方式不满足要求的话完全可以用StateServer和数据库的方式。StsteServer还可以解决集群Session共享的问题配置StateServer的方法：略asp.net中&lt;% %&gt;、&lt;% = %&gt;、&lt;% # %的区别是什么？&gt;&lt;% %&gt;是执行&lt;% %&gt;中的C#代码，&lt;% = %&gt;是将=后的表达式的值输出到Response中，&lt;% # %&gt;是数据绑定，一般用来ListView、GridView、Repeater等控件的绑定中。数据绑定分为，Eval：单向绑定和Bind：双向绑定。asp.net中的错误机制定制错误页来将显示一个友好的报错页面页面中未捕捉一样会触发Page_Error，应用程序中的未捕获异常会触发Application_Error。通过HttpContext.Current.Server.GetLastError();拿到未捕捉异常，记录到Log4Net日志中。","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"面试","slug":"面试","permalink":"http://xj8c.cc/tags/面试/"}]},{"title":"三层架构到底是个什么玩意？","date":"2016-04-07T16:12:44.000Z","path":"2016/04/08/what-is-a-three-tier-architecture/","text":"名词解释：架构：架构一般是针对整个系统的，并非针对某个单独的问题(单独的问题可以用模式来解决)，针对整个系统的”一个蓝图”，对系统的抽象。模式：软件开发中遇到的一些特定问题，前任总结出来特定的经验、解决方法。框架：架构设计、模式应用的经验积累的具体代码实现，方便以后的复用。 三层：表现层UI(User Interface)：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。业务逻辑层BLL(Business Logic Layer)：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。(备注：又称领域层，常用业务规则、数据访问、合法性校验等等) 。其实，逻辑层就像房屋中介，租房买房跟快捷了，但消耗的钱也跟多了。数据访问层DAL(Data Access Layer)：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。(领域对象：crud)优点：1、开发人员可以只关注整个结构中的其中某一层；2、可以很容易的用新的实现来替换原有层次的实现；3、可以降低层与层之间的依赖；4、有利于标准化；5、利于各层逻辑的复用；6、结构更加的明确；7、在后期维护的时候，极大地降低了维护成本和维护时间。缺点：1、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以次获取相应的数据，如今却必须通过中间层来完成。；2、有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表现层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。；3、一定程度上增加了开发的成本。；规则三层结构的程序不是说把项目分成DAL，BLL，WebUI三个模块就叫三层了。下面这几个问题： 1、UILayer里面只有少量(或者没有)SQL语句或者存储过程调用，并且这些语句保证不会修改数据？2、如果把UILayer拿掉，你的项目还能在Interface/API的层次上提供所有功能吗？3、你的DAL可以移植到其他类似环境的项目吗？4、三个模块，可以分别运行与不同的服务器吗？如果不是所有答案都为YES，那么你的项目还不能算是严格意义上的三层程序。三层程序有一些需要约定遵守的规则： 1、最关键的，UI层只能作为一个外壳，不能包含任何BizLogic的处理过程2、设计时应该从BLL出发，而不是UI出发。BLL层在API上应该实现所有BizLogic，以面向对象的方式3、不管数据层是一个简单的SqlHelper也好，还是带有Mapping过的Classes也好，应该在一定的抽象程度上做到系统无关4、不管是用COM+( Enterprise Server )，还是Remoting，还是WebService之类的远程对象技术，不管部署的时候是不是真的分别部署到不同的服务器上，最起码在涉及的时候要做这样的考虑，更远的，还得考虑多台服务器通过负载均衡做集群。所以考虑一个项目是不是应该应用三层/多层设计时，先得考虑下是不是真的需要？实际上大部分程序就开个WebApplication就足够了，完全没必要做的这么复杂。而多层架构，是用于解决真正复杂的项目需求的。 三层与MVC的区别同样是架构级别的，它们有什么相同点和不同点呢？这篇文章讨论一下它们的异同点。希望能帮助读者理解其中的玄机。其实它们相同的地方在于他们都有一个表现层。但是他们不同的地方在于其他的两个层。首先先解释一下MVC。V即View.是视图的意思。C即Controler.是控制器的意思。而M即Model，是模型的意思。这三个里.最不容易理解的应该是Model.就是什么是Model，而为什么叫Model。我先不说为什么叫Model，先解释Controler。Controller是控制器的意思，所谓控制器，就是将用户请求转发给模型层，经过处理后把结果返回到界面展现的一个中间层，那么Controler到底管什么工作呢？先不说.先来看下在Java Web中这三个层一般的定义，一般在Java Web里，JSP充当V，Servlet充当C,JavaBean充当M，这里的Servlet管什么工作呢？接受输入，转到Model层去处理，处理结果保存后转发到JSP，然后展现数据。所以它的功能就是控制器的基本功能，它就管转发，在V和M之间转来转去。再来说说M，即Model，在Java Web里说的是JavaBean，我认识的很多人都把JavaBean误认为是实体类，其实JavaBean有比实体类更丰富的定义，在JavaBean中除了其属性和字段，还可以有行为及其事件，JavaBean可以理解为普通Java对象。Java普通对象，就是符合Java规范的所有对象，这和实体类完全是两回事。所以，我认为在MVC中。业务逻辑和数据访问应该放在Model层，也就是V负责展示数据，Controler除了转发不做业务逻辑。真正的逻辑事务，数据访问，甚至算法都放到Model去。再说三层架构。三层其实很好理解，界面，业务，数据访问，就这三个，从字面都可以理解出它们的意思。我要说的是它和MVC的区别。在三层架构中没有定义Controler的概念。这是我认为最不同的地方。而MVC也没有把业务的逻辑访问看成两个层，这是采用三层架构或MVC搭建程序最主要的区别。当然了。在三层中也提到了Model，但是三层架构中Model的概念与MVC中Model的概念是不一样的，“三层”中典型的Model层是已实体类构成的，而MVC里，则是由业务逻辑与访问数据组成的。不一样的概念。虽然名字一样。","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"三层架构","slug":"三层架构","permalink":"http://xj8c.cc/tags/三层架构/"}]},{"title":"ADO.NET中的五个主要对象？","date":"2016-04-07T15:34:02.000Z","path":"2016/04/07/five-main-objects-in-dotnet/","text":"Connection主要是开启程序和数据库之间的连接，没有利用连接对象将数据库打开，是无法从数据库中取得数据的。 Close和Dispose的区别，Close以后还可以Open，Dispose以后则不能再用。 Command主要可以用来对数据库发出一些指令，例如可以对数据库下达增、删、改、查数据等指令，以及调用存在数据库中的存储过程等。 这个对象是架构在Connection对象上，也就是Command对象是透过连接到数据源。 DataAdapter主要是在数据源以及DataSet之间执行数据传输的工作，它可以透过Command对象下达命令后，并将取得的数据放入DataSet对象中。 这个对象是架构在Command对象上，并提供了许多配合DataSet使用的功能。 DataSet这个对象可以视为一个暂存区(Cache)，可以把从数据中所查询到的数据保留起来，甚至可以将整个数据库显示出来，DataSet是存在内存中。 DataSet的能力不只是可以存储多个Table而已，还可以透过DataAdapter对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。 DataSet对象可以说是ADO.NET中重量级的对象，这个对象架构在DataAdapter对象上，本身不具备和数据源沟通的能力；也就是说我们是将DataAdapter对象当做DataSet对象以及数据源传输数据的桥梁。 DataSet包含若干DataTable、DataTable包含若干DataRow。 DataReader当我们只需要循序的读取数据而不需要其它操作时，可以使用DataReader对象。 DataReader对象只是一次一笔向下循序的读取数据源中的数据，这些数据存在数据库服务器中，而不是一次性加载到程序的内存中，只能通过游标读取当前行的数据，而且这些数据是只读的，并不允许做其它的操作。 因为DataReader字啊读取数据的时候限制了每次只读取一笔，而且只能只读，所以使用起来不但节省资源而且效率很好。 使用DataReader对象除了效率较好之外，因为不能把数据全部传回，故可以降低网络的负载。 ADO.NET使用Connection对象来连接数据库，使用Command或DataAdapter，然后再使用取得的DataReader或DataAdapter对象操作数据结果。","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"C#","slug":"C","permalink":"http://xj8c.cc/tags/C/"}]},{"title":"所谓的Get和Post到底是何方神圣？","date":"2016-04-07T15:04:07.000Z","path":"2016/04/07/get-and-post/","text":"简介：Get和Post是表单提交数据的两种基本方式，Get请求数据通过域名后缀URL传送，用户可见，不安全，Post请求数据通过在请求报文正文里面传输，相对来说比较安全。Get是通过URL传递表单值，Post通过URL看不到表单域的值；Get传递的数据量是有限的，如果要传递大量数据则不能用Get，比如type=”file”上传文章、type=”password”传递密码或者用&gt;textarea&lt;发表大段文章，Post则没有这个限制；Post会有浏览器提示重新提交表单的问题，Get则没有。对于Post的表单重新敲地址栏再刷新就不会提示重新提交了，因为重新敲地址就没有偷偷提交的的数据了。Post方式的正确的地址很难直接发给他人。 GET和POST的区别：1. Get提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连，如Edit.aspx?name=test1&amp;id=123456。Post方法是把提交的数据放在http包的body中。2. Get提交的数据大小有限制，因为浏览器对URL的长度是有所限制的，感兴趣的可以自己了解一下。而Post方法是提交的数据没有限制。3. Get方式需要使用Request.QueryString来取得变量的值，而Post方式通过Request.Form来获取变量的值。4. Get方式提交数据，会带来安全问题，比如一个登录页面，通过Get方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问此电脑，就可以从历史记录获得该用户的账号和密码。Get是从服务器上获取数据，Post是向服务器传送数据。Get是把参数数据队列加到提交表单的action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。Post是通过http post机制，将表单内各个字段与其内容放置在HTML HEADER 内一起传送到action属性所指的URL地址。用户是看不到这个过程的。对于Get方式，服务器端用Request.QueryString获取变量的值，对于Post方式，服务器端用Request.Form获取提交的数据。Get传送的数据量小，不能大于2kb(还是因为受URL长度的限制)。Post传送的数据量大，一般被默认为不受限制。但理论上，限制取决于服务器的处理能力。Get安全性较低，Post安全性较高。因为Get在传输过程，数据被放在请求的URL中，而如今有很多服务器、代理服务器或者用户代理都会讲请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上之间看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post的所有操作对用户来说都是不可见的。","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"get","slug":"get","permalink":"http://xj8c.cc/tags/get/"},{"name":"post","slug":"post","permalink":"http://xj8c.cc/tags/post/"}]},{"title":"一个学渣的逆袭","date":"2015-12-10T08:05:19.000Z","path":"2015/12/10/the-students-with-poor-grades-reversed/","text":"周一上午一般是我一周最忙碌的时间段，要处理积压的邮件，Review各组的开发计划，安排后续工作，查看业务线的支持请求……这时候电话响了，接通后发现，是很久不见的一位老友兼发小，权且称之为M。M和我是高中同学，从高中到大学时期我们经常厮混在一起，工作后因为涉足的领域不同，联系渐渐变少，但是每年总能找时间聚聚，或者打一通电话天南海北地聊。今年还没聚过，突然接到电话我多少有些吃惊。老M常常游走在幽暗的森林里，工作中好事坏事都能碰到，时间久了，戾气渐盛，有时候需要和我这样的正义化身聊聊天，获取一些正能量，才能勉力支撑他继续过个一年半载，所以我以为他遇到什么麻烦了。结果伊说：昨晚梦到你了，突然变得伤感，于是打个电话，看看你这个老小子是否还在地球上活蹦乱跳。 原来如此。于是我们在电话里互相说了一些“你现在过得咋样”、“你的公司还没倒闭吧”、“老婆是不是原配”、“孩子是不是你的”之类的问候语，互道郑重之后挂了电话。我陷入了深深的思考，并想到了这个题目，“一个学渣的逆袭”。学渣不是我。那一年，我也16岁，他也16岁，我以全校第一名的成绩进入区重点高中，俨然是个学霸。M的成绩就差了很多，他在高中时期以打架和交友广泛闻达于诸侯，而我以成绩优秀和解题迅猛名震四方。可以说，高中时代，基本上是我看着他打架泡妞，他抄着我的作业长大的。在那个眼镜与作业本齐飞的年代，虽然有时我对身边的好白菜都被猪拱了这件事耿耿于怀，但总体来说，我们互补有无，相安无事。大学毕业以后，我进了位于北京顺义郊区的一个直流电源的工厂，每月能收入1000元。他回了老家，月薪200元。他在节假日有时来北京玩耍，常常羡慕我月薪过千，眼中闪烁着锐利通透的光芒，像狼。狼常常意味着独自流浪，其实人也有流浪情结，只是有的人去了，有的人没去。记得中学的一个假期，M突然说要去南方旅行，身上带了几十块钱就上路了，我一度想去，但最终被循规蹈矩的父母阻止，只好看着他逃了票上了开向南方的列车，羡慕不已。回来后M变得黑而精瘦，沉默，两眼冒绿光，眼神犀利，似乎黑暗中走路都不需要手电筒。最要命的是，沉默期过后，我们不得不在之后的一年内反复听他讲述他的南方流浪记，一如《Red Dog》里那位不停讲述阿布鲁奇太阳的矿工，为此挨揍也在所不惜。另外，M还传授了我们不下10种逃票的方法，无论是公交、火车、汽车，他都能逃之有道并逃之夭夭，以至于我很长时间一想到流浪就是逃票十法。这样的人是不会在家乡待太久的，因为他不是植物。很快，他离开了家乡，来到一家电梯公司，开始从事楼宇的电梯安装工作。他从基层做起，经常带着工队出入于各种新旧楼盘，有时候吃住就在那些还未完工的大楼里进行，吃盒饭，睡睡袋，环境极为艰苦。由于业绩突出，他慢慢开始参与公司一些管理工作，并且逐步展现出了自己优秀的销售天赋和组织协调能力，很快，他成长为某个区域的大区经理。后来我听说伊离职创业了，联系变少，断断续续。有一天，他说要请我吃顿好的，并回顾一下眼镜和作业本齐飞的岁月。当他从一辆崭新的雷克萨斯570上走下来的时候，我知道，一个学渣的逆袭已经完成……现在他经营着一家相对传统的电梯公司，员工不足百，营收过亿，并继续前行。故事讲完了，如果你身边也有这样的学渣，请对他们好一点，因为学渣随时可以逆袭。如果你是个学渣，不要放弃自己，因为学渣和学霸在出了校门之后，是可以转换的。","tags":[{"name":"逆袭","slug":"逆袭","permalink":"http://xj8c.cc/tags/逆袭/"}]},{"title":"计算机运算基础荟萃","date":"2015-11-20T17:24:48.000Z","path":"2015/11/21/computer-computing-infrastructure/","text":"二进制数的运算方法电子计算机具有强大的运算能力，它可以进行两种运算：算术运算和逻辑运算。 1．二进制数的算术运算二进制数的算术运算包括：加、减、乘、除四则运算，下面分别予以介绍。 （1）二进制数的加法根据“逢二进一”规则，二进制数加法的法则为：12340＋0＝00＋1＝1＋0＝11＋1＝0 （进位为1） 1＋1＋1＝1 （进位为1） 例如：1110和1011相加过程如下：… （2）二进制数的减法根据“借一有二”的规则，二进制数减法的法则为：12340－0＝01－1＝01－0＝10－1＝1 （借位为1） 例如：1101减去1011的过程如下：… （3）二进制数的乘法二进制数乘法过程可仿照十进制数乘法进行。但由于二进制数只有0或1两种可能的乘数位，导致二进制乘法更为简单。二进制数乘法的法则为：1230×0＝00×1＝1×0＝01×1＝1 例如：1001和1010相乘的过程如下：… 由低位到高位，用乘数的每一位去乘被乘数，若乘数的某一位为1，则该次部分积为被乘数；若乘数的某一位为0，则该次部分积为0。某次部分积的最低位必须和本位乘数对齐，所有部分积相加的结果则为相乘得到的乘积。 （4）二进制数的除法二进制数除法与十进制数除法很类似。可先从被除数的最高位开始，将被除数（或中间余数）与除数相比较，若被除数（或中间余数）大于除数，则用被除数（或中间余数）减去除数，商为1，并得相减之后的中间余数，否则商为0。再将被除数的下一位移下补充到中间余数的末位，重复以上过程，就可得到所要求的各位商数和最终的余数。 例如：100110÷110的过程如下：… 所以，100110÷110＝110余10。 2．二进制数的逻辑运算二进制数的逻辑运算包括逻辑加法（“或”运算）、逻辑乘法（“与”运算）、逻辑否定（“非”运算）和逻辑“异或”运算。 （1）逻辑“或”运算又称为逻辑加，可用符号“＋”或“∨”来表示。逻辑“或”运算的规则如下：12340＋0＝0或0∨0＝00＋1＝1或0∨1＝11＋0＝1或1∨0＝11＋1＝1或1∨1＝1 可见，两个相“或”的逻辑变量中，只要有一个为1，“或”运算的结果就为1。仅当两个变量都为0时，或运算的结果才为0。计算时，要特别注意和算术运算的加法加以区别。 （2）逻辑“与”运算又称为逻辑乘，常用符号“×”或“· ”或“∧”表示。“与”运算遵循如下运算规则：1230×1＝0或0·1＝0或0∧1＝01×0＝0或1·0＝0或1∧0＝01×1＝1或1·1＝1或1∧1＝1 可见，两个相“与”的逻辑变量中，只要有一个为0，“与”运算的结果就为0。仅当两个变量都为1时，“与”运算的结果才为1。 （3）逻辑“非”运算又称为逻辑否定，实际上就是将原逻辑变量的状态求反，其运算规则如下：… 可见，在变量的上方加一横线表示“非”。逻辑变量为0时，“非”运算的结果为1。逻辑变量为1时，“非”运算的结果为0。 （4）逻辑“异或”运算“异或”运算，常用符号“”或“”来表示，其运算规则为：123400＝0 或 00＝001＝1 或 01＝110＝1 或 10＝111＝0 或 11＝0 可见：两个相“异或”的逻辑运算变量取值相同时，“异或”的结果为0。取值相异时，“异或”的结果为1以上仅就逻辑变量只有一位的情况得到了逻辑“与”、“或”、“非”、“异或”运算的运算规则。当逻辑变量为多位时，可在两个逻辑变量对应位之间按上述规则进行运算。特别注意，所有的逻辑运算都是按位进行的，位与位之间没有任何联系，即不存在算术运算过程中的进位或借位关系。下面举例说明。 【例1.1】 如两变量的取值 X＝00FFH，Y＝5555H，求Z1＝X∧Y；Z2＝X∨Y；Z3＝；Z4＝XY的值。12345678解：&amp;nbsp;&amp;nbsp;X＝0000000011111111&amp;nbsp;&amp;nbsp;Y＝0101010101010101则：&amp;nbsp;&amp;nbsp;Z1＝0000000001010101＝0055H&amp;nbsp;&amp;nbsp;Z2＝0101010111111111＝55FFH&amp;nbsp;&amp;nbsp;Z3＝1111111100000000＝FF00H&amp;nbsp;&amp;nbsp;Z4＝0101010110101010＝55AAH 算术运算及逻辑运算规则见下表:… 数在计算机中的表示在计算机中要处理的数有无符号数和有符号数。这些数在计算机中是如何表示的呢？1．无符号数所谓无符号数，通常表示一个数的绝对值，即数的各位都用来表示数值的大小。一个字节（8位）二进制数只能表示0～255范围内的数。因此，要表示大于255的数，必须采用多个字节来表示，它的长度可以为任意倍字节长，其数据格式如图1.1所示。… 2．有符号数所谓有符号数，即用来表示一个任意位长的正数或负数。我们知道，在普通数字中，区分正负数是在数的绝对值前面加上符号来表示，即“＋”表示正数，“－”表示负数。在计算机中数的符号也数码化了，即用一位二进制数位来表示符号。一般是，用一个数的最高位来表示符号位，用“0”表示正号，用“1”表示负号，而其余位为数值位。其数据格式如图1.2所示。… 3．有符号数的原码、反码、补码及补码运算带正、负号的二进制数称为数的真值表示。12例如：X＝＋1010110 Y＝－0110101 为了运算方便，在计算机里的有符号数，有三种表示方法，即原码、反码和补码，称为机器数。 （1）原码正数的符号位用“0”表示，负数的符号位用“1”表示，其余数字位表示数值本身，这种表示法称为原码。例如：上例中12[X]原＝01010110[Y]原＝10110101 对于0，可以认为它是＋0，也可以认为它是－0。因此在原码中，0有下列两种表示12[＋0]原＝00000000[－0]原＝10000000 原码表示数的方法很简单，只需要在真值的基础上，将符号位用数码“0”和“1”表示即可。但采用原码表示的数在计算机中进行加减运算时很麻烦。如：遇到两个异号数相加，或两个同号数相减时，就要用减法运算。为了把减法运算转变成加法运算，则引入了反码和补码。 （2）反码在原码表示的基础上很容易求得一个数的反码。正数的反码与原码相同，而负数的反码则是在原码的基础上，符号位不变（仍为1），其余数位按位求反，即0→1，1→0。例如：上例中1234[X]反＝01010110[Y]反＝11001010而：[＋0]反＝00000000 [－0]反＝11111111 （3）补码一个数的补码也很容易求得。如果是正数，补码同原码也同反码，如果是负数，则在反码的基础上最末位加1。例如：上例中123456[X]补＝01010110＝[X]反＝[X]原 [Y]补＝11001011注：补码中0只有一种表示，无正负之分，即：[＋0]补＝[－0]补＝00000000不难证明，补码具有如下特性：[[X]补]补＝[X]原 用8位二进制数来表示无符号数及有符号数的原码、反码、补码时的对应关系见表1.5。 由表1.5可知，用8位二进制数，表示无符号数为0～255；表示原码为－127～＋127；表示反码为－127～＋127；表示补码为－128～＋127。 （4）补码运算两个用补码表示的带符号数进行加减运算时，特点是把符号位上表示正负的“1”和“0”也看成数，与数值部分一同进行运算，所得的结果也为补码形式，即结果的符号位为“0”，表示正数，结果的符号位为“1”表示负数。下面分加、减两种情况予以讨论。两个带符号的数X和Y进行相加时，是将两个数分别转换为补码的形式，然后进行补码加运算，所得的结果为和的补码形式。即：1[X＋Y]补＝[X]补＋[Y]补 【例1.2】 用补码进行下列运算 (＋18)＋(－15)；(－18)＋(＋15)；(－18)＋(－11)解：… 由例1.2可知：当带符号的数采用补码形式进行相加时，可把符号位也当作普通数字一样与数值部分一起进行加法运算，若符号位上产生进位时，则自动丢掉，所得的结果为两数之和的补码形式。如果想得到运算后原码的结果，可对运算结果再求一次补码即可。 两个带符号数相减，可通过下面的公式进行：12X－Y＝X＋（－Y）则 [X－Y]补＝[X＋(－Y)]补＝[X]补＋[－Y]补 可见：求[X－Y]补，可以用[X]补和[－Y]补相加来实现。这里关键在于求[－Y]补。如果已知[Y]补，那么对[Y]补的每一位（包括符号位）都按位求反，然后再在末位加1，结果即为[－Y]补。（证明从略）。一般称[－Y]补为对[Y]补的“变补”，即[[Y]补]变补＝[－Y]补；已知[Y]补求[－Y]补的过程叫变补。这样一来，求两个带符号的二进制数之差，可以用“减数（补码）变补与被减数（补码）相加”来实现。这是补码表示法的主要优点之一。 【例1.3】 用补码进行下列运算：① 96－19； ② (－56)－(－17)123解：① X＝96，Y＝19 则[X]补＝01100000 [Y]补＝00010011[－Y]补＝11101101故 [X－Y]补＝[X－Y]原＝01001101＝＋77 12345678② X＝－56，Y＝－17， 则[X]补＝11001000[Y]补＝11101111[－Y]补＝00010001则 [X－Y]补＝11011001故 [X－Y]原 ＝[[X－Y]补]补＝10100111＝－39综上所述，对于补码的加、减运算可用下边一般公式表示：[X±Y]补＝[X]补＋[±Y]补 （都小于2n+1） （5）溢出判断当两个有符号数进行补码运算时，若运算结果的绝对值超出运算装置容量时，数值部分就会发生溢出，占据符号位的位置，导致错误的结果。这种现象通常称为补码溢出，简称溢出。这和正常运算时符号位的进位自动丢失在性质上是不同的。下面举例说明。例如：某运算装置共有五位，除最高位表示符号位外，还有四位用来表示数值。先看下面两组运算。 ① 计算13＋7＝？ ② 计算(－4)＋(－4)＝？ ① 的运算结果显然是错误的，因为两个正数相加不可能得到负数的结果，产生错误的原因是由于两个数相加后的数值超出了加法装置所允许位数（数值部分4位，可以表示的最大数值为24＝16），因而从数值的最高位向符号位产生了进位，或说这种现象是由于“溢出”而造成的。② 的结果显然是正确的，由符号位产生的进位自动丢失。为了保证运算结果的正确性，计算机必须能够判别出是正常进位还是发生了溢出错误。微机中常用的溢出判别称为双高位判别法，并常用“异或”电路来实现溢出判别。其表达式为.. 数的编码方法在计算机里，所有用到的数字、字母、符号、指令等都必须用特定的二进制码来表示，这就是二进制编码。 1．二进制编码的十进制数计算机只能识别二进制数，但是，人们却熟悉十进制数。所以，在计算机输入和输出数据时，往往采用十进制数表示。不过，这样的十进制数是用二进制编码表示的，称为二进制编码的十进制数——BCD（binary code decimal）码。用二进制数为十进制数编码，每一位十进制数需要由四位二进制数来表示。四位二进制数共有16种编码形式，由于十进制数只有0～9十个数码，故有六个码是多余的，放弃不用。而这种多余性便产生了多种不同的BCD码。在计算机中较常用的是8421 BCD码（在以后的章节中简称BCD码）。这种BCD码用四位二进制数表示一位十进制数的数码0～9，而这四位的权从高位到低位依次为8，4，2，1。十进制数0～15与8421 BCD码的编码关系见表1.6。12例如：(208)10＝(0010 0000 1000)8421 BCD (1001 0001 0111 0101)8421 BCD＝(9175)10 2．字母与符号的编码在计算机里，字母和符号也必须用特定的二进制编码来表示。目前，在微机、通信设备和仪器仪表中广泛采用的是美国标准信息交换码ASCII（american standard code for information interchange）码。它用七位二进制码表示一个字母或符号，共能表示27＝128个不同的字符。其中包括数字0～9、英文26个大、小写字母、运算符、标点及其他的一些控制符号。常用的七位ASCII码见表1.7。例如：数字0的ASCII码为0110000B 或 30H 数字9的ASCII码为0111001B 或 39H 字母A的ASCII码为1000001B 或 41H ASCII码多用于微型计算机的输入/输出设备（如电传打字机）及在数据传送过程中进行奇偶校验。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://xj8c.cc/tags/计算机基础/"},{"name":"进制转换","slug":"进制转换","permalink":"http://xj8c.cc/tags/进制转换/"}]},{"title":"CEAC-office2010实操题练习评测系统","date":"2015-11-07T16:01:20.000Z","path":"2015/11/08/CEAC-office2010/","text":"CEAC，即国家信息化计算机教育认证，是国家信息产业部和中国电子商务协会共同批准、设立。是为建立国家信息化培训标准、加强培训渠道建设、完善信息化考试系统平台和考核标准的新举措。 简介由 CEAC 国家信息化培训认证管理办公室统一管理、实施。CEAC 认证证书是信息产业部向从业人员颁发的信息技术专业标准证书。具有广泛的认可度和专业权威性，代表了当今信息技术应用专业资格认证的国家标准。 CEAC 认证证书将陆续成为信息产业系统和各地方政府主管部门，对信息技术从业人员素质考核的主要参考因素，并针逐渐演变为对所有人员从业的基本要求国家信息化计算机教育认证项目（CEAC）为信息产业部核准、设立，由CEAC国家信息化培训认证管理办公室统一管理、实施的国家级教育认证项目。项目按照国际规范和信息技术培训标准设计符合中国政府、企业、行业信息化需求的人才培训、认证解决方案。依托于建立在各地的CEAC认证机构，实现大规模信息化人力资源培训的发展战略，从而大力推进政府、企业、行业信息化进程。国家信息化计算机教育认证项目（CEAC）以先进的课程方案、独特的教学方法、权威的国家认证服务于国家信息化建设。设立以来，深得社会各界认可，已获得计算机技术培训行业多项奖项。软件下载office2010实操题练习评测系统","tags":[{"name":"CEAC","slug":"CEAC","permalink":"http://xj8c.cc/tags/CEAC/"},{"name":"office2010","slug":"office2010","permalink":"http://xj8c.cc/tags/office2010/"},{"name":"绿色软件","slug":"绿色软件","permalink":"http://xj8c.cc/tags/绿色软件/"}]},{"title":"测试用例设计进阶(下)","date":"2015-10-28T13:58:11.000Z","path":"2015/10/28/test-case-design-advanced(bottom)/","text":"场景分析法设计测试用例 — 场景分析相关概念场景应用软件一般都是用事件触发来控制流程的，事件触发时的情景便形成了场景。 事件流同一事件不同的触发顺序和处理结果就形成事件流，事件流分为基本流和备选流。 基本流程序从开始执行直到成功结束所经过的最短路径。 备选流一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中；也可能起源于另一个备选流，执行后加入基本流或者终止用例。 一个典型的场景分析图场景分析法设计测试用例 — 使用场景分析设计测试用例场景分析法通过分析事件流设计测试用例的方法。 场景分析法的使用场景场景分析一般在分析业务流程或流程化处理功能时使用。 场景分析法的优点场景分析法可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。 场景分析法设计测试用例的步骤：1、分析软件规格说明描述，整理出基本流和备选流。2、根据基本流和备选流组合关系生成场景。3、分析所有场景，合并测试内容重复的场景。4、根据场景逐一设计测试用例。例、在用信用卡网上支付时，输入信用卡卡号、查询密码和实时短信验证码，信息全部正确且账户金额充足的情况下可以完成付款。如果相关信息不正确则给出对应提示信息；多条信息不正确时按输入顺序提示；短信验证码一分钟内有效，出错三次则退出本次支付。 1）整理基本流和备选流基本流：正常支付备选流1：账户不存在；备选流2：查询密码不正确；备选流3：短信验证码不正确；备选流4：短信验证码失效；备选流5：账户余额不足；备选流6：退出支付2）根据事件流生成场景场景1：基本流场景2：基本流-备选流1场景3：基本流-备选流2场景4：基本流-备选流3场景5：基本流-备选流4场景6：基本流-备选流5-备选流6场景7：基本流-备选流1-备选流2-备选流3-备选流6场景8：基本流-备选流3-备选流4-备选流5-备选流63）合并重复场景场景1：基本流场景2：基本流-备选流5-备选流6场景3：基本流-备选流1-备选流2-备选流3-备选流6场景4：基本流-备选流3-备选流4-备选流5-备选流64）根据最终的场景逐一设计测试用例测试用例总结 — 测试用例设计策略1、任何情况下都要使用边界值分析法设计测试用例，经验表明这种测试用例发现程序错误的能力最强。2、使用等价类划分法补充必要的测试用例。3、如果程序规格说明中多个条件决定多个动作，每个条件的取值只有两种，并且条件和动作之间的逻辑关系明确，那么使用判定表法设计测试用例。4、针对程序规格说明中含有多个条件的组合，输入与输出关系比较复杂的情况，使用因果图法设计测试用例。5、针对程序规格说明中的复杂业务流程、操作流程等，使用场景分析法设计测试用例。6、对照程序实现逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到覆盖要求，应当分析具体情况，补充足够的测试用例。7、分析程序规格说明，使用错误推测法补充一部分测试用例。8、测试过程中针对具体实现，将已有测试用例未覆盖的部分，选用合适的测试用例设计方法再补充一些必要的测试用例。测试用例总结 — 测试用例编写策略1、功能测试用例覆盖的功能点需要尽量小，方便测试执行时提取用例。2、对于常用控件的测试可以整理出针对控件的通用测试点，在具体的功能测试用例中就可以不再编写通用测试点已经覆盖的内容了。3、对于系统相关流程的测试用例，可以提取出来，编写有针对性的流程测试用例。4、对于业务关联性比较强的功能，可以提取出来，针对存在的业务场景编写功能测试用例。测试用例总结 — 测试用例的维护管理测试用例伴随着软件产品的整个生命周期，随着软件功能的日渐完善，测试用例也在不断改进、扩充和完善。在这个过程中，如何维护和管理测试用例将是直接影响软件测试质量的重要工作内容。 维护测试用例的原因软件需求变更需求分析错误测试需求误解或遗漏测试用例遗漏测试用例的维护日常维护主要有测试用例修改、测试用例删除和测试用例增加。 用例修改测试设计人员在设计测试用例时考虑不够全面，对测试需求的理解偏差或误解，功能实现和设计存在出入等都是造成测试用例修改的直接原因。 用例删除测试用例的删除主要是因为软件相关功能发生较大变化或已去掉，对应测试用例已不适用时，就需要删除对应用例；冗余的测试用例也需要删除。 用例增加测试人员在测试过程中发现有测试用例未覆盖的功能，用例评审时发现有未覆盖的测试需求，需求分析错误或收到新的需求时都需要新增对应功能的测试用例。 用例维护注意事项用例的维护都需要保留维护记录。同一软件不同现场功能出入较大的话，需要根据现场维护不同的测试用例。同一软件多版本共存的话，需要在测试用例中标注不同版本的用例差异。测试用例的管理测试用例根据公司代码和文档管理体制的不同采用对应的管理方式。如果公司资料文档使用同一个管理软件的话，将测试用例直接纳入管理软件测试相关目录即可；如果测试是作为一个完全独立的部门，相关资料文档有自己的管理软件的话，则将测试用例纳入自己软件的相关目录。 管理测试用例的作用保护测试人员工作成果。测试人员变动不会影响测试工作的正常进行。用例管理注意事项用例设计人员只有上传和更新用例文档的权限，不具有删除用例文档的权限，删除用例文档需经过相关人员核准。用例文档更新的人员、日期等历史信息需要能够查询。用例执行人员不具有编辑用例文档的权限。所有的用例评审结论文档都需要纳入文档管理系统。","tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://xj8c.cc/tags/软件测试/"}]},{"title":"测试用例设计进阶（上）","date":"2015-10-28T13:43:03.000Z","path":"2015/10/28/test-case-design-in-order(upper)/","text":"判定表法设计测试用例 — 判定表相关概念判定表是分析和表达多逻辑条件下执行不同操作的工具。判定表是由条件桩、动作桩、条件项、动作项四部分内容构成的表格。 条件桩（Condition Stub）列出了问题的所有条件。通常认为列出条件的次序无关紧要。 动作桩（Action Stub）列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。 条件项（Condition Entry）列出针对所列条件的取值。在所有可能情况下的真假值。 动作项（Action Entry）列出在条件项的各种取值情况下应该采取的动作。 判定表中的规则任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。 判定表的化简合并判定表中两条或多条具有相同动作，并且其条件项之间存在着极为相似关系的规则这一过程。 判定表法设计测试用例 — 使用判定表设计测试用例判定表使用场景如果程序中多个条件决定多个动作，并且每个条件的取值只有两种，且条件和动作之间的逻辑关系明确。 判定表的优点能够将复杂的问题按照各种可能的情况全部列举出来，简明并且可以避免遗漏。 判定表的建立步骤：1、列出所有的条件和动作2、确定规则的个数（假如有n个条件，每个条件有两个取值（0,1），就可以产生2的n次方种规则）3、填写判定表4、化简判定表例1 问题要求：“……对功率大于50马力的机器、维修记录不全或已运行10年以上的机器，应优先维修处理……” 。这里假定，“维修记录不全”和“优先维修处理”均已在别处有更严格的定义 。1）列出所有的条件和动作 条件：功率大于50马力?/维修记录不全?/已运行10年以上？动作：优先维修处理/其它处理方式2）确定规则的个数 这里有3个条件，每个条件有两个取值，故应有8种规则。3）填写判定表 4）化简判定表首先，找出判定表中相似的规则。 5）合并相似规则，就得到了化简后的判定表。 因果图法设计测试用例 — 因果图相关概念因果图是分析输入条件之间的联系及相互组合、输入与输出之间关系的分析方法。这里的输入就是原因，输出就是结果，所以这种分析方法称为因果图。 因果图的关系恒等：Ci=1,Ei=1;Ci=0,Ei=0. 非：Ci=1,Ei=0;Ci=0,Ei=1. 或：C1、C2、C3有一个是1，Ei为1； C1、C2、C3全是0，Ei为0。 与：C1、C2、C3有一个是0，Ei为0； C1、C2、C3全是1，Ei为1。 约束输入或输出状态相互之间还可能存在某些依赖关系，称为约束。 因果图的约束A、输入条件的约束有以下四类：E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。 I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。 O约束（唯一）：a和b必须有一个，且仅有一个为1。 R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。 B、输出条件约束：M约束（强制）：若结果a是1，则结果b强制为0。因果图法设计测试用例 — 使用因果图设计测试用例因果图使用场景适合于检查程序输入条件的各种组合情况，分析输入与输出之间的关系。 因果图的优点以图形化的方式将输入与输出之间的关系、输入条件、输出条件之间的相互约束标示出来，方便生成判定表，并能避免遗漏。 因果图法设计测试用例的步骤：1、分析软件规格说明描述, 找出原因（即输入条件或输入条件的等价类）和结果（即输出条件）, 并给每个原因和结果赋予一个标识符。2、分析软件规格说明描述中的语义，找出原因与结果之间、原因与原因之间对应的关系，根据这些关系，画出因果图。3、由于语法或环境限制, 有些原因与原因之间、原因与结果之间的组合情况不可能出现，为表明这些特殊情况, 在因果图上用一些记号表明约束或限制条件。 4、把因果图转换为判定表，并化简判定表。5、以最终的判定表的每一列为依据设计测试用例。例2 用户登录系统时需要输入用户名、用户密码、验证码，且验证码在1分钟内有效。如果用户输入的用户名、用户密码和验证码都正确则可以登录到系统；如果用户名、用户密码和验证码有一个未输入则给出对应的提示信息，如果多于一项未输入，那么提示输入次序在前的输入项；如果用户名或用户密码不正确，则提示“用户，不存在或密码不正确”；如果验证码失效给出失效提示信息。 输入项为空的逻辑在画因果图时不考虑，我们只分析输入错误和正确的情况。 1）找出原因和结果 原因：a、用户名，b、用户密码，c、验证码结果：ab、用户不存在或密码不正确，c1、验证码不正确，c2、验证码失效， d、登入系统2、3）分析因果关系，画出因果图，并在因果图上添加相关约束 4）将因果图转化为判定表，并化简 5）以最终判定表的每一列为依据设计测试用例","tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://xj8c.cc/tags/软件测试/"}]},{"title":"边界值分析法相关概念 — 边界点相关概念","date":"2015-10-25T05:21:45.000Z","path":"2015/10/25/boundary-value/","text":"边界点分为上点、内点和离点上点：就是边界上的点，不管它是开区间还是闭区间，就是说，如果该点是封闭的，那上点就在域范围内，如果该点是开放的，那上点就在域范围外。内点：就是域范围内的任意一个点。离点：就是离上点最近的一个点，如果边界是封闭的，那离点就是域范围外离上点最近的点，如果边界是开的，那离点就是域范围内离上点最近的点。边界值分析法相关概念 — 边界值分析法的概念 就是对输入或输出域的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。 边界值分析法相关概念 — 与等价类划分法的区别边界值分析法不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。边界值分析法不仅考虑输入条件，还要考虑程序输出产生的测试情况。使用边界值分析法设计测试用例 — 确定边界值的原则原则一如果输入或输出条件规定了取值范围，则应该以该范围的边界值及边界附近的值作为测试数据。例1.1 工人的工龄范围是大于等于0，小于等于50的整数。 边界值：-1，0，50，51例1.2 用户登录软件系统时，软件根据用户的权限加载相关模块功能。 边界值：没有权限，有一个模块的权限，有所有模块的权限。原则二如果输入或输出条件规定了值的个数，则用最大个数、最小个数、比最小个数少1、比最大个数多1的数作为测试数据。例2.1 报表定义中限定报表字段至少有两个字段，至多不能超过10个字段。 边界值：1，2，10，11例2.2 查询结果多于15条记录时需要提供翻页功能。 边界值： 0，1，15，16原则三如果程序规格说明书中提到的输入或输出是一个有序的集合，应该注意选取有序集合的第一个和最后一个元素作为测试数据。例3.1 下拉列表选择控件的测试。 边界值：下拉列表第一个选项，下拉列表最后一个选项例3.2 系统在编号从1-100的拓扑图中定位包含网元A的拓扑图，将含有网元A的拓扑图名称按照编号从小到大的顺序显示出来，在单击拓扑图名称后定位出网元A在拓扑图中的位置。 边界值：在包含网元A的编号最小的拓扑图中定位，在包含网元A的编号最大的拓扑图中定位。原则四如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试数据。例4 程序根据用户近三个月的消费状况给用户评级，月均消费超过3000元的用户或至少一个月消费超过5000的用户为优级用户，月均消费超过1500元或至少一个月消费超过3000元的为良级用户，月均消费超过800元的为潜力用户。 边界值：月均消费为 {3000,3001,1500,1501,799,800}，不满足月均消费数据但某月消费{5000,5001,3500,3501}使用边界值分析法设计测试用例 — 设计测试用例的原则给所有划分出来的等价类编号对所有有效等价类逐个确定边界值对所有无效等价类逐个确定边界值合并等价类和边界值设计出的测试数据中重复的数据分析程序规格说明书，应用确定边界值的各原则找出其它的边界值使用边界值分析法设计测试用例 — 错误推测法概念就是根据经验和直觉推测程序中可能存在的各种错误，从而有针对性地设计测试用例的方法。 思路列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。","tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://xj8c.cc/tags/软件测试/"}]},{"title":"软件测试基础知识","date":"2015-10-24T14:18:50.000Z","path":"2015/10/24/basic-knowledge-of-software-testing/","text":"常用的软件测试模型 — 模型的概念和作用模型的概念通过主观意识借助实体或者虚拟表现、构成客观阐述形态、结构的一种表达目的的物件。在软件行业来说就是：对系统实现步骤或系统知识的抽象表示。 模型的作用1.参与构造软件的人员之间沟通的基础2.指导具体的软件实现过程3.管理者制定相关工作计划的基础 常用的软件测试模型 — V模型常用的软件测试模型 — W模型常用的软件测试模型 — X模型常用的软件测试模型 — H模型软件测试的阶段划分 — 软件测试的各个阶段软件测试的阶段划分 — 软件测试各阶段工作重点单元测试单元模块内的功能测试、边界测试、容错测试、界面测试、控制流和数据流测试，以及模块内的业务流程测试等。 集成测试系统集成以后的相关接口测试、功能测试、容错测试、约束测试，跨模块的业务流程测试等。 系统测试系统性的初始化测试、功能测试、业务处理和数据处理测试、性能测试、压力测试、安装卸载测试等。 验收测试在用户现场和用户一起对系统进行功能确认、用户需求确认、备份恢复测试、安全性测试等。 回归测试系统使用过程中发现问题修改完成以后，测试对应的问题是否修改好了，测试新修改的功能是否引发新的缺陷，测试与修改代码相关的其它程序功能是否依然正确。 测试用例相关知识 — 测试用例的概念为了特定的测试目的而设计的具有测试输入、测试执行条件、预期结果及结果验证方法的文档。 测试用例相关知识 — 测试用例的特点1.最有可能抓住错误的2.不是重复的、多余的3.一组相似测试用例中最有效的4.既不是太简单，也不是太复杂 测试用例相关知识 — 测试用例设计原则1.测试用例的代表性2.需求的可追溯性3.测试结果的可判定性、可再现性4.测试用例粒度的合适性 Bug相关知识 — Bug的概念Bug就是程序的缺陷，是指软件程序运行过程中由于程序本身有问题导致的功能不正常、体验不佳、数据丢失、死机、非正常中断等现象。 Bug相关知识 — Bug相关要素Bug相关知识 — Bug记录原则及技巧Bug记录原则1.发现的所有问题都要记录Bug2.Bug描述要清晰准确3.避免重复Bug Bug记录技巧描述简明扼要，最好附带错误截图，尽量抓取错误日志，说清错误发生场景，可附带自己对错误的推测分析。","tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://xj8c.cc/tags/软件测试/"}]},{"title":"软件测试概述","date":"2015-10-24T14:06:08.000Z","path":"2015/10/24/overview-of-software-testing/","text":"软件测试的概念及分类 — 软件测试相关概念软件测试的定义通过手工或自动化的手段来运行或测定某个软件产品系统的过程，目的在于检测软件产品是否满足规定的需求，或者弄清楚预期结果与实际结果之间的差别。 软件测试的目的1. 是为了发现程序中存在的错误而执行程序；2. 是为了证明程序有错，而不是证明程序无错误。 软件测试工作流程软件测试的阶段划分软件测试的概念及分类 — 软件测试类型划分功能测试测试软件各个功能模块处理是否正确，业务逻辑是否正确，数据流转、呈现、处理和存储是否正确。 用户界面测试测试用户界面是否美观，界面设计是否人性化、易操作，提示是否友好完善，不同屏幕分辨率下各界面显示是否正确、美观，软件支持的不同语言版本下，各界面显示的文字是否正确、美观等。 兼容性测试主要测试浏览器兼容性、操作系统兼容性、硬件兼容性。 安装、卸载测试正常情况下软件安装完成后可以正常运行，可以完全卸载；用户无权限、硬件资源不满足等异常情况下能够给出准确的提示信息。 安全和访问控制测试分应用程序级别、系统级别两个层次。1. 应用程序级别主要是用户登录、数据和功能权限控制的正确性。2. 系统级别主要是服务器的访问控制和用户权限设置。 故障转移和恢复测试1. 主服务器不能服务备用服务器接管服务2. 主服务器恢复服务备用服务器停止服务 性能测试包括负载测试、压力测试、并发测试、可靠性测试、失效恢复测试等。 发布测试测试软件产品附带的各种说明书、帮助文档等。 软件测试入行指导和职业发展之路 — 软件测试入行要掌握的知识和技能软件测试相关的概念、术语、测试工作流程与人沟通、表述看法的能力测试用例设计方法基本的程序逻辑结构基本的数据库操作服务器日志查看方法软件测试入行指导和职业发展之路 — 测试从业人员的持续学习软件所服务行业的业务知识公司软件测试涉及的相关工具提高个人工作效率和质量的工具提高测试团队工作效率的方法或工具软件测试入行指导和职业发展之路 — 测试从业人员职业发展之路软件测试的生命周期及原则 — 软件测试的生命周期软件测试的生命周期及原则 — 软件测试的原则软件测试的基本原则站在用户的角度，从需求出发，对软件进行全面的、深入的测试，尽早、尽可多地发现Bug，并跟踪和分析软件中存在的问题，对不足之处提出质疑和改进意见。 软件测试的具体原则1、准备详尽的测试工作计划，并及时维护。2、所有测试的标准都应该建立在需求之上。3、事先定义好产品的质量标准，并不遗余力的去执行。4、尽可能早的开始测试工作。5、避免让程序员测试自己的程序。6、测试用例是设计出来的，不是写出来的。7、对发现错误较多的程序段，应进行更深入的测试；对于出错多的程序员编写的程序同样需要给予特别关注。","tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://xj8c.cc/tags/软件测试/"}]},{"title":"XML学习笔记(一)","date":"2015-10-20T14:52:19.000Z","path":"2015/10/20/xml-note-1/","text":"Xml简单的历史介绍1969 gml (通用标记语言) [主要的目的时候要在不同的机器进行通信的数据规范]1985 sgml (标准通用标记语言)1993 html (万维网)1998 xml Html语言本身是有一些缺陷的1.标记不能自定义2.Html本身缺少一些含义3.Html本身没有真正的国际化Html -&gt;xhtml-&gt;Xml: Extensible Markup Language 可扩展标记语言 Xml的特点1.xml描述的是结构和语义，而不是格式化2.xml讲数据内容和现实格式相分离3.xml是元标记语言。Xml的标记不是预先定义好的，而是自定义的。4.xml是自描述语言5.xml是独立于平台的6.xml不进行任何操作7.xml具有良好的保值性xml和html的不同1.xml和html都来自于SGML，它们都含有标记，有着相似的语法，区别：html不具有扩展性，它用固有的标记来描述、显示网页内容.2.Html的核心不是为了体现数据的含义，而是为了体现数据的显示格式。3.吸取html松散格式带来的经验教训，xml一开始就坚持实行“良好的格式”。为什么需要学习xml？1.需求2.做配置文件3.Xml还可以描述很复杂的数据关系Xml的常见应用1.数据传送通用格式2.配置文件3.充当小型数据库编码问题ANSI 编码 是American national standard institute 美国国家标准协会ansi编码在不同的国家是不一样的ansi -&gt;gb2312 、ansi -&gt;gbk、big5 …… Xml语法1.文档声明&lt;?xml version=”1.0” encoding=”编码方式” standalone=”yes/no”?&gt;2..一个xml文档中，有且只有有一个根元素元素—标签—节点 属性值用双引号(“)或单引号(‘)分隔(如果属性值中有’，用”分隔；有”，用’分隔)特别说明：如果属性值有单引号，有双引号，则需要使用实体：html -&gt; &nbsp; &copy;4.CDATA节有时我们希望传递一些特殊字符，&lt;&gt;!@#$%^&amp;* 可以使用CDATA节包括 基本用法：&lt;![CDATA[……]]&gt;面试题：问：如何使用xml去传递小图片？答：可以把文件读取成一个 byte[]，然后放到CDATA节，再传递。Xml语法小结语法规范Xml声明语句 &lt;?xml version=”1.0” encoding=”gb2312”?&gt;1.必须有且仅有一个根元素2.标记大小写敏感3.属性值用引号4.标记成对5.空标记关闭6.元素正确嵌套元素语法1.名称中可以包含字母、数字或者其它字符2.名称中不能包含空格3.名称中不能含冒号(注：冒号留给命名空间使用)元素之间的嵌套规则1.父元素的起始标记必须在子元素的起始标记之前,父元素的结束标记必须在子元素的结束标记之后.元素之间不可交叉嵌套2.子元素与子元素间是兄弟关系3.两元素之间不能既是父子元素又是兄弟关系.定义属性时应该注意以下几点1.属性的命名规则同元素命名2.属性值必须用引号括起来3.属性只能包含在开始标记中4.特点在属性名称在同一个元素中只能出现一次","tags":[{"name":"xml","slug":"xml","permalink":"http://xj8c.cc/tags/xml/"}]},{"title":"当最深沉的筹谋换来最清明的理想","date":"2015-10-12T04:51:41.000Z","path":"2015/10/12/when-the-deepest-counsel-comes-to-the-most-clear-ideal/","text":"我用了一周的时间，看完《琅琊榜》。期间或是在第一排坐在上课时把手机放在课桌下看，或是夜里已然熄灯把手机窝在被窝里看，或是吃饭的时候，偶尔也不能舍下。它关于亲情，兄弟，家国之恨。它如此沉重，我却甘之如饴。不管是一夜历经人生颠覆的萧景睿，还是一直貌似纨绔，却心思敏捷的言豫津；不管是镇守云南，巾帼不让须眉的郡主霓凰，还是貌美如花，琴技卓然的花魁宫羽；不管是心如稚童的飞流，还是风流不羁，重情重义的蔺晨……然而我最不能忘的，仍是那琅琊榜上第一公子——梅长苏。 开始几章只是一个病弱的江湖公子和游历之后回家的豪门子弟到金陵去养病，普通到再没有那么普通，没有波涛起伏，没有勾心斗角，江湖侠客和富家公子相处融洽，就算有那么点小病，金陵的环境那么好，养几天，早晚会好起来的。身边的少年虽然心智不全，可是很乖很漂亮。嗯，世界大同，很好，很温情。可是梅长苏，你为什么要感叹，说什么前尘往事如烟似梦，云散水涸不能重来！冠盖满京华，阳光明亮的刺眼，这些少年眉目张扬笑容温暖，有了这么美好的开端，以后的波诡云谲天翻地覆，那么残忍。孱弱的躯壳里是死过一次的灵魂，常年围炉而坐，不由衷的笑意，永远凉的惊心的指尖，却偏偏，在偌大的金陵翻云覆雨等闲间。你跟着梅长苏的节奏，看他无声无息的救出祁王遗孤，看他不动声色的解决敌国虎视眈眈的求亲，看他一手把夺嫡之争推上了高潮，看他一手拉太子和誉王下位，看他一手把靖王推上高处。一点一点，一步一步，紧凑的，执着的，拼却残生。因为他的生命太短，他的使命太重。所以你不得不连呼吸都和他一样小心翼翼，就这样看着他运筹帷幄之中，决胜朝堂之上。谁不想当年的兄友弟恭君臣和睦，谁不想当年的鲜衣怒马飞扬跋扈，可是谁都回不去了。十二万热血，十二万英魂。天下不再记得，朝臣不敢提起，君王假装忘记。虽然还是有人记得当年的小火人，虽然还有人念念不忘赤炎少帅，虽然还有人放不下少年的小殊，可是，没有用。肌肤骨骼一点一点碎裂，而后重长，十三年忍辱负重，他就只是梅长苏。梅长苏不是来妥协的，梅长苏不是来失败的，梅长苏永远不会放弃。他毕生的精力只用在了一件事上。梅长苏，你的一个挥手，一个眼神，闻不惯的香味，喜欢吃的榛子糕，甚至连呼吸方式和生命期限，都有目的。你不累吗？靖王被立为太子，权柄在握，战功显赫，朝堂之上再也没有人可与之争锋。梅长苏，你累不累？都走到了这一步，只要靖王上位，什么案不能翻？可是，他为什么不等。因为就算是正义是事实，只要靖王指摘的是自己的父亲，他就会背上不忠不孝的骂名？处心积虑，让君王无力遮掩，只能正视自己的错。罪己诏？唤不回十二万英魂！他只是想，让他的兄弟上位之后一身光明磊落，千古流芳。他只是想，让错的人知道自己的错。他只是太坚持他的原则。十三年的冤案昭雪，是不是一切的纷争都走到了尽头？梅长苏，你太累了，该歇歇了。可是，他没有。因为他是梅长苏。外敌来犯，靖王刚刚登基，一国之本，不可出战。可是，国无栋梁。梅长苏，用重药之后披甲上阵。赤炎军的灵魂在他手中重生。天下人终于知道，赤炎军的英名不灭，灵魂不死。这才是真正的昭雪。赤炎昭雪，你的使命完成了，所以，你撑不下去了吗？梅长苏，像你这样的人，也该歇歇了。从开篇到结尾，我没有等到梅长苏的那个她。整个故事，梅长苏有的只是计谋和病痛。心智不全的少年和他赤炎军的兄弟们，陪着他走到最后。梅长苏，下一个故事，一定要有红泥小火炉，一定要有红袖添香夜读书，一定要有那个让你渴望延续生命的人，一定要，有人陪着你。看完了，故事也只是故事而已，更何况，架空的历史和军事，这个世界上从来没有这样一个人存在。可是我忍不住要用文字记住他。那个“遥映人间冰雪样，暗香幽浮曲临江，遍识天下英雄路，俯首江左有梅郎”的梅长苏；那个有着“麒麟之才，得之可得天下”的梅长苏；那个一身伤病，生寿难永的梅长苏。总是浮现的他的样子，便是一袭白衣，长身玉立的清俊模样，便是惊采绝艳，计谋天下的骄傲模样，也便是洗骨换髓，面色苍白的青年。昔日最疼爱他的皇奶奶逝世之时，他把自己关在屋里尽孝一月，未能在逝者灵前跪拜，他只能遥望宫阙，用手去触摸虚空的记忆。昔日最亲密的战友，从小一起长大的挚友，最初用不屑的眼神看他，用毫无感情的冷言嘲讽，只因那张他熟悉的脸孔已变，再无当年少帅的风采，他也唯有心酸无奈，但却一直隐忍。昔日的爱人已另投他人怀抱，昔日家园已成废墟一片，可是他还是要继续战斗，为天下仅存的正义和忠勇，为无辜枉死的沙场英烈。只因他不仅仅是梅长苏，他还是一个本该死去，却生生从地狱中爬出来的人，昔日皇朝最耀眼，最张扬的赤焰少帅林殊。我想看看当年雪夜薄甲，追敌千里的他，跳脱飞扬，如同烈日的他，清风皓月，且歌且行的他。然而终究是回不去了，他一身功力尽失，如风中残烛，命在旦夕。我看他满脸倦意，心力交瘁；我看他翻云覆雨，纵横捭阖。终于，萧景琰坐上了皇位，赤焰军得以平反。七万英烈的魂魄终得安息作为苏哲，他完成了自己的使命作为林殊，他承担了自己的责任我以为，从此他便只是梅长苏，可以携至交好友，畅游江湖，了却余生。我以为，是的，只是我以为。终于，他做出了那个令所有人都心痛的决定。他用半年，一年，甚至更久的生命，换取三个月的鲜衣怒马，保家卫国。他是林殊。苏哲是你的幻影，梅长苏是他的向往，而那有血有肉有灵魂的只是林殊。哪怕挫骨削皮，哪怕岁月变迁，他也只能是林殊。滚滚热血，依然流淌。漫天黄沙中，我又见他昔日肆意张扬的笑脸。白骨如山忘姓氏，无非公子与红妆。战争结束了，看到新皇在每夜手抄阵亡名单，抄到最后一个却泪流满面的时候，新皇也许注定了孤寂一生。年年雪里埋新酒，却与何人谋一醉？我想要记住的是，就算白云苍狗，就算无力回天，也要有自己至死坚持的原则。我想要记住的是，就算人心险恶，就算世道沧桑，也要有从未想过放弃的梦想。我想要记住的是，这个世界上不光有无耻的奸佞小人，不光有昏聩的无道庸君，还有春闺梦里依依等待却终不可得的少妇，更有为了天下苍生抛头颅洒热血的无名枯骨。我想要记住的是，一种心情和一种信念。","tags":[{"name":"琅琊榜","slug":"琅琊榜","permalink":"http://xj8c.cc/tags/琅琊榜/"}]},{"title":"10个最佳 javascript 开发实践","date":"2015-09-01T11:46:01.000Z","path":"2015/09/01/10-best-javascript-development-practices/","text":"使用很多javascript代码的web页面会加载很慢，过多使用javascript会使网页丑陋拖沓……如何有效使用javascript是一个非常火热的话题。在此列出10个最佳javascript实践，帮助你有效地使用javascript。 1、尽可能保持代码简洁可能大家都听到过了N遍这个代码简洁问题了。作为一个开发人员你可能在你的代码开发过程中使用了很多次，但千万不要在js开发中忘记这点。尽量在开发模式中添加注释和空格，这样保持代码的可读性在发布到产品环境前请将空格和注释都删除，并且尽量缩写变量和方法名使用第三方工具帮助你实现压缩 javascript。2、思考后再修改prototypes添加新的属性到对象 prototype 中是导致脚本出错的常见原因。12yourObject.prototype.anotherFunction = ‘Hello’;yourObject.prototype.anotherMethod = function () &#123; … &#125;; 在上面代码中，所有的变量都会被影响，因为他们都继承于yourObject。这样的使用会导致意想不到的行为。所以建议在使用完后删除类似的修改。123yourObject.prototype.anotherFunction = ‘Hello’; yourObject.prototype.anotherMethod = function () &#123; … &#125;; test.anotherMethod();delete yourObject.prototype.anotherFunction = ‘Hello’;delete yourObject.prototype.anotherMethod = function () &#123; … &#125;; 3、Debug Javascript代码即使最好的开发人员都会犯错。为了最大化减少类似错误，请在你的 debugger 中运行你的代码，确认你没有遇到任何细微的错误。4、避免 Eval你的JS在没有eval方法的时候也可以很好的工作。eval允许访问 javascript 编译器。如果一个字符串作为参数传递到eval，那么它的结果可以被执行。这会很大的降低代码的性能。尽量避免在产品环境中使用eval。5、最小化DOM访问DOM是最复杂的API，会使得代码执行过程变慢。有时候web页面可能没有加载或者加载不完整。最好避免DOM。6、在使用js类库之前先学习javascript互联网充斥着很多的javascript类库，很多程序员都往往使用js类库而不理解负面影响。强烈建议你在使用第三方类库之前学习基本的JS代码，否则，你就准备着倒霉吧。7、不要用 “SetTimeOut” 和 “Setinterval” 方法来作为 “Eval” 的备选1setTimeOut( &quot;document.getID(&apos;value&apos;)&quot;, 3000); 在以上代码中 document.getID(‘value’) 在 setTimeOut 方法中被作为字符串来处理。这类似于eval方法，在每个代码执行中来执行一个字符串，因此会降低性能，因此，建议在这些方法中传递一个方法。1setTimeOut(yourFunction, 3000); 8、[] 比 new Array(); 更好一个常犯的错误在于使用当需要数组的时候使用一个对象或者该使用对象的时候使用一个数组。但是使用原则很简单：“当属性名称是小的连续整数，你应该使用数组。否则，使用一个对象” - Douglas Crockford, JavaScript: Good Parts 的作者。建议： 1var a = [&apos;1A&apos;,&apos;2B&apos;]; 避免： 123var a = new Array();a[0] = &quot;1A&quot;;a[1] = &quot;2B&quot;; 9、尽量不要多次使用var在初始每一个变量的时候，程序员都习惯使用var关键字。相反，建议你使用逗号来避免多余的关键字，并且减少代码体积。如下：123var variableOne = ‘string 1’,variableTwo = ‘string 2’,variableThree = ‘string 3’; 10、不要忽略分号 “;”这往往是大家花费数个小时进行 debug 的原因之一。我很确信你肯定也在其它的文章中阅读过以上相关的内容，但是大家可能往往都忽略了很多基本的规则。你是不是也曾经忽略过分号，是不是也遇到过eval关键字问题导致性能问题？","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xj8c.cc/tags/JavaScript/"}]},{"title":"史上最难回答的30个问题，没有一人都能答对！","date":"2015-08-07T12:55:58.000Z","path":"2015/08/07/the-30-most-difficult-questions-to-answer-in-history/","text":"为什么男装纽扣在右，而女装在左呢?纽扣最初问世时，只有富人的外套才钉纽扣。按当时的风俗，男士自己穿衣服，女士则由仆人帮穿。女士衬衣上的扣子钉在左边，极大地方便了伺候女主人的仆人们(现在方便男人脱)。男士衬衣的扣子在右边，除了自己穿衣服，还因为用右手方便拔出挂在左腰的佩剑，这样就不容易被衬衫兜住。 为什么是上厕所、下厨房?中国自古以来就有五行，五行分别对应五个方位。古代厕所建造在北面偏东的位置，厨房要建造在南面偏东。去南方时，习惯说南下(皇帝下江南)，去北方时，习惯说北上(北上抗日)。当要去厕所时要去院子的北面，所以说上厕所。当要去厨房时，要去院子的南面，所以说下厨房。 俗语为什么是不三不四?古人称天为一、地为二。所以天地相加为三，三即成为整体的代表，比如：三部曲、三省、三思、三人行等等;而对于四则称之”周全”，亦有称心如意的意思，比如四大金刚、四大家、四体、四艺、四书等等。所以把”美好事物”之外的，行为不端的人统称为”不三不四”。 李耳为什么叫老子不叫李子?第一种说法，老子生下来就是白胡子白眉，耳朵又大，所以又叫老子又叫李耳。显然这种说法很科幻、很胡扯。第二种说法更贴切一些，李耳本来就姓老，名老聃，即李姓源于老姓。而且李姓渊于老虎图腾，苦县一带虎被称为”狸儿”，所以李耳只是”狸儿”的误传罢了。 佛家弟子为什么都姓释?释姓是汉人姓氏之一，一般为汉传佛教出家人统一使用之姓氏，并未收录于《百家姓》中。中国出家人以释为姓，始于道安禅师。佛教初期魏晋沙门，以师为姓，故姓各不同。道安以为，根本道师乃释迦世尊，故”以释命氏”，后来他译《增一阿含》，有”四海出家，同称释氏”之语。 十二生肖为什么没有猫?有民间神话传说用”鼠骗猫”的说法来解释这个问题，但真正的原因是因为中国古时无猫，猫原产于埃及，何时传入中国已不可考，民间传说则由唐三藏从印度带回(其实是汉朝)。所以猫在传入中国以前，中国的十二生肖早就排完成定论了。而且，十二生肖中已经有了老虎这只大猫，所以小猫就不用值班了。 人为什么要打呵欠?打呵欠这种行为一直困扰着科学家有两个原因。一是打呵欠似乎没有任何作用。但打呵欠的时候，如果你想抑制它，你的身体会不由自主地抽搐，面部会因痛苦而扭曲，你感觉血液似乎要从鼻孔里涌出。同样困扰科学家的还有呵欠的传染性。看看，你刚打呵欠了吧? 回复姓氏为什么要免贵?在夏商周之时，姓氏分而为二，男子称氏，女子称姓。《通志·氏族略》有云：”贵者有氏，贱者有名无氏。”姓用来区别婚姻，同氏不同姓可通婚，同姓不同氏不可通婚。秦统一以后，姓氏合二为一。因姓氏还是贵者，所以往往要问”贵姓”，而有人问”贵姓”，才能回答”免贵姓某”。当然，如果你姓张和姓孔，你就不需要回答免贵了，因为这是老天爷和孔圣人的姓噢。 诺贝尔奖为什么没有数学奖?诺贝尔在遗嘱中提到：奖励那些对人类做出巨大贡献的”发明或发现”。他不认为数学是人类可藉以得益的实践科学，因而数学被排除在诺贝尔奖之外。其实是诺贝尔曾向一位女士求婚，而她却嫁给了名叫米泰莱弗勒的数学家，还共同欺骗了诺贝尔，诺贝尔终身未娶，他恨数学啊。 本命年为什么要穿红?风水位理学认为，逢本命年时，生肖守护神要去天庭参拜，按现在的说法就是述职，这时对人的保护就会减弱，妖魔邪祟就会乘虚而入，红色能够去灾辟邪。这与”过年”贴春联的来历也有关联，所以人们用穿红衣服，系红腰带来去灾辟邪，后来被人们发扬光大，连内裤袜子都要红色。 百家姓开头四姓为什么是“赵钱孙李”?明清文献记载，《百家姓》是宋朝初期，由一位吴越地区的儒家学者最先编辑。所以他用了当朝皇帝的姓氏为第一姓;五代十国时期吴越国的国王姓”钱”;”孙”是宋朝皇族妻妾的姓;”李”是后唐皇帝李后主的姓氏。这就是《百家姓》开头四姓”赵钱孙李”次序的由来。 犬子的来历“犬子”本是司马相如小名，《史记》记载，司马相如”少时好读书，学击剑，故其亲名之曰犬子”。他长大后，也觉得名字不好听，加上又仰慕蔺相如的为人，自己便更名为相如。但司马相如的成名，”犬子”也不断为人所知。人们便争相效仿，谦称自家儿郎，用上了”犬子”一词。那么龟儿子呢? 二百五的来历苏秦一直努力说服六国联合抗秦，史称”六国封相”。但苏秦在齐国的时候被刺客杀了，齐王为了抓出刺客，特贴出告示，声称苏秦为大内奸，刺杀苏秦者赏金千两。告示一出，立刻有四个上钩，声称是自己所为。齐王正恨刺客牙痒，怒：千两黄金每人二百五，顺便把这四个二百五推出去砍了! 过年为什么要给孩子压岁钱?北宋神宗年间，某年春节夜晚，有个副宰相王韶的小儿子南陔，跟随大人在街头观灯游玩时，不料被歹人掠走，想勒索王韶一笔钱财。逃跑中正巧遇朝廷车子经过，南陔大声呼救，歹人放下南陔仓皇逃跑。后来，宋神宗得知此事后，就赐予南陔一些金钱，给他压惊，从此”压岁钱”在民间流传开来。 中国人为什么把说大话叫吹牛?从前宰羊时放完血，屠夫会在羊的腿上割开一个小口，把嘴凑上去使劲往里吹气，直到羊全身都膨胀起来，用刀轻轻一拉，皮就会自己裂开。这叫吹猪或吹羊。如果谁要说可以把牛皮吹起来，那就是说大话了，因为牛皮很大，而且非常坚韧，根本吹不起来。所以”吹牛”就是说大话的代名词! 宰相肚里能撑船的来历宋时宰相王安石中年丧妻，续娶了一妾名唤姣娘。老夫少妻的生活，使得姣娘私下与年轻仆人偷情。王安石知道后，本来火冒三丈，但一忍再忍，干脆在中秋节对诗的时候，诱使姣娘讲出实情，但姣娘一句”宰相肚里能撑船”让王安石深知其苦，即赐银千两，送姣娘与仆人成婚。 为什么是替罪羊而不是替罪狗?圣经《旧约》：挪亚后有个叫亚伯拉罕的闪族人，他99岁得一子。一天，耶和华突然降临，要他杀子以撒献祭。以撒不知自己是祭品，跟随父亲上山，亚伯拉罕准备好一切，正将儿子放上祭坛欲动刀时，天使飞来拉住其手，不准他杀子，告诉他只是耶和华的考验，并改用羊来做为祭品。这就是替罪羊的来历。 拍马屁是怎么来的?一说是元代蒙古人有个习惯，两人牵马相遇，要在对方马屁股上拍一下，表示尊敬。二是蒙古族好骑手遇到烈性马便拍拍马屁股，使马感到舒服，随即乘势跃身上马，纵马而去。三是蒙古人爱马，如果马肥，两股必然隆起，所以见到骏马，总喜欢拍着马屁股称赞一番。 哪壶不开提哪壶的来历早年，有父子俩开了一个小茶馆。知县白老爷是一个贪财好利的主儿，经常来白吃白喝。虽然父子俩受不了，有气，但也没办法。有一段时间老掌柜病了，小掌柜司炉掌壶。等老掌柜病好以后，发现县太爷再没来了。问其缘由，小掌柜一笑说：”我给他沏茶，是哪壶不开提哪壶!” 为什么占女人便宜叫“吃豆腐”?汉朝，长安街上有个夫妻开的豆腐店，老板娘生得漂亮，风情万种，人称”豆腐西施”，为招徕顾客，难免有卖弄风情之举，引得周围男人老以”吃豆腐”为名到豆腐店与老板娘调情，趁付铜板时摸摸老板娘的纤手等。后来，“吃豆腐”便成了男人轻薄女人的代名词。 孺子牛的来历?齐景公非常疼爱庶子荼，有一次齐景公和荼在一起嬉戏，竟然口里衔根绳子，让荼牵着走。不料，儿子不小心跌倒，把齐景公的牙齿拉折了。齐景公临死前遗命立荼为国君。景公死后，陈僖子要立公子阳生。齐景公的大臣鲍牧对陈僖子说：”汝忘君之为孺子牛而折其齿乎?而背之也!”","tags":[]},{"title":"Win10正式版微软官方原版ISO系统镜像下载大全","date":"2015-08-05T10:22:37.000Z","path":"2015/08/05/windows10-iso/","text":"Win10正式版微软MSDN官方原版镜像下载地址在哪里？Win10下载地址、Windows10下载地址在哪里？ Win10正式版32位简体中文版（含家庭版、专业版）文件名： cn_windows_10_multiple_editions_x86_dvd_6846431.isoSHA1：21B824F402927E76C65160B62EB8A4EBBABE9C6Eed2k://|file|cn_windows_10_multiple_editions_x86_dvd_6846431.iso|3233482752|B5C706594F5DC697B2A098420C801112|/ Win10正式版64位简体中文版（含家庭版、专业版）文件名： cn_windows_10_multiple_editions_x64_dvd_6848463.isoSHA1：C71D49A6144772F352806201EF564951BE55EDD5ed2k://|file|cn_windows_10_multiple_editions_x64_dvd_6848463.iso|4303300608|94FD861E82458005A9CA8E617379856A|/ Win10正式版32位简体中文企业版文件名： cn_windows_10_enterprise_x86_dvd_6846962.isoSHA1：83797D3477E3E5346F804D65E46EF227A4535B1Ded2k://|file|cn_windows_10_enterprise_x86_dvd_6846962.iso|3100794880|B605D57635502A46B86ACC73764CCD9A|/ Win10正式版64位简体中文企业版文件名：cn_windows_10_enterprise_x64_dvd_6846957.isoSHA1：071A2B6CB634D46E12DC2B287DCFDB737A615281ed2k://|file|cn_windows_10_enterprise_x64_dvd_6846957.iso|4162242560|3F657E387CD65FE7BA69DACAAE0E3510|/ Win10正式版32位简体中文教育版文件名： cn_windows_10_education_x86_dvd_6847858.isoSHA1：F5E5B26C03180D492E32872B5D0E16DCFC134DA8ed2k://|file|cn_windows_10_education_x86_dvd_6847858.iso|3097344000|E65D0B95FC75EC17FA6E72DC7433B46F|/ Win10正式版64位简体中文教育版文件名： cn_windows_10_education_x64_dvd_6847843.isoSHA1：C948D930E229AB277AAFF9233CBD46F125AAC179ed2k://|file|cn_windows_10_education_x64_dvd_6847843.iso|4159854592|50A2126871A73D48FAE49D7D928D5343|/ Win10正式版32位企业2015 LTSB版文件名：cn_windows_10_enterprise_2015_ltsb_x86_dvd_6848426.isoSHA1：B0181D56B7C699890B69A21E77EDA40884F3CF24ed2k://|file|cn_windows_10_enterprise_2015_ltsb_x86_dvd_6848426.iso|2887350272|681C2F80A511FCEC73B7A5D878D4D9EC|/ Win10正式版64位企业2015 LTSB版文件名：cn_windows_10_enterprise_2015_ltsb_x64_dvd_6848425.isoSHA1：179A95E6A498EFE079FB1817D1ADF5A3B7793B4Ded2k://|file|cn_windows_10_enterprise_2015_ltsb_x64_dvd_6848425.iso|3907538944|38E47AB92B6D97DF2BE602BBC9969D34|/","tags":[{"name":"win10","slug":"win10","permalink":"http://xj8c.cc/tags/win10/"},{"name":"原版系统","slug":"原版系统","permalink":"http://xj8c.cc/tags/原版系统/"}]},{"title":"一本关于程序员的修真小说","date":"2015-08-02T02:14:15.000Z","path":"2015/08/02/the-work-of-a-programmer/","text":"本文产生自知乎一话题“怎么写出一本程序员风格的修真小说？”，于是乎有了下面这篇程序员修真奇文，现分享出来，以待各位看官共赏~ 终有一天我手中的编译器将成为我灵魂的一部分，这世界在我的眼中将被代码重构，我将看到山川无尽银河无垠都汇成二进制的数字河流，过往英雄都在我脑海眼前一一浮现，而我听到无数码农跪倒在我的程序面前呼喊。他们叫我代码之神。到那个时候，我想我一定可以找回你。 一丶这是一个属于代码的修真世界。这世界里的每一个人，每一个东西，包括高山大海，刀剑风云，其本质都是一串数字流。打个比方，如果你知道一块石头的内部数据结构，并且参透其中玄妙，你就能用程序改变它的一切。如果能参透自身这一个复杂的操作系统，就能重新编码自己，获得更大的能力。所以你的程序水平的高低，决定了你的牛逼程度。我们这些修真者，都叫程序员。有人的地方，就有江湖。有江湖的地方，就有代码。刚入门的时候，师傅跟我说，我们程序员修的，是一份境界。短短几句的代码里，要有最完美的逻辑，跟最精妙的算法。这本《算法导论》，你暂且拿去研修。我们程序员，外修语言，内修算法。以数据为根，算天算地算自己。听起来真的好酷。但这个江湖，并不平静。几大门派，上有微软谷歌，下至百度阿里，每个门派风格迥异，暗地里都有无数摩擦。师傅说，我们知乎派，理论见长。三大软狗、哦不，三大软神坐镇，还有无数默默搬砖的程序员，如今也算在乱世立稳了脚跟。师傅还说，江湖虽乱，但我们修真之人，说到底还是要修自身，恩恩怨怨都是过眼云烟，自身境界才是万源之本。我点了点头。师傅又拍了拍我的小脑瓜，慈祥一笑。他说，如果下次天涯派那群人还过来闹事，我们一定要秉承我们的自身理念来处理他们。我知道了，我回师傅道，我跟刘看山一定会好言相劝，么么他们个哒哒。不。师傅转身过来，鹰眼之中精光毕露，胡须颤动的嘴唇之中，一个字一个字地吐出来。灰飞烟灭，一个不留。二丶自我开始修真起，我练的便是C++的功夫。虽然大师兄跟我说过，不管你学的事什么语言，都是殊途同归。我们修真之人，都不要在乎这些差别，要参透的是程序的本质。然后他又说，不过，用Java的都是傻逼。大师兄跟我一样，C++的功底深厚，面向对象的各种技能用的精通，只是可惜，他还没有对象。我永远忘不了那一天，我们知乎派的山门被一众凶恶之徒所踏破，山石飞舞，浮尘弥漫，门派服务器都暂停运行。大师兄坐在大殿房顶之上，喝一壶陈年的竹叶青。姿势潇洒，闷骚至极。是他们，谁都知道，天涯派不止一次来闹事。我从来没见过大师兄出过手。天涯派的来人，在烟尘之中现出数个魁梧身影，还夹带了一声大笑和开场白：哈哈哈哈哈哈哈，知乎派，hello world！大师兄的眼皮都没有眨一下。他的右手之上字符串环流浮现，左手抬起酒壶一饮而尽，右手对着虚空就是一指，那一串字符都消散在空气之中。刹那间风云突变，一阵狂风似有形一般，沿着大师兄所指方向似一条狂龙横冲了过去，一个照面便将几个大汉吹得撞出山门之外，摔了个七荤八素。那一霎我屏住呼吸大师兄整了整风中凌乱的发型，说，这就叫快速傅里叶变换，将风压重新编码，所到之处，寸草不生。你们都还在解码自己，我已经开始操纵世界——天涯跟知乎，就是在这里的差距，懂？都他妈的给老子滚从那一刻开始，我才知道，有些人已经可以编码这个世界本身。这才是叫修真。三丶在知乎里修行了十年，师傅说我可以下山了。我已经熟知C++的基本技能，但师傅告诫我千万不要说自己精通C++。他说，这世界上，没有人可以说，他已经精通C++，所以即算你装逼的时候，也要装得像个样子。比如，你可以说你精通java。我点头称是。这十年来，我每日苦读《算法导论》和《C++ primer》，精通数据库原理跟操作系统，同龄人之中无人是我敌手，自认为天下哪里都可去得。是为年轻气盛，是为势不可挡。我下山之后，连连在江湖之中，将一些有一点点小名气的程序员斩于马下。他们之中，有些是根基不稳，有些是反应迟钝，有些是冥顽不灵，有些是莽撞愚蠢。当然，我现在说起来是云淡风轻，那是因为我在装逼。其实也经过了一番苦战，有过一些辛酸。终于有一天，我将天下程序员排行榜第一千位的马特给击败，成功登上天下程序员排行榜。马特这个程序员，有一些狡猾。他占据第一千位，已经很久没有变过。他精通计算机图形学，经常使用一些幻境击败对手。他比他上面几位更加难缠，所以通常没有人会去挑战他。因为你赢了他，也只能到第一千位，还不如去挑战他上面的更划算一些。可惜他遇到了我，因为我比他，更精通计算机图形学。于是这也成为一个不大不小的消息，在江湖里传播，从此我有了一个外号，他们叫我杀马特。俗话说树大招风，人不能太出名。有一天看到一个酒馆，我走进去，一个风情万种的女人转过来，她问我，客官，你要喝点什么嘛？我说，三两竹叶青。正当我在喝酒的时候，来了一群穿着黑衣的程序员。这群人，个个怪异，但水平很高。江湖之中，穿黑衣的程序员，都叫黑客。来者不善。他们将我围起来，为首的一人说，他们是做安全的。我心中陡然一惊。因为我看到了他们衣服里藏着的，三百六十度的环形刀刃。一百年前，有一个叫奇虎的门派。他们每个人，都有一把神秘的三百六十度的环形刀刃，所以也叫奇虎三六零。他们声称他们的存在，是为了防止世界被破坏，为了保护世界的和平，是为了贯彻爱与真实的勇敢，他们是穿梭在江湖中的三六零。但他们却暗中做了无数秘密勾当，后来江湖人人称之魔教，BAT三大派跟一些其他门派联手围上光明顶，将其灭门。当然，我们知乎派，也在之中出了不少的力量。我皱眉喝酒，问他们所为何事。那为首一人，拿过我的酒壶，仰头一灌。最后一滴酒在壶中滴落之时，无数环形刀刃在我身边出现，他的手中也倏地出现一把，朝我迎面砍来。竟是偷袭。刀刃之上闪过的代码我毕生未见，锋利无比，威力惊人。我虽鼓动全身能量，瞬间编译，但也感觉凶多吉少。这电光火石一瞬间，只听得铛地一声，数把环形刀刃通通弹落一边，那些黑衣怪人通通倒地。我靠，我有这么强？只听得酒馆二楼悠悠传来一个女声。要打去别的地方打吧，进来酒钱都没付，还要打我的客人，这是何理？原来是酒馆的女老板。她从二楼飘飘而落，将我身边灰尘一扫而空，朱唇轻启，哎呀，吓到小哥你了，真是对不起。我以前听师傅说，对于程序员，只有两种东西是天敌。一种是御姐，一种是萝莉。我说我不信。我现在信了。四丶女老板说，可以叫她结衣。她问我叫什么，我嘟哝了半天，我说我叫杀马特。结衣说哈哈哈哈哈哈哈你真可爱。我说结衣，你怎么会这么强。她说你不懂，我一个弱女子，不懂点编程之术，在这江湖里怎么开酒馆嘛。我说结衣，你怎么这么好看。结衣不说话了。结衣说，你这个小流氓。我说结衣，师傅说，我们程序员只有两种天敌，一叫御姐，二是萝莉，你是哪一种？结衣说，我都不是。我说，哦。其实我心里想着的，是你都是。结衣，你跟我一起闯荡江湖去好不好？不好，你还没我强。哦。那等我比你强了，我们一起去闯荡江湖好不好？结衣笑了一下说，不好。于是我就住在了酒馆里。因为我可能，爱上了这个女人。我杀马特曾经以为，我这一辈子就只能爱上一个女人。后来我才知道，这世间有万千代码，万物都可编译，但你编译不了的，是自己的心。结衣是一个看上去很好强，八面玲珑的女人。她的编程水平，比那些排行榜上五百位之后的怂蛋，不知道高到哪里去了，但是她却在这里经营一个小酒馆。我曾经问过为什么，但是结衣不说。她只说她在等人。我想问她是不是在等她的意中人，但是又不好意思开口。我怕是的，那我可能要伤心。师傅说修真的程序员，不能伤心。伤心的程序员，写不出好的代码。所以我也只能等。终于等到有一天，那天酒馆外面都是黑漆漆的云，空气里都是紧张的、像墨水混合了砂子一样的味道。可能有沙尘暴。结衣一脸严肃。我说结衣，咱们把门关上避一避。结衣一言不发，站在门口，看向远方。过了一阵，远处黑云之中，竟然出现一个人影。霎时间，雷光闪动，暴雨如注。结衣看了我一眼，转身腾空就飞了出去。朝着远处的黑云人影，鼓动着浑身能量，就这么飞了出去。我大喊一声结衣，然后也跑了出去。雨越下越大，我只能隐隐看见远处电闪雷鸣，我在混乱之中大喊结衣。他们在交战。远处代码一行行在云端飞舞盘旋，命令与字节化为巨大的力量，我没有想到结衣竟然强到这个地步。举手投足，山河变色。我想起大师兄所说的，有人还在解码自身，有人已经操纵世界。是一场恶战。我只能站在下面看，我甚至都不知道他们交战的具体情况。我心急如焚。在一个天际的惊雷响彻之后，一道正弦函数冲击波将所有黑云弹射开来，而我只看到结衣在空中坠落的身影。拨云见日，阳光普照。在很多年之后，当我再回想起这个情形，还是觉得，即算是临死之时的结衣，在空中的身影，也那么美好。我抱着结衣，泣不成声。她看着我，怔怔的看着我。她说你别哭，真的，这是注定的一天。她说我们家以前侵入国防系统，被朝廷发现灭门，我侥幸逃脱。但是不管我在哪里，总有一天他们会找上来。她说你是男孩子，要坚强一点。不坚强一点，你怎么成为最好的程序员。结衣在那几分钟里，好像想把她一生没讲完的话，都给讲完。她说的最后一句话是，杀马特，你一定不要忘了我。然后她就再也没有说话了。我甚至都没有问过她说，你有心上人吗？我甚至都没有跟她说过，我是真的很喜欢你。我甚至都没有吻过她，没有牵过她的手，我们只是这样匆匆遇到，然后匆匆告别。她的身体将化成一串数字流，失去结构，流向无尽的原野、河流跟大地，化为三月的春风、杨柳跟雨滴。有些东西，是命。我的整个程序员修真生涯，在这一天，被分割开来。对，我杀马特，在这一天之后，是一个一定要成为天下第一的程序员。为了结衣。五丶并非是单单想给结衣报仇。我们程序员的修真之路，内修自己，外修天地。当代码可以操控天地这个最为复杂的系统之时，就一定会涉及到世界的本源之处。若这个世界的代码在我眼前一览无遗，或许我可以控制时间。或许我可以从时间的bug里，找回结衣。这是我这么多年来的，唯一念想。毕竟我们程序员，生来就要逆天改命。之后的时间里，我从程序员排行榜上一路飙升，五年之后跻身前十，成为世界上最优秀的程序员之一。我树敌无数，也击败无数敌人。他们之中，甚至有自创一门语言的奇才，有号称已然精通C++的装逼犯，有对各类操作系统跟编译原理都熟悉无比的怪才，但是，不管谁，都无法阻挡我杀马特的脚步。无人可挡。生来彷徨。但，即算是到了我这样的水准，我也依旧无法知道，如何寻找这个世界里时间的bug，甚至都没有一丝头绪。每逢debug的夜晚，我都会想起结衣，明媚如歌的笑容，和她从天而落，如佛光普照般的美丽。但这又时时提醒了我，我可能真的已经离她远去了，而我无能为力。这世间我认识的高手，都无法为我解答这个问题。直到有一天，我在山间遇到一个红衣人。他是个高手，从看到他码出第一行代码的时候，我就知道，这是个绝顶高手。山野相逢，抛却了身份。我跟他把酒言欢，知无不谈，倒也痛快。直到我跟他说起关于这世界里，时间的bug。他说，这世界极有可能是在一个环形循环之中。说罢他从怀里掏出一把刀，却正是奇虎派的那把三百六十度环形刀刃。他说你看这把刀，我派毕生所愿，即是参透这世界的圆之循环，重新编码，到时候天下唾手可得。我说，我不想要什么天下，我只要一个女人。红衣人哈哈大笑，说，那你加入我们，来我奇虎参透这世界运行之时最底层的命令，参透这循环，说不定你就能重新遇到那个女人。对，我没有犹豫，我答应了。他说，他叫周红衣。六丶我就这么加入了奇虎三六零。彼时奇虎正在重整旗鼓，周红衣想要东山再起，他不能少了我这个助力。从此我手里多了一把，三百六十度的，环形刀刃。萧萧狼烟，江湖恩怨再起。人在江湖，真的身不由己。我一边参悟奇虎派祖传的代码跟算法，一边帮奇虎派征战天下。我是知乎派出身，根正苗红，师傅知我落入魔教之手，吐出一口老血。孽徒，孽徒啊。他们也曾劝降，但我不为所动。我心中，有我自己的编程之道。所以我很清楚自己在干什么。我很清楚，男孩子，要坚强。奇虎的势力扩张得很快，但正邪势不两立，BAT三大派见天下形势如此，便要集结程序员部队，重新再上一次光明顶。他们说，一百年前能灭的，现在也能灭。光明顶，是我奇虎派的大本营。而他们带队之人，正是当今天下排行第一的程序员，出身知乎、神龙见首不见尾的大师兄。大师兄，真的好久不见。说实话，虽从一开始，我便知道自己背负的是什么，但我也并未想过，有一天要跟大师兄动手。也许在成为男人的路上，杀死偶像，都是不可避免的一环。大师兄还是酒壶一把，桀骜不驯。他说傻小子，你现在过来，还真的来得及。我说大师兄，皇皇天下，哪有什么正邪分家。无非是你来我往，你抢我杀。咱们做程序员的都知道，手底下见真章。大师兄喝酒，哈哈大笑，他说你有长进，然后把酒壶朝天一扔。** Talk is cheap，show me the code。** 七丶与大师兄交战之前，我正参悟到这个世界代码的一些关键之处。如今一战，倒是针尖对麦芒。大师兄的编程能力，已然步入化境。代码不在手上，已在心中。物质都是数据，规则都是代码，一时间天地轰隆，流云沐风皆能当锋利兵器，重力气压都能做任意改变，我跟大师兄从天到地，战了个平分秋色。大师兄说，没想到你小子这么难缠。大师兄说，对不起，我必须解决掉你。为了正义。我从没见他说过对不起，这正如他一定会放一个前所未见的大招一样可怕。大师兄操纵无数代码，打入大地之中，蓦地瞬间，我感觉脚底重力似乎加大了无数倍。好沉。好一个无限重力流。我们这边的程序员，要么被强大重力挤压变形，最舒服的也寸步不能动弹。大师兄竟然还没有结束，他接着操纵无数代码，打入遥远天空之中，竟从无垠星海之中召来巨大陨石。陨石当空，重力无限。这两者相结合，他竟凭他一人之力，要横扫整个奇虎。不愧是天下第一的旷世奇才。我承认，面对这样的攻势，我并没有什么好的办法。但我也不后悔。既然踏上这条路，我就没有打算过回头。陨石从我头上落下之时，生死交错的瞬间，我仿佛又看到结衣的脸，像电影一般飞驰而过的场面。我突然领悟到些什么。我在那一瞬也打出无数代码，我打出的代码，跟大师兄的，一模一样。复制代码，通常比较容易。我脚下重力瞬间又加大无数倍，其他的程序员早已不堪重负，化为一摊数据流。而那个陨石速度越来越快，擦出巨大的热浪火花，空间都变形扭曲，周围一切化为粉末，消散无形。我以为那个瞬间我已经死了。而我在那一个瞬间，看到了在弯曲变形的前方，有一个时空的奇点。时间是一个圆。我靠近它，向死而生。前方白光一片。八丶我睁开眼。眼前是那个熟悉的酒馆。我走进去，一个风情万种的女人转过来。她问我，客官，你要喝点什么嘛？完。","tags":[{"name":"小说","slug":"小说","permalink":"http://xj8c.cc/tags/小说/"},{"name":"程序员","slug":"程序员","permalink":"http://xj8c.cc/tags/程序员/"}]},{"title":"Win10的十个亮点","date":"2015-08-02T01:45:08.000Z","path":"2015/08/02/Win10-ten-points/","text":"北京时间7月29日中午12点，微软在中国正式发布Windows 10，目前，有不少预定了升级版的微软用户已经开始在各大论坛和社交网络开始谈使用心得。 同日，微软会在北京、悉尼、东京、新加坡、新德里、迪拜、内罗毕、柏林、约翰内斯堡、马德里、伦敦、圣保罗和纽约这13个城市举行了规模盛大的庆祝活动。其中北京的庆祝活动于本日19点到21点在北京水立方举行。 尽管自Windows 95发布以来，搞个热热闹闹的发布会已成为微软每次发布新系统的惯例活动。但相较于从Windows Vista到Windows 8.1这几代产品的不温不火甚至令人失望，Windows 10则寄托了粉丝们太多的期许。 而微软也是摩拳擦掌，准备靠Windows 10彻底挽回自Windows 8系统发布以来的失败，试图在移动互联网时代保住PC市场的活力并振兴自己的手机业务。 Windows 10究竟有何等魅力，令厂商、用户如此寄予厚望?以下虎嗅整理了Windows 10系统的十个亮点，看完之后你会不会试一试? 一、免费：等了好久终于等到今天 微软早在今年一月份的发布会上就公布了这一消息：Windows 7、Windows 8/8.1系统可免费直升Windows 10!并且Win 10其后的升级版本都将支持永久免费更新。 目前网上已有RTM版可供下载，另外360安全卫士、腾讯管家也提供免费升级Windows 10服务。不过盗版系统想要升级正版Win 10可能要稍微绕些弯路……据报道，微软官方表示，大部分用户在7月29日之后都能升级Win 10，但升级后仍然需要付费完成安装。说是这么说，但网上已经流传着很多针对此问题的解决方案……请大家自行百度吧。 二、开始菜单：又回到最初的起点 Windows 8系统中，伴随一代用户的开始菜单被砍，引得哀声一片。很多用户拒绝从Win 7升级到Win 8，或可视为对微软此举的不满。而在Windows 10中，我们熟悉的开始菜单回来了，而且你可以任意调整它的大小，甚至能够占满整个屏幕。它仍然保留了磁贴界面，所以并不会对移动设备的体验造成太大影响。你可以将它视为Win 7开始菜单与Win 8开始菜单的结合体。 三、Continuum：手机PC平板傻傻分不清 Continuum功能它可以让平板电脑、二合一设备以及变形本等设备用户更加方便地在平板模式和传统PC桌面模式下无缝自然切换，用户设备可以通过此功能适应不同的使用场景，不论何种输入设备以及何种尺寸的显示屏幕都将获得一致的体验。 Windows 10会自动感知设备运行模式的改变，并自动调整到最适合的模式，用户只需确认是否要改变模式即可。微软的统一平台做了这么久，体验一直不尽人意，现在终于像点样子了，可喜可贺。 四、Cortana：你存在我的歌声里 微软招牌的语音助手“小娜”，号称比Siri和Google Now都更智能。主角名字来自微软游戏《光晕》的人物名字Cortana，在经过嵌入WP8.1系统的手机之后，还进驻了iOS和Android平台，这次将更深入地整合到桌面操作系统中。你可以让她给你唱首歌、讲个笑话或者订火车票……随时随地，任你调戏。 如果你对电影《她》中的“萨曼莎”情有独钟，那么你也一定会爱上“小娜”……“小娜”的好姐妹是“小冰”，这款人工智能聊天机器人的微博粉丝达243万，已共计完成6亿次对话，堪称陪聊神器。你也可以通过和小娜对话来召唤小冰，如果不怕小娜吃醋的话…… 五、虚拟桌面：Windows也可以 虚拟桌面使得同时操作多个应用进程成为可能，每一个虚拟桌面都是独立的区域，在多桌面环境下，用户可以更高效地展开工作。也就是说，如果你觉得一个桌面里开启的程序太多，空间不够用，那么就可以再打开一个桌面来开启其他程序。需要注意的是，目前的Windows 10虚拟桌面中还不能为每个桌面单独设置桌面壁纸，桌面图标排列也是公用的。 不管怎样，虚拟桌面对用户体验的提升还是很有帮助的。好吧，我知道Linux早就有了…… 六、通用版Office：部分免费与部分收费 最新的通用版Office也将登陆Windows 10系统。该版本针对台式机、触摸屏和移动设备等平台进行了优化，可无缝运行在包括Windows Phone、84英寸的Surface Hub在内的所有Win10设备中。但它仅在10.1英寸以下的设备中免费，在更大尺寸的设备中使用，就要交钱了。通用版Office主要针对触控设计，提供给手机、平板用户，PC用户可以安装功能更强大的Office 2016。据说它已经有破解版了…… 当然，无论是通用版Office还是Office 2016，最终还是会合并到一起的。 七、Microsoft edge：这就是斯巴达 IE背负了太多恶名，于是微软开发了Project Spartan，在后来的测试中，“斯巴达”被正式命名为Edge。 Edge区别于IE的最重要改进，是支持了扩展程序。这是Edge的一小步，微软的一大步!回想当年IE浏览器靠内置Windows系统把网景打得节节败退最终关门大吉，而后IE自己却又不思进取每况愈下成为外界黑微软反应慢的靶子。这次微软直接把名字一改，宣布改头换面，重新开始，足见其决心之大。#改名部立功了# 此外Edge在细节上颇下了一些“苦功”，比如“Web笔记”，你可以通过它随时随地在网页上做笔记。比如采用采用全新的Edge渲染引擎，浏览网页的速度和安全性都得到了不同程度的提升。 八、游戏：手牵手，一起走 Windows版PC和Xbox ONE牵手成功!首先，Win10支持Xbox ONE，并且搭载Win10的PC可以和Xbox ONE共同游戏，真正的跨平台联机。其次，通过Win10，Xbox ONE平台的游戏可以投射在任意一台Win10平板或PC上。最后，Win10支持DX12，这使其游戏性能提升50%，实在是玩家们的福音。电脑上可以玩Xbox了，那么我们还要电视干什么…… 九、通知中心与应用商店：你有我有全都有 Windows 也提供通知中心啦!通过该功能你可以自由开启或关闭通知，还有各种开关和快捷功能。Win 10通知中心与OS X中的颇为相似。而OS X中的通知中心是可以与iOS通知中心相结合的，所以微软接下来应该也会在跨平台融合方面做出改进。 在通知中心之外，Win 10还将支持统一的应用商店，所以微软这次真的不再任性，虚心向同行学习了，可喜可贺。 十、Windows Hello：更酷的生物识别技术 Windows Hello生物识别系统是微软力推的全新安全认证识别技术。通过Windows Hello，你可以使用人脸、虹膜以及指纹识别等方式解锁屏幕。Windows Hello不仅免去了用户记忆密码的麻烦，还进一步增强了密码的安全性。但需要注意的是，人脸识别的完成需要英特尔实感相机支持，或者采用该技术并且得到微软认证的传感器。虹膜识别和指纹识别同样需要相应的硬件设备支持。 不管怎样，在Windows Hello上，我们能看到微软的诚意和创新之心。任性的微软绝不会仅仅去借鉴同行，也绝不会唯用户行事。微软和Windows的调性，就是不断尝试，不断突破，哪怕顶着漫天口水和误解，也坚持走自己的路。 然而情怀不能当饭吃……Win 10成功与否，还得市场说话。 以下是对Windows各版本桌面操作系统历史沿革的简单梳理，资料来源于网络，进行了整理加工。 1985~1994年，微软基于MS-DOS操作系统发布了Windows早期版本，分别是Windows 1.0/2.0/2.1/3.0/3.1/3.2。 在Win 1.0发布前夕，乔布斯指责盖茨的Windows“剽窃”自苹果麦金塔操作系统，他为此曾将盖茨叫到苹果公司臭骂一顿，并直指Windows“就是一坨翔”，而盖茨则反击麦金塔也是从施乐“剽窃”来的……这两位科技大佬自此从合作者变为仇敌。 Win 3.2是Win 3.0的中文版，该版本是国内大部分先驱用户接触Windows系统的开始。 1995~2000年，Win 9x系列面世，Windows操作系统开始在大众中普及，Win 9x系列包括Windows 95/98/Me。 Win 95开启了每代Windows正式发布时都要举行盛大发布会的传统。 Win 98是最后一代基于MS-DOS开发的Windows操作系统。 Win Me在上市后遭到用户恶评。它的稳定性和Win 98比并没有多大提升，并且砍掉了实模式的MS-DOS入口，诸如此类的修改，都引得用户不满。 尽管Win 9x是微软统治操作系统市场的开始，但它的问题仍然不少。稳定性差，经常蓝屏、死机等，已经成为Win 9x的标签。在Win 98发布会上，盖茨现场演示Win 98时，电脑意外死机，微软在全球人民面前闹了笑话。 比尔·盖茨的崩溃心情可想而知 1999年，微软推出Windows 2000。 自Win 2000起，Windows个人操作系统进入基于NT核心开发的时期。基于NT核心开发的好处之一，就是减少了蓝屏、死机的概率，增强了系统稳定性。可以想见Win 98发布会后盖茨发了多大的火…… 2001年8月25日，微软正式推出Windows XP。 Win XP是基于Win 2000代码的产品，拥有一个全新的用户图形界面——月神Luna。Win XP以易用性为核心，受到用户热捧。在大多数软粉、路人和软黑看来，Win XP是微软有史以来最成功的操作系统，没有之一。 Win XP正式发布会是Windows历届发布会中最朴实、低调的，因为它撞上了“911”，这场本该规模盛大的发布会最后只能以简单的聚会形式举行。 2006~2009年，微软分别发布了Windows Vista和Windows 7。 Win Vista被认为是微软历史上最失败的操作系统，其过于超前的创意遭到用户恶评。Win Vista最大的贡献就是让用户看到了微软在发布会上的创新能力——Win Vista加拿大发布会是在一座冰屋中举行的…… Win 7是微软首个支持触控的Windows系统，它的出现多少给微软挽回了一些颜面。 2012年8月，Win 7以42.72%的占有率超越Win XP的42.52%，成为世界上占有率最高的操作系统。 2012年10月25日，微软正式发布Windows 8。 Win 8引入了一种全新的界面——“磁贴”界面。“磁贴”使得Win 8在平板和PC上的体验得以统一。 ·据悉，微软在Win 8的宣传推广上投下了15~18亿美元的重注，不过Win 8的市场反响依然十分冷淡，甚至微软内部将其视为微软的“又一个Vista”。 Win 8的失败可能直接导致了当时的Windows事业部主管、“Win 8之父”辛诺夫斯基及一批高管的出走。当然，也有人认为辛诺夫斯基出走是因为与高管们在管理方法上长期意见不合，而Win 8的失败是一根导火索。 微软在WP 8发布时宣布WP 7将退出历史舞台，无法升级到WP8，这给了微软忠实“队友”诺基亚当头一棒，刚刚上市三个月的Lumia 900遭遇了毁灭性的的打击…… 2013年10月17日，微软正式发布Windows 8.1。 Win 8.1是Win 8的升级版，它被视为微软从Win 7向Win 10过渡的承上启下的产品。 微软在WP 8.1发布时宣布将对9英寸以下预装了Windows操作系统的设备实行免收授权费，以此缩短与Android、iOS的差距。 2014年4月8日，微软取消对Win XP的所有技术支持。 微软历史上最成功的操作系统光荣退休。但国内仍有不少情怀粉坚守在Win XP的阵地上。好消息是，在Win XP退休一周年之际，腾讯电脑管家宣布联合微软成功实现XP一键升级Win10服务。这一次，XP粉们还能守住情怀吗? 2014年9月30日，Windows 10技术预览版发布。三天后，面向技术人员和IT爱好者开放下载。 2015年1月13日，微软正式终止了对Win 7的主流支持，至2020年1月14日将正式结束对Win 7的所有技术支持。此举为Win 10的首度亮相打响了前哨。 2015年1月22日，微软在其总部召开Windows 10媒体发布会。 发布会结束后，外界反响极佳。微软被黑了这么多年，终于靠Win 10实现口碑大翻身。 发布会上同时还发布了全息眼镜Hololens、巨屏设备Surface Hub等。 发布会上还展示了为手机打造的Windows 10 for Phones。没错，不是Windows Phone 10，而是Windows 10 for Phones，微软改名部开始干活了……新系统正式发布的时间待定。 2015年4月29日，在美国旧金山Build 2015开发者大会上，微软展示了Win 10 的更多内容。 2015年7月29日，Windows 10(PC版)正式发布。","tags":[{"name":"win10","slug":"win10","permalink":"http://xj8c.cc/tags/win10/"},{"name":"微软","slug":"微软","permalink":"http://xj8c.cc/tags/微软/"}]},{"title":"一大波，知乎神回复在接近了！","date":"2015-08-01T13:26:56.000Z","path":"2015/08/01/Zhihu-god-reply/","text":"整理了知乎100条机智回答， 在这些神回复里，你能深深感受到汉语文化的勃大，不对，博大精深… 问：你收到的最雷的表白语是什么？知友：程冬冬 做我女朋友行不行，行就行，不行我再想想办法。 问：“晚来天欲雪，能饮一杯无”，怎么回复比较霸气？知友：鼓鼓 司机一行酒，亲人两行泪。 问：「滚床单」有哪些优雅的叫法？知友：匿名用户 管鲍之交。 问：为什么中国人这么喜欢拍古装片？知友：magasa 科幻片面临的最大问题是，在未来时空还要不要党的领导？ 问：暧昧是什么？知友：苑小帅 暧昧=爱日未日 问：女朋友和女性朋友有什么区别？知友：James Swineson 中国人取名字有一个习惯：实际上缺什么，一定要在名字里补上，五行圆满才行。 问：一个美女在吃糖葫芦，怎么问才能让她相信我不是来搭讪而是想知道糖葫芦在哪买的？知友：屠钱钱 “美女，你好，你真漂亮，老远就看见你了，就想过来跟你打个招呼……那个，我想打听一下，你吃的糖葫芦是在哪儿买的？” 问：在武侠世界中，开一家客栈需要注意什么？知友：王叔叔 墙上贴大字：要打出去打。 问：如果给客户放 PPT 的时候突然蹦出来不雅图片，怎么办？知友：刘熹坤 沉默半响，然后问：“大伙儿还困吗？——不困咱继续。。。” 问：「拿得一手好牌还装孙子地打」这类行为是什么心态？知友：刘云暄 因为孙子就是这么打的。 “孙子曰:兵者,诡道也，故能而示之不能。” 《孙子兵法》 问：和不太熟悉的女生吃饭时（有追求她的意愿），女方提出AA制，该不该接受？知友：负二 这次我请，下次换你请。 问：2000RMB 想出国穷游可以去哪个国家？知友：匿名 秦国。鲁国。齐国。蜀国。韩国。郑国。魏国。楚国。赵国。燕国。吴国。等等。 问：怎样含蓄地表达「我已经被收买了」？知乎：Icarus鬼 我说句公道话… 问：女友跟前男友分手炮后怀孕了，我应该怎么办？知友：匿名 谁污染，谁治理。谁开发，谁保护。 问：女朋友允许我出轨，并且还介绍她闺密给我认识。在她真的很爱我的前提下，该如何理解她的行为？知友：ScottDong 千万不要上当！！！Mac告诉你，我也可以装windows哦，但你真的装了，会用高发热来报复你的！ 问：情人节没情人怎么办？知友：Ruah 家里没死人的难道还得在清明节前费劲弄死一个两个的么？ 没有就不过。 问：为什么有人说「女人永远是对的」？知友：Raymond Wang 这句话反映了很多男性蛮不讲理地认为很多女性蛮不讲理。 问：如何挑逗男朋友？知友：匿名 “老公，我困了”“恩，你先睡吧”“那得亲一下！”“好，亲一下，睡吧。”“老公抱抱！”“好，抱抱，快睡吧。”“老公，你拍我！”“好，老公拍你睡。”“老公，你给我讲故事！”“…草你个妈的。来，来，来 别睡了，起来，来，把屁股撅起来！我给你讲讲老汉推车的故事！” 问：为什么自从快播消失之后，2014年七月开始，越来越多的针对少女的刑事案件频繁发生？知友：大蓝小蓝 1978年，我出生了，中国为庆祝我出生而改革开放。2008年，我结婚了，中国为庆祝此事还举办了奥运会。 问：你是从哪个细节发现女朋友出轨的？知友：海上马超 那天回家她一抖被子说给我表演一个大变活人。 问：为什么女生有「体香」，而男人没有？知友：green grass 化妆品腌入味了→_→ 问：什么叫暖男？知友：匿名用户 云备胎。 问：同龄人中不少人结婚生子了，对你有什么影响吗？知友：匿名用户 对我没啥影响，对我妈影响比较大。 问：男性更看重女人的身材、脸蛋还是思想？知友：匿名用户 脸蛋和身材决定了我是否想去了解她的思想。思想决定了我是否会一票否决掉她的脸蛋和身材。 问：「谁，执我之手，敛我半世癫狂」是什么意思？知友：本拉拉 我有病，谁有药！ 问：什么东西女人觉得很好看，男人却并不认同？知友：frank 其他男人。 问：你见过的知乎最萌/最有创意/最有哲理意味的自我（一句话）介绍？知友：田七 三种单纯然而极其强烈的激情支配着我的一生。那就是对于操逼的渴望，对于装逼的追求以及对于傻逼痛彻肺腑的怜悯。 问：怎么看待女朋友的蓝颜？知友：匿名用户 蓝颜蓝颜，加点黄色就绿了。 问：如何优雅地表达愤怒？知友：ALPee 用中指推眼镜。 问：如何吐槽一部电影很烂？知友：李亚京 影厅座位有17排，每排32个座位，天花板上共有48盏灯，荧幕的左下角有个黑点总是出现，频率大概是1分20秒一次。 问：怎么回击「你家里没老人吗？你没有孩子吗？」之类的道德绑架 ？知友：丁健男 我爷我奶有文化，公交车上不掐架，我弟我妹家教好，不熊不作不瞎闹，我爸人多不抽烟，我妈坐车不大叫，您家全家素质高。 问：哪些定律让你印象深刻并认为有指导意义？知友：田七 神马都看脸定律。 问：分手100天了，还没有走出来怎么办？知友：韩重赞 替换文件永远比删除文件更彻底。 问：为什么找男朋友那么难？知友：camen 没有一见钟情的资本，又缺少日久生情的条件。 问：IT大牛是怎样炼成的？知友：justjavac 记得初入公司时，写的代码乱七八糟，错误百出，bug连连，不仅项目经理骂我，其他同事也对我怨声载道。后来听朋友介绍，就报了一个培训班。经过1个月的刻苦学习，终于功夫不负有心人啊—他们都骂不过我了。 问：如何回应「人的眼睛有 5.76 亿像素，却终究看不懂人心」？知友：Kenneth 你有100亿个脑细胞，却尽想些没营养的问题。 问：初恋是不是用来练手的？知友：wsivoky 放屁。单身才是用来练手的。 问：女朋友有什么用处？知友：安雅 让你四处躁动的心、鸡鸡和不知道怎么花的钱有个温暖着落。 问：男生如何回答女生「你为什么对我这么好」比较靠谱？知友：Vvan 我敬你是条汉子。 问：史上最奇葩的广告语是哪句？知友：王大圣 垃圾分类，从我做起。 问：妹子还书的时候夹了一张面巾纸，是什么意思？知友：Zzzwizard 说明你对人家有意思。 问：如何提高女朋友的智商？知友：赵月 她不喜欢你的时候，智商自然就高起来了。 问：为什么很多女生都觉得会做菜的男生很有魅力？知友：邹明宇 有个蛋蛋魅力！！你认为她们会觉着一个黑胖子光着膀子满头大汗地炒面很有魅力么？她们只是觉得帅哥身穿一尘不染的厨师服面带微笑地做甜点牛排很有魅力。 问：为什么和女朋友在一起总是想和她做爱，所有男生都这样吗？还是心理变态？知友：Luxenius 孩子，你的这种冲动是人类生生不息的源头，你GF的矜持是人类文明的基石。 问：为什么别人有人追而你没有？知友：应宝宝 那你扪心自问，如果把她们的男朋友给你，你要么？ 问：遇到女孩求六元回家路费这种情况，怎么做才好？知友：朱嘟嘟嘟嘟 “出门带粉笔的人，通常运气都不会太好。” 问：南方人和北方人打 DotA 有什么差异吗？知友：王超 一到冬天，南方水平集体下降。 问：历史上有哪些有名的「洗脑名句」？知友：反裤衩阵地 对于所有中国人来说，有一个四字魔咒是永远绕不开的。只要有人对你说出这四个字，你就能中邪般地买票去最坑爹的景点、玩命爬上最艰险的山峰、吃下最难吃的餐馆饭菜 这四个字就是： 来都来了。 问：女朋友发短信说「我想你了」，应该怎么回短信才好？知友：木匠Bryan 死脑筋啊。她发短信你就回短信？回电话啊！ 问：有哪些关于足球的名言？知友：sharnodo 留给中国队的时间不多了。 问：女人的温柔从哪里体现？知友：郭妮娜 吵架出门，顺便买个菜回来。 问：丫头吃鸭头，鸭头咸丫头嫌知友：猫责冬 基友抹机油，机油稠基友愁。 问：有些男生喜欢贫乳女生的原因有哪些？知友：vczh 可以亲手带大。 问：历史上最著名的秀恩爱事件？知友：鬼木知 烽火戏诸侯。 问：女朋友说XX好帅的时候怎么往下接话茬？知友：匿名 那又怎样，女朋友又没我的漂亮。 问：为什么在洗完澡洗完头之后，一些人会觉得自己变帅/变漂亮很多？知友： millll 因为脑子进水了。 问：你在旅途中曾遇到过哪些厉害的人或事？知友： 一味 我妈，她哪也不让我去。 问：健身会导致停经吗？知友：yong cao 要看你和教练的关系… 问：拆迁的「拆」为什么要用圈圈住？知友：匿名 我是拆迁队的，其实没啥讲究，纯粹顺手。心情好，我也可以画成心形的。 问：性对男人来说到底有多重要？知友：欲三更 我就不说漂亮话了—别来这套，三十年河东三十年河西，谁都有吃不饱的时候，等你到了如狼似虎，坐地吸土的年纪，再来说男人馋的事儿。 问：什么事情让你崩溃过？知友：国栋 和女朋友讲道理。 问：如果母鸡有思想，它会想些什么？知友：雷幺幺 我母鸡啊！ 问：如何优雅地提出滚床单？知友：zodiac207 有一个将近三亿的项目需要你帮忙配合一下。 问：妹子送了本书，在扉页上写了一段俄文，是什么意思？知友：林井南 明知对方看不懂还要给的东西就是表白。 问：有个很聪明的女朋友是怎样的体验？知友：诸葛不亮 拿朋友的手机给我女朋友打电话，一接通我还没开口她就知道叫亲爱的。 问：有什么赞扬让你比较尴尬？知友：誓死追随苏子敬 哎呀，这位小伙子，人不可貌相啊。 问：为什么图书馆不能穿拖鞋？知友：ace zh 以防翻书舔手指的和看书抠脚丫的打起来。 问：在古代神话中，为什么柳树槐树这种植物可以成精，而水果蔬菜就不能成精？知友：蒲星伟 上午发愿修炼，中午就给炖了… 问：为什么深海里的鱼都长得那么特别？知友：徐生活 深海里黑漆漆的，谁也看不见谁，大家就随便长长了… 问：让我感谢你，赠我空欢喜，如何翻译成英文？知友：王泽亚 fuck you。 问：气宇轩昂的男士到菜市场买菜如何避免被要高价？知友：戈重日 没用的，这是器宇轩昂税。 问：谈恋爱是一件浪费时间的事情吗？知友：mu peng 我谈恋爱那会，每天笑着睡着，笑着睡醒，一个人走路，也是满脸笑意，和别人聊天，聊着聊着也能扯到我女朋友那里，一群光棍默默无语的看着我眉飞色舞，现在想来也是太不体贴。时间算什么？命都给她了，浪费就浪费吧：） 问：约妹子看电影时对影片的选择有分歧，该怎么办？知友：Emileo 居然有分歧，看来你确实想看电影… 问：吵架时女朋友不让你和她说话，也不让你碰她时，怎么做比较好？知友：匿名 拿一个杯子狠狠摔到地上，看看能不能镇住她，要是镇住了，完事，要是没镇住，顺势往那玻璃渣子上一跪，完事。 问：孩子问「为什么我做错事大人可以打我，大人错了我不能打他们」时应该怎么回答？知友：匿名 因为打不过，等你打得过了，大人就会跟你开始讲道理了。 问：与律师谈恋爱是什么感受？知友：匿名 别离婚，你连内裤都分不到。 问：为什么不能和前男友联系？知友：teenieweenie 感情世界里最没用的四种东西：分手后的悔恨，不爱后的关怀，高高在上的自尊心，低情商的善良。 问：是否应该取消中小学强制性文言文学习？知友：冯昱尧 数学你们觉得实用性有限，平时谁会没事解个方程组，买菜用不上，不学；英语你们觉得实用性有限，平时谁和外国人说话，看美剧都有字幕组，买菜用不上，不学；物理你们觉得实用性有限，平时谁没事那几个小滑块摆来摆去，买菜用不上，不学；化学你们觉得实用性有限，平时谁鼓捣硫酸铜，买菜用不上不学；文言文你们觉得实用性有限，平时谁闲的蛋疼看古文，买菜用不上，不学；那你告诉我义务教育学什么？学买菜吗？ 问：为什么女生在被表白、被求婚的时候总是会捂嘴？知友：mu peng 这样别人才看不出自己说的是OMG，还是WTF。注：WTF是 what the fuck，意为：他妈的什么玩意。 问：为什么中国极少发动对外侵略战争？知友：沈野熊 从最初的黄河流域一小片到现在一个大公鸡难道是充话费送的？ 问：有一个女儿是什么体验？知友：梅源贝 “宝贝， 我愿意把这世界上的一切都给你”“我想吃雪糕～”“不行！” 问：女孩子出了林微因的上句：是爱，是暖，是希望，你是人间的四月天。如何对下句？知友：起司尼 是他，是他，就是他，少年英雄小哪吒。 问：室友打飞机被我看见怎么办？知友：李谦 我可以假装看不见，也可以偷偷地想念。 问：Google Glass的启动命令：OK，Glass，中文翻译为什么最合适？知友：HolyPerry 好的，镜哥哥。 问：为什么女人一边骂男人不是好东西、都是色鬼，一边还是很喜欢男人？知友：走嗅 真心想买的人都是挑三拣四的主，一直夸好的那是托儿。 问：哪件事，让你对自己的无知感到震惊？知友：匿名 小的时候写作文要写笔名，我写的一直是“中华绘图铅笔”。 问：女朋友和自己交往的时候和别的男生去旅行，开一间房是什么心理？知友：理想的蘑菇 你以为绿茶婊的最大特点是婊，你错了，其实是绿。 问：男生问你喜欢我哪一点时该怎么回答？知友：腐生 直接下手点过去啊，能占不少便宜，“我喜欢你…这一点，这一点，这一点，还有这一点，还有这一点…” 问：为什么越靠北方地区的人性格越直接、彪悍？知友：刘洋 天寒地冻的，哪有时间和你磨叽。 问：如果恋爱不牵手，不接吻，不上床，就不是恋爱，爱一个人的表现真的要这些身体接触吗？知友：苏莉安 当然了，不然你觉得为啥“爱情”和“受精”长那么像。 问：男朋友假期一两个月不主动联系我，如何调教？知友：于百威 大家回答得都太阴暗，什么劈腿变心从来没爱过你之类的，凡事要往好的方面想。我猜你男朋友应该是死了。 问：向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？知友：邵鸽 也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。 问：林志颖的唱功怎么样？知友：Hugo LEE 我写了一大段，比如圆润，美声，自然等溢美之词，然后发现你说的不是林志炫，于是默默地删了。 问：你做过最坑爹的事情是什么？知友：bia gao 小时候总要和我妈睡。 问：分手是一种怎样的体验？知友：韩知行 老师只能否定你的成绩，老板只能否定你的工作。但是她呢，把你整个人都否定了。你的勤劳勇敢高大帅气，你的博古通今风趣幽默，对她都不构成意义；你小心翼翼的示好，精心准备的礼物，背地里琢磨了好久的冷笑话，都并没有什么卵用；你把自己的好用心雕琢反复修饰，包装华美双手奉上；她低头看了看，耸耸肩，好像不是我想要的呢。打败一个人有时候就是这么简单。 问：体现情商低的言行有哪些？知友：st寻光 “你老踢我干嘛？” 问：哪一个字可以表示快速、精确的含义？知友：匿名 biu 问：女朋友是脑残怎么办？知友：丁一 按照相关法规规定，明知妇女是精神患者或痴呆者（程度严重的），而与其发生性行为的，不管采取什么手段都应以强奸罪论处。 问：你见过最美好的男生是什么样的?知友：最近比较烦 身高170-185cm，体重56-75kg，身材匀称，性格温和，笑起来阳光，普通话标准，发型清爽，偶尔喝酒，不抽烟，不爱泡吧。会煮饭，有情调，会制造小浪漫，有耐心，有孝心，有爱心，有责任心，有上进心，举止斯文，不说脏话，谦虚，谨慎，稳重，大方。不约炮，不善于和女生说话，但对待爱情忠诚不二，有担当。这样的男孩子基本上都是做备胎的。","tags":[{"name":"知乎","slug":"知乎","permalink":"http://xj8c.cc/tags/知乎/"}]},{"title":"必须知道的 Visual Studio 快捷键","date":"2015-07-27T12:21:47.000Z","path":"2015/07/27/vs-shortcuts/","text":"本文将为大家列出在Visual Studio中常用的快捷键，正确熟练地使用快捷键，将大大提高你的编程工作效率。 项目相关的快捷键Ctrl + Shift + B = 生成项目Ctrl + Alt + L = 显示Solution Explorer（解决方案资源管理器）Shift + Alt+ C = 添加新类Shift + Alt + A = 添加新项目到项目 编辑相关的键盘快捷键Ctrl + Enter = 在当前行插入空行Ctrl + Shift + Enter = 在当前行下方插入空行Ctrl +空格键 = 使用IntelliSense（智能感知）自动完成Alt + Shift +箭头键(←,↑,↓,→) = 选择代码的自定义部分Ctrl + } = 匹配大括号、括号Ctrl + Shift +} = 在匹配的括号、括号内选择文本Ctrl + Shift + S = 保存所有文件和项目Ctrl + K，Ctrl + C = 注释选定行Ctrl + K，Ctrl + U = 取消选定行的注释Ctrl + K，Ctrl + D = 正确对齐所有代码Shift + End = 从头到尾选择整行Shift + Home = 从尾到头选择整行Ctrl + Delete = 删除光标右侧的所有字导航相关的键盘快捷键Ctrl +Up/Down = 滚动窗口但不移动光标Ctrl + - = 让光标移动到它先前的位置Ctrl ++ = 让光标移动到下一个位置F12 = 转到定义调试相关的键盘快捷键Ctrl + Alt + P = 附加到进程F10 = 调试单步执行F5 = 开始调试Shift + F5 = 停止调试Ctrl + Alt + Q = 添加快捷匹配F9 = 设置或删除断点搜索相关的键盘快捷键Ctrl + K Ctrl + K = 将当前行添加书签Ctrl + K Ctrl + N = 导航至下一个书签Ctrl + . = 如果你键入一个类名如Collection，且命名空间导入不正确的话，那么这个快捷方式组合将自动插入导入Ctrl + Shift + F = 在文件中查找Shift + F12 = 查找所有引用Ctrl + F = 显示查找对话框Ctrl + H = 显示替换对话框Ctrl + G = 跳转到行号或行Ctrl + Shift + F = 查找所选条目在整个解决方案中的引用以上就是Visual Studio的全部快捷键，如果有遗漏，欢迎补充分享。","tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://xj8c.cc/tags/Visual-Studio/"}]},{"title":"Asp.net知识点总结(五)","date":"2015-07-16T11:47:48.000Z","path":"2015/07/16/asp.net-knowledge-point-summary-5/","text":"ASP.NET高级配置Cache缓存机制缓存的参数：第一个为缓存的主键；第二个人为缓存的值；第三个为缓存的依赖项；第四个为缓存移除的时间；第五个为缓存时间的间隔 设置一般缓存1//this.Cache.Insert(“w”, DateTime.Now.ToLongTimeString(), null, DateTime.Now.AddSeconds(10), TimeSpan.Zero); 设置滑动缓存1//this.Cache.Insert(“w”,DateTime.Now.ToLocalTime(),null,DateTime.MaxValue,new TimeSpan(0,0,5)); 缓存依赖为文件1//this.Cache.Insert(“w”, DateTime.Now.ToLocalTime(), new CacheDependency(Server.MapPath(“a.html”))); 缓存数据库1// this.Cache.Insert(“w”,DateTime.Now.ToLocalTime(),new SqlCacheDependency(“web.config文件中的配置数据库连接名”,”数据库缓存表名的名字”)); 配置缓存数据库数据库缓存依赖S服务器名称 -E集成身份验证 -ed启动 -d数据库名称 -et指定缓冲依赖的表名 -t表名** 在vs2010的命令提示符中运行（切换到aspnet_regsql.exe所在的目录） 1aspnet_regsql -S . -E -ed -d HKCorpData -et -t HKSJ_USERS 缓存依赖禁用该数据库1aspnet_regsql -S . -E -dd -d HKCorpData web.config配置文件如下：connectionString为连接字符串的名称 1234567/* &lt;caching&gt;&lt;sqlCacheDependency enabled=”true”&gt;&lt;databases&gt;&lt;add name=”数据库名” connectionStringName=”connectionString” pollTime=”500”/&gt;&lt;/databases&gt;&lt;/sqlCacheDependency&gt;&lt;/caching&gt;*/ session使用1/*stateServer数据必须是能可序列化的数据*/ 1.进程内使用123session[”key”]=”value”;object obj=session[”key”]; 2.进程外使用配置web.config文件：1&lt;sessionState mode=”StateServer” stateConnectionString=”tcpip=localhost:42424”&gt;&lt;/sessionState&gt; 如果是远程的stateserver配置注册表命令：cmd → regedit.exeHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\aspnet_state\\Parameters\\AllowRemoteConnection 3.数据库服务器上使用1aspnet_regsql.exe -S 127.0.0.1 -U sa -P 123 -ssadd -sstype c -d SessionTest 1&lt;sessionState mode=”SQLServer” allowCustomSqlDatabase=”true” sqlConnectionString=”Data Source=.;Initial Catalog=SessionTest;uid=sa;pwd=123”&gt;&lt;/sessionState&gt; 全局文件的使用全局文件介绍：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//网站在iis上开启使用运行的方法，并对变量进行初始化protected void Application_Start(object sender, EventArgs e)&#123;//这里的变量为全局变量，也就是静态变量，可以被整个网站共用例：Application[”isbackground”] = “bluk”;//需要使用的这个颜色的时候可以直接调用Application[”isbackground”]//或者网站访问量Application[”number”] = 0;&#125;//当用户访问网站的时候执行此方法protected void Session_Start(object sender, EventArgs e)&#123;//在这里可以验证用户是否登入或者在线统计lock (Session[”Id”]) &#123;//在线人数统计Session[”Id”] = (int)Session[”Id”] + 1;//访问次数统计Application[”number”] = (int)Application[”number”] + 1; &#125;&#125;//浏览器请求iis服务器到达管道中的第一个事件，在管道中触发protected void Application_BeginRequest(object sender, EventArgs e)&#123;//在这里可以对用户请求过滤例如：防盗链设置if (Request.RawUrl.Contains(“images/”))&#123;if (Request.UrlReferrer == null || !IsSameDomain(Request.UrlReferrer, Request.Url)) &#123;Response.ContentType = “image/jpeg”;string path = Request.MapPath(“~/daolian.jpg”);Response.WriteFile(path);//结束请求Response.End(); &#125;&#125;&#125;//判断两个域名是否相等public bool IsSameDomain(Uri u1, Uri u2)&#123;return Uri.Compare(u1, u2, UriComponents.HostAndPort, UriFormat.SafeUnescaped, StringComparison.CurrentCultureIgnoreCase) == 0 ? true : false;&#125;//管道中的第二个事件，验证请求，开始检查用户的身份protected void Application_AuthenticateRequest(object sender, EventArgs e)&#123;//一般用来获取用户信息//获取用户的访问证书HttpClientCertificate hr = new HttpClientCertificate();hr= Context.Request.ClientCertificate;//获取用户的访问地址string str= Request.UserHostAddress;&#125;//网站出错时运行此方法protected void Application_Error(object sender, EventArgs e)&#123;//可以将访问的地址更改为其他不出错的地址页面上去Response.Redirect(Server.MapPath(“a.html”));&#125;//当用户下线或者不在访问该网站时执行此方法protected void Session_End(object sender, EventArgs e)&#123;lock (Session[”Id”]) &#123;if ((int)Session[”Id”] &gt; 0) &#123;Session[”Id”] = (int)Session[”Id”] - 1; &#125; &#125;&#125;//网站停止或者重启时运行此方法protected void Application_End(object sender, EventArgs e)&#123;//可以保存当前网站的一些信息到文件中//将网站的访问量包存到文件中File.WriteAllText(“log.txt”, Application[”number”].ToString());&#125; 同时管道中的事件也可以在这里注册，下面是请求管道中的已经公开的19个事件：(1)BeginRequest: 开始处理请求(2)AuthenticateRequest授权验证请求，获取用户授权信息(3):PostAuthenticateRequest获取成功(4): AunthorizeRequest授权，一般来检查用户是否获得权限(5):PostAuthorizeRequest:获得授权(6):ResolveRequestCache:获取页面缓存结果(7):PostResolveRequestCache已获取缓存 当前请求映射到MvcHandler（pr）： 创建控制器工厂 ，创建控制器，调用action执行，view→responseaction Handler : PR()(8):PostMapRequestHandler创建页面对象:创建 最终处理当前http请求的Handler 实例： 第一从HttpContext中获取当前的PR Handler ，Create(9):PostAcquireRequestState获取Session(10)PostAcquireRequestState获得Session(11)PreRequestHandlerExecute:准备执行页面对象执行页面对象的ProcessRequest方法 (12)PostRequestHandlerExecute执行完页面对象了(13)ReleaseRequestState释放请求状态(14)PostReleaseRequestState已释放请求状态(15)UpdateRequestCache更新缓存(16)PostUpdateRequestCache已更新缓存(17)LogRequest日志记录(18)PostLogRequest已完成日志(19)EndRequest完成、IHttpModule接口的使用：此接口中有两个方法Dispose和Init，在Init中也可以注册管道中的19事件 配置web.config文件：在system.web节点下配置12345678910111213141516171819202122232425262728&lt;httpModules&gt;&lt;add name=”文件名称” type=”类的全名称”/&gt;&lt;!--&lt;add name=”MyHttpModuleDemo” type=”CZBK.WebSite.Web.HttpModule.MyHttpModuleDemo”/&gt;--&gt;&lt;/httpModules&gt;//对象释放式执行public void Dispose()&#123;&#125;/// &lt;summary&gt;/// 初始化时执行，可以对管道中的公开的事件进行注册/// &lt;/summary&gt;/// &lt;param name=”context”&gt;上下文对像&lt;/param&gt;public void Init(HttpApplication context)&#123;//例：注册管道中的第一事件//注册开始处理请求事件context.BeginRequest += new EventHandler(context_BeginRequest);&#125;/// &lt;summary&gt;///注册管道中的第一个事件的方法/// &lt;/summary&gt;/// &lt;param name=”sender”&gt;请求信息&lt;/param&gt;/// &lt;param name=”e”&gt;与事件有关的基类对象&lt;/param&gt;private void context_BeginRequest(object sender, EventArgs e)&#123;//将sender中的信息转化为应用程序的基类对像HttpApplication application = sender as HttpApplication;application.Context.Response.Write(“我是在继承了IHttpModle的类中注册的管道中的事件”);&#125; 错误页配置：在web.config文件中的system.web配置：123&lt;customErrors mode=”错误页配置模式：On开启, Off关闭，RemoteOnly远程开启 “ defaultRedirect=”默认错误发生时跳转的页面”&gt;&lt;error statusCode=”http状态错误代码” redirect=”指定跳转的页面”/&gt;&lt;/customErrors&gt; 例：1234&lt;customErrors mode=”RemoteOnly” defaultRedirect=”myErrorpage.aspx”&gt;&lt;error statusCode=”404” redirect=”error.html”/&gt;&lt;error statusCode=”403” redirect=”error.html”/&gt;&lt;/customErrors&gt; url重写原理123456789101112131415void Application_BeginRequest(object sender, EventArgs e) &#123;//url重写HttpApplication app = sender as HttpApplication;string url = app.Request.RawUrl;/根据请求的地址解析出实际地址来Regex r = new Regex(“/(\\\\d+)/details\\\\.htm&quot;,RegexOptions.IgnoreCase);Match m = r.Match(url);if (m.Success) &#123;string id = m.Groups[1].Value;app.Context.RewritePath(“~/PhotoDetails.aspx?id=” + id); &#125; &#125; urlRewriter1、在节点加入12&lt;section name=”RewriterConfig”type=”URLRewriter.Config.RewriterConfigSerializerSectionHandler, URLRewriter” /&gt; 2、在之后加入123456789&lt;RewriterConfig&gt;&lt;Rules&gt;&lt;RewriterRule&gt;&lt;LookFor&gt;~/(\\d&#123;4&#125;)/(\\d&#123;2&#125;)/Default\\.aspx&lt;/LookFor&gt;&lt;SendTo&gt;~/Default.aspx?ID=$1&lt;/SendTo&gt;&lt;/RewriterRule&gt;&lt;/Rules&gt;&lt;/RewriterConfig&gt; 3、中加入12&lt;add verb=”*” path=”*.aspx” type=”URLRewriter.RewriterFactoryHandler, URLRewriter” /&gt; 数据绑定：1.&lt;%#Eval()%&gt;Eval单向绑定,只是计算表达式的值输出2.&lt;%: %&gt;将绑定的数据进行格式化后再显示在页面上3.&lt;%= %&gt;将绑定的数据直接输出来不做什么处理4.&lt;%#Bind()%&gt;双向绑定,不仅可以计算表达式的值输出，还可以将用户填入的值更新到数据中5.第二种方法的方法重载:12&lt;a href=’&lt;%# Eval(“userId”,”Default.aspx?id=&#123;0&#125;”)%&gt;’&gt;&lt;%# Eval(“userName”) %&gt;&lt;/a&gt; 6.eval同时绑定两个值12&lt;a href=’&lt;%# string.Format(“Default.aspx?id=&#123;0&#125;&amp;role=&#123;1&#125;”, Eval(“userId”),Eval(“userRole”))%&gt;’&gt;&lt;%# Eval(“userName”) %&gt;&lt;/a&gt; 注意%和后面的#不能有空格或其他发符号 WebRequest类使用:12345678910PageUrl = “http://xj8c.cc “; //需要获取源代码的网页WebRequest request = WebRequest.Create(PageUrl); //WebRequest.Create方法，返回WebRequest的子类HttpWebRequestWebResponse response = request.GetResponse(); //WebRequest.GetResponse方法，返回对Internet请求的响应Stream resStream = response.GetResponseStream(); //WebResponse.GetResponseStream方法，从Internet资源返回数据流。Encoding enc = Encoding.GetEncoding(“GB2312”); // 如果是乱码就改成utf-8 / GB2312StreamReader sr = new StreamReader(resStream, enc); //命名空间:System.IO。 StreamReader类实现一个TextReader (TextReader类，表示可读取连续字符系列的读取器)，使其以一种特定的编码从字节流中读取字符。ContentHtml.Text = sr.ReadToEnd(); //输出(HTML代码)，ContentHtml为Multiline模式的TextBox控件resStream.Close();sr.Close();","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"技术教程","slug":"技术教程","permalink":"http://xj8c.cc/tags/技术教程/"}]},{"title":"你必须知道的十个编程语言","date":"2015-07-13T13:44:57.000Z","path":"2015/07/13/ten-programming-languages/","text":"如果你刚接触编程，有可能不太知道这些语言，但如果你花些功夫来了解它们，然后选择一种或多种语言来认真学习，那么你今后肯定能在IT领域找到一份高薪的工作~今天在这里提到的10个最受欢迎的编程语言，希望能对你的学习规划有些帮助。 JavaJava 被认为是最最适合开发者和程序员学习的。它是被使用最多的编程语言，并且在Android OS开发语言中再一次夺魁（尽管近些年份额逐步下降）。Java非常适合运用于移动设备平台、企业层用途、制作电脑应用程序，还有开发制作基于安卓平台的智能手机和平板电脑的App应用程序。PHP互联网开发者非常应该学习PHP，PHP是一个非常有名的编程语言。借助PHP的帮助，你可以很轻松的扩展一个web app。其实PHP是很多强大CMS（内容管理系统）的基石，比如说美国著名的微博和博客网站WordPress的CMS。PHP的确称得上对开发者和程序员非常有价值的编程语言。 JavaScript当你准备扩展你的网页的时候，JavaScript 定会极大地帮助你。你可以利用JavaScript中各种各样的样式框架做出极好体验的UI（用户操作界面）。掌握JavaScript才可以制作出效果优异的交互式网页。JavaScript被大量应用在网页动画、图片读取标志、页面脚本，还有制作交互UI。PythonPython 可谓是一个多功能多用途的编程语言。学了Python，你将有能力拓展到网页应用，数据分析，UI设计等等。相比之下较大规模的公司才会运用Python来帮助他们分析评估大数据。所以学习Python工程师可谓是前程似锦。Objective-C如果你对iOS开发有着浓厚的兴趣，我建议你还是开始学习Objective-C，并且你要足够了解它才能开始你的iOS App研发之路。除此之外，Objective-C语言还是最受网页工程师欢迎的语言之一。如果你已经熟练掌握了Objective-C，你就可以使用Xcode以较快的速度来开发你所向往的iOS App咯！Ruby还有一个很受欢迎的编程语言名叫Ruby，还有它的应用框架 Ruby on Rails。Ruby非常易学，而且它非常强大、简洁。如果你手里的时间并不充裕，但是你对编程很感兴趣或者总是想制作些什么， Ruby一定是你最佳选择。Ruby被大量应用在众多的网页编程中，因此它也被刚起步的互联网公司视为一个不错的选择。PerlPerl 也是一个被很多人所熟知的编程语言，它提为系统程序设计提供了一些特殊的工具。尽管Perl在用起来的时候容易让人迷惑，但它的的确确非常强大。Perl现阶段非常适合学习，学习它会刷新你对这个领域的认知。Perl 主要被运用在网页制作、网页应用上、计算机应用和系统管理、数据库自动化测试等领域。C, C++ 和 CC语言是一个很独特的编程语言。即便C语言是计算机语言里中年岁最长的，我觉得你还是应该先从计算机语言中的元老C语言开始学起。为什么？这还用说，因为市面上大多数不同的软件都是利用它编写出来的。C++在C语言的基础上有一些进步，C++被大量运用在加速游戏速度上。对于性能强大的计算机应用或者移动端应用，C++是一个理想的选择。C++是目前为止最强大的编程语言，一些至关重要的操作系统都采用C++，比如我们最熟知的微软的windows系统就是基于C++开发的。在了解C语言和C++之后，我们可以进一步的了解一下C#语言了。如果你掌握C语言和C++的话，学习使用C#并不会很难。C#实际上是微软的应用程序和服务端的主要语言。如果你需要执行运用.Net 和ASP，你必须要熟练掌握C#语言。SQL当你需要在类似于微软的 SQL server, 甲骨文的 MySQL, etc.数据库执行命令，你应该学习SQL（结构化查询语言）编程语言。通过SQL，你可以精通在巨大的多层数据库中获取你所需的目标数据。SwiftSwift 可以说是当下最时髦的编程语言了。最近几年，随着苹果产品在全球的扩张，基于iOS平台和MacOS的App应用开发也是如火如荼的发展。2014年苹果公司推出了Swift语言，它的优点是简单和快捷，如果你继续开发iOS，你真的应该好好了解一下Swift编程成语言。","tags":[{"name":"编程","slug":"编程","permalink":"http://xj8c.cc/tags/编程/"}]},{"title":"Asp.net知识点总结(四)","date":"2015-07-11T14:32:58.000Z","path":"2015/07/11/asp.net-knowledge-point-summary-4/","text":"ASP.Net服务器端控件(部分)Repeater1. Repeater控件使用数据源返回的一组记录呈现只读列表。与FormView控件类似，Repeater控件不指定内置布局。您可以使用模板创建Repeater控件的布局。2. Repeater相当于一个foreach循环.3. 特征：自由定制；分页功能需要手写。 4.Repeatera) 头部模版,通常用来做表格头部信息的展示。b) 项模版 通常用来做数据的绑定用c) 交替模版 通常用来做各行变色,和项模版搭配使用. 5. 数据的绑定a) 数据的绑定通常和数据源做搭配来绑定数据(数据源会在后面文档最后做介绍)b) 数据绑定的方式有两种: 121&gt; Eval方式： &lt;td&gt;&lt;%# Eval(“ID”) %&gt;&lt;/td&gt;2&gt; Bind方式: &lt;asp:TextBox ID=”IDTextBox” runat=”server” Text=’&lt;%# Bind(“ID”) %&gt;’ /&gt; c) 内部服务器控件的事件的触发规则: 1&gt; 在服务器端的数据控件中如果包含了其他的服务器控件,那么其他的服务器控件的事件只能通过数据控件(Repeater)的ItemCommand事件来出发,在额外的服务器控件中需要给定CommandName和CommandArgument以方便后台在ItemCommand事件中处理此事件;2&gt; 前台代码示例： 3&gt; 后台代码示例： ListView1. 这个控件既可实现像GridView一样的效果，也可实现像DataList一样的效果（怪不得名字叫ListView），这东西应用起来也要复杂些。要点是：LayoutTemplate下面必须有一个服务器端控件，即runat=”server”，其ID必须为itemPlaceholder（除非更改ListView的ItemPlaceholderID），注意大小写，ItemTemplate模板中的内容输出时就是插入到itemPlaceholder的。2. 但ListView分页却不是那么复杂，在LayoutTemplate模板中拖入一个DataPager控件，指定好DataPager的Fields就可以了。但DataPager并不会向DataSource发送startRowIndex和maximumRows这两个参数，也就是说这种分页是取出所有的记录，只是显示部分，并不是一种高效的分页。。3. 特征：自由定制，功能强大；应用复杂；分页功能需要手写。4. 模版包括:a) AlternatingItemTemplate: 交替模版: 交替模版 通常用来做各行变色,和项模版搭配使用.b) EditItemTemplate: 编辑模版,通常用来做行的数据编辑:可以在里面放入其他服务器控件: 按钮、 A标签等、c) EmptyDataTemplate空模版: 顾名思义,空模版服务器返回数据为空的时候显示的: 也可以在里面自定义其他的空页面d) InsertItemTemplate添加模版: 用来做添加数据用的,和普通的添加数据页面一样,只不过数据的绑定方式使用了Bind(“UserName”) %>’)``` 双向数据绑定类型.12345678910111213141516171819202122232425262728e) ItemTemplate: 数据项目模版,用来绑定数据:绑定方式和Repeater一样也分两种: Eval() 和 Bind();f) LayoutTempalate布局模版:### 1&gt; 使用LayoutTemplate属性可以为ListView控件的根容器定义自定义用户界面 (UI)。### 2&gt; 若要指定布局模板，请在ListView控件内添加一个LayoutTemplate元素。 然后可以将模板的内容添加到LayoutTemplate元素。 ### 3&gt; LayoutTemplate内容必须包含一个占位符控件，例如由ItemTemplate模板定义的项或由 ### 4&gt; GroupTemplate模板定义的组的表行 (tr) 元素。 占位符控件必须将runat特性设置为“server”，### 5&gt; 将ID特性设置为ItemPlaceholderID或GroupPlaceholderID属性的值（具体取决于ListView控件是否使用组）。 ### 6&gt; LayoutTemplate模板不是ListView控件所必需的。 您可以使用不带LayoutTemplate的ListView ### 7&gt; 控件，也可以使用没有占位符服务器控件但具有已知ID的控件。g) SelectedItemTemplate选择模版:指定当前选中的内容,可在里面添加按钮a标签或者一个复选框,以实现选择的效果### 5、数据源控件之ObjectDataSource# ObjectDataSource的概述### ObjectDataSource控件对象模型类似于SqlDataSource控件。ObjectDataSource公开一个TypeName属性（而不是ConnectionString属性），该属性指定要实例化来执行数据操作的对象类型（类名）。类似于SqlDataSource的命令属性，ObjectDataSource控件支持诸如SelectMethod、UpdateMethod、InsertMethod和DeleteMethod的属性，用于指定要调用来执行这些数据操作的关联类型的方法。本节介绍一些方法，用于构建数据访问层和业务逻辑层组件并通过ObjectDataSource控件公开这些组件。 下面是该控件的声明方式：# &lt;asp:ObjectDataSource```CacheDuration=”string|Infinite” CacheExpirationPolicy=”Absolute|Sliding” CacheKeyDependency=”string”123456789101112131415161718192021222324ConflictDetection=”OverwriteChanges|CompareAllValues” ConvertNullToDBNull=”True|False” DataObjectTypeName=”string” DeleteMethod=”string” EnableCaching=”True|False” EnablePaging=”True|False” EnableTheming=”True|False” EnableViewState=”True|False” FilterExpression=\\’#\\’” &gt; ID=”string” InsertMethod=”string”MaximumRowsParameterName=”string”OldValuesParameterFormatString=”string”OnDataBinding=”DataBinding event handler” OnDeleted=”Deleted event handler” OnDeleting=”Deleting event handler” OnDisposed=”Disposed event handler” OnFiltering=”Filtering event handler” OnInit=”Init event handler” OnInserted=”Inserted event handler” OnInserting=”Inserting event handler” OnLoad=”Load event handler”OnObjectCreated=”ObjectCreated event handler”OnObjectCreating=”ObjectCreating event handler”OnObjectDisposing=”ObjectDisposing event handler” OnPreRender=”PreRender event handler” OnSelected=”Selected event handler” OnSelecting=”Selecting event handler” OnUnload=”Unload event handler” OnUpdated=”Updated event handler” OnUpdating=”Updating event handler” runat=”server” SelectCountMethod=”string” SelectMethod=”string” SortParameterName=”string” SqlCacheDependency=”string” StartRowIndexParameterName=”string” TypeName=”string” UpdateMethod=”string”&gt;&lt;DeleteParameters&gt; &lt;asp:ControlParameter ControlID=”string”123456789101112131415161718192021ConvertEmptyStringToNull=”True|False”DefaultValue=”string”Direction=”Input|Output|InputOutput|ReturnValue”Name=”string”PropertyName=”string”Size=”integer”Type=”Empty|Object|DBNull|Boolean|Char|SByte|Byte|Int16|UInt16|Int32|UInt32|Int64|UInt64|Single|Double|Decimal|DateTime|String”/&gt; &lt;asp:CookieParameter CookieName=”string” /&gt; &lt;asp:FormParameter FormField=”string” /&gt; &lt;asp:Parameter Name=”string” /&gt; &lt;asp:ProfileParameter PropertyName=”string” /&gt; &lt;asp:QueryStringParameter QueryStringField=”string” /&gt; &lt;asp:SessionParameter SessionField=”string” /&gt;&lt;/DeleteParameters&gt;&lt;FilterParameters&gt;... ...&lt;/FilterParameters&gt;&lt;InsertParameters&gt;... ...&lt;/InsertParameters&gt;&lt;SelectParameters&gt;... ...&lt;/SelectParameters&gt;&lt;UpdateParameters&gt;... ...&lt;/UpdateParameters&gt;&lt;/asp:ObjectDataSource&gt; 绑定到数据访问层数据访问层组件封装ADO.NET代码以通过SQL命令查询和修改数据库。它通常提炼创建ADO.NET连接和命令的详细信息，并通过可使用适当的参数调用的方法公开这些详细信息。典型的数据访问层组件可按如下方式公开：123456public class MyDataBllLayer &#123; public DataView GetRecords(); public int UpdateRecord(int recordID, String recordData); public int DeleteRecord(int recordID); public int InsertRecord(int recordID, String recordData);&#125; 也就是,通常是在业务逻辑访问层定义对数据库里记录的操作，上面就定义了GetRecords、UpdateRecord、DeleteRecord和InsertRecord四个方法来读取、更新、删除和插入数据库里的数据，这些方法基本上是根据SQL里的Select、Update、Delete和Insert语句而定义。和上面方法相对应， ObjectDataSource提供了四个属性来设置该控件引用的数据处理，可以按照如下方式关联到该类型，代码如下1234&amp;lt;asp:ObjectDataSource TypeName=”MyDataLayer” runat=”server”SelectMethod=”GetRecords” UpdateMethod=”UpdateRecord” DeleteMethod=”DeleteRecord” InsertMethod=”InsertRecord” /&gt;这里的SelectMethon设置为MyDataBllLayer里的GetRecords()方法，在使用时需要注意ObjectDataSource旨在以声明的方式简化数据的开发，所以这里设置SelectMethod的值为GetRecords而不是GetRecords()。 同样依次类推，UpdateMethod、DeleteMethod、InsertMethod分别对应的是UpdateRecordDeleteRecord、InsertRecord方法。在上面GetRecords（）的定义时，读者可以看到该方法返回的类型是DataView，由于ObjectDataSource将来需要作为绑定控件的数据来源，所以它的返回类型必须如下的返回类型之一： Ienumerable、DataTable、DataView、DataSet或者Object。除此以外，ObjectDataSource还有一个重要的属性TypeName，ObjectDataSource控件使用反射技术来从来从业务逻辑程序层的类对象调用相应的方法，所以TypeName的属性值就是用来标识该控件工作时使用的类名称，下面通过Simple_ObjectDataSource.aspx来说明ObjectDataSource的基本使用。 建立数据业务逻辑层为了方装业务逻辑我建立了ProductDAL.cs文件。在该文件里定义了GetProduct方法获取产品列表，UpdateProduct方法更新产品记录，DeleteProduct删除产品记录，为了便于共享，将该文件放置在App_Code目录下，完整代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using System;using System.Collections.Generic;using System.ComponentModel;using System.Configuration;using System.Data;using System.Data.Common;using System.Data.SqlClient;using System.Web;/// &lt;summary&gt;/// Summary description for ProductBLL/// &lt;/summary&gt;public class ProductDAL&#123; protected int _count = -1; public ProductDAL() &#123; &#125; string _connectionString = ConfigurationManager.ConnectionStrings[”ConnectionString”].ConnectionString; public SqlDataReader GetProduct() &#123; SqlConnection con = new SqlConnection(_connectionString); string selectString = “SELECT * FROM Products”; SqlCommand cmd = new SqlCommand(selectString, con); con.Open(); SqlDataReader dtr = cmd.ExecuteReader(CommandBehavior.CloseConnection); return dtr; &#125; public void UpdateProduct(int productID, string productName, int categoryID, decimal price, Int16 inStore,string description) &#123; SqlConnection con = new SqlConnection(_connectionString); string updateString = “UPDATE Products set ProductName=@ProductName,CategoryID=@CategoryID,Price=@Price,InStore=@InStore,Description=@Description where ProductID=@ProductID”; SqlCommand cmd = new SqlCommand(updateString, con); cmd.Parameters.AddWithValue(“@ProductID”,productID); cmd.Parameters.AddWithValue(“@ProductName”,productName); cmd.Parameters.AddWithValue(“@CategoryID”,categoryID); cmd.Parameters.AddWithValue(“@Price”,price); cmd.Parameters.AddWithValue(“@InStore”,inStore); cmd.Parameters.AddWithValue(“@Description”,description); con.Open(); cmd.ExecuteNonQuery(); con.Close(); &#125; public void DeleteProduct(int ProductId) &#123; SqlConnection con = new SqlConnection(_connectionString); string deleteString = “DELETE FROM Products WHERE ProductID=@ProductID” SqlCommand cmd = new SqlCommand(deleteString, con); cmd.Parameters.AddWithValue(“@ProductID”, ProductId); con.Open(); cmd.ExecuteNonQuery(); con.Close(); &#125;&#125; 建立表示层建立一个页面Simple_ObjectDataSource.aspx然后将ObjectDataSource控件托方到Web窗体创，使用默认的ID。Visual Stduio为我们建立业务逻辑提供了强大的支持。选中ObjectDataSource1，在其智能配置里选择配置数据源。……最后生成代码如下：1234567891011121314&lt;asp:ObjectDataSource ID=”ObjectDataSource1” runat=”server” DeleteMethod=”DeleteProduct” SelectMethod=”GetProduct” TypeName=”ProductDAL” UpdateMethod=”UpdateProduct”&gt; &lt;DeleteParameters&gt; &lt;asp:Parameter Name=”ProductId” Type=”Int32” /&gt; &lt;/DeleteParameters&gt; &lt;UpdateParameters&gt; &lt;asp:Parameter Name=”productID” Type=”Int32” /&gt; &lt;asp:Parameter Name=”productName” Type=”String” /&gt; &lt;asp:Parameter Name=”categoryID” Type=”Int32” /&gt; &lt;asp:Parameter Name=”price” Type=”Decimal” /&gt; &lt;asp:Parameter Name=”inStore” Type=”Int16” /&gt; &lt;asp:Parameter Name=”description” Type=”String” /&gt; &lt;/UpdateParameters&gt; &lt;/asp:ObjectDataSource&gt;","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"技术教程","slug":"技术教程","permalink":"http://xj8c.cc/tags/技术教程/"}]},{"title":"Asp.net知识点总结(三)","date":"2015-07-07T12:30:58.000Z","path":"2015/07/07/asp.net-knowledge-point-summary-3/","text":"关于服务器响应码：（常用）浏览器向服务器发出请求，服务器处理可能是成功、可能是失败、可能没有权限访问等原因，服务器会通过响应码来告诉浏览器处理结果。 “200” : OK “302” : Found重定向. “400” : Bad Request错误请求，发出错误的不符合Http协议的请求 “403” : Forbidden禁止 “404” : Not Found未找到。演示访问一个不存在的页面看报文 “500” : Internal Server Error服务器内部错误。演示页面抛出异常。 “503” : Service Unavailable。一般是访问人数过多。 200段是成功；300段需要对请求做进一步的处理；400段表示客户端请求错误；500段是服务器的错误。 关于报文响应一些属性介绍：Server: Cassini/3.5.0.5表示服务器的类型 Content-Type: text/html; charset=utf-8表示返回数据的类型 Content-Length: 19944表示响应报文体的字节长度，报文头只是描述，返回的具体数据（比如HTML文本、图片数据等）在两个回车之后的内容中。 HTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。get和postGet和post是表单提交数据的两种基本方式，get请求数据通过域名后缀url传送，用户可见，不安全，post请求数据通过在请求报文正文里传输，相对比较安全。 get是通过url传递表单值，post通过url看不到表单域的值； get传递的数据量是有限的，如果要传递大数据量不能用get，比如type=“file”上传文章、type=“password”传递密码或者&lt; text area &gt;发表大段文章，post则没有这个限制； post会有浏览器提示重新提交表单的问题，get则没有(加分的回答) 对于Post的表单重新敲地址栏再刷新就不会提示重新提交了，因为重新敲地址就没有偷偷提交的数据了。Post方式的正确的地址很难直接发给别人。 GET和POST的区别1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.GET是从服务器上获取数据，POST是向服务器传送数据。GET是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。POST是通过HTTP POST机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据GET传送的数据量较小，不能大于2KB（这主要是因为受URL长度限制）。POST传送的数据量较大，一般被默认为不受限制。但理论上，限制取决于服务器的处理能力。GET安全性较低，POST安全性较高。因为GET在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。POST的所有操作对用户来说都是不可见的。页面生命周期1.当用户在浏览器地址栏输入网址址按回车之后,浏览器将请求报文进行封装,然后通过Socket套接字(三次握手)建立连接,将域名转成ip地址发送到服务器.2.当服务器接收到请求时,首先到达内核模块(kernel Modal) HTTP.SYS,而它的职责就是对当前请求做最基本的解析,解析出来当前的请求是什么(html,jpg,ashx,aspx),请求地址是什么,然后访问注册表,看下当前的请求需要交给谁处理,查看了一下,要交给IIS处理。3.IIS接收到请求之后,首先去访问一下INetInfo.exe(IIS主进程)里面的元数据信息.INetInfo.exe主要去查询当前的请求(根据后缀名)要交给哪个扩展程序进行处理.(aspx,ashx都是交给AspNet_ISAPI.DLL)4.aspnet_isapi.dll负责启动aspnet Runtime创建aspnet运行环境,将请求交给ISAPIRuntime的PR方法.5.调用ISAPIRuntime.PR通过ecb句柄创建一个HttpWorkRequest对象,就是对http请求报文的简单封装.ecb:操作系统的句柄,指向了当前请求的内存空间地址,可以通过句柄拿到当前请求的报文.6.调用HttpRuntime.PR HttpWorkRequest对象根据HttpWorkRequest对象封装一个HttpContext,它包含了所有的请求信息,HttpRequest、HttpResponse.7.根据HttpApplicationFactory获得一个HttpApplication对象(获取实例的时候,先去Application池中去找是否有空闲的HttpApplication对象,如果有直接返回,没有则先编译globle文件生成一个HttpApplication的派生类,然后通过反射创建一个HttpApplication类型实力并返回).8.开始处理请求,进入HttpApplication处理管道,开始执行19个事件23个步骤，只要是没ASP.Net的请求,都会经过这个管道,并且每一个请求都会经过这个处理管道.管道中所流动的是HttpContext上下文对象,在执行第7和第8个事件之间,先判断当前上下文里面有没有最终处理请求的handler的实例,如果没有则 根据请求地址创建一般处理程序或是aspx页面类型实例。9.在处理管道的第9个至第11个事件中,先尝试将页面对象转换成IRequestSessionState接口对象,如果转换不成功,则不加载Session对象，转换成功则将浏览器发送过来的SessionId,根据此值到服务器的Session池中找到对应的Session对象,并将它赋值给页面对象的Session属性(Page.HttpContext.HttpSessionState).10.在处理管道的第11个至第12个事件中,执行在第7-8个事件之间所创建的IHttpHandler实例的PR方法.如果是一般处理程序:开发人员所写的,执行完成就OK了. 如果是Aspx页面那么就走页面的生面周期. 主要步骤:1.创建页面控件树,创建整个页面控件树的结果普通的C#代码被编译到一个方法体重2.判断IsPostBack,确定是否回发,通过ViewState实现若ViewState不为null,则为true3.初始化:PreInit()预初始化4.加载控件状态(Load Control State)5.加载视图状态(Load View State)6.加载回传数据(Load Post Data)7.预加载(PreLoad)8.加载(Load):9.加载回传数据(Load Post Data)10.引发回传数据修改事件(Raise Post Data Changed Event)11.引发回传事件(Raise PostBack Event)12.完成加载(Load Complete):13.引发回调事件(Raise CallBack Event)14.预呈现(PreRender)15.预呈现完成(PreRender Complete)16.保存控件状态(Save Control State)17.存视图状态(Save View State)18.保存状态完成(Save View Complete)19.呈现简单步骤：在管道中管道的第十一事件到第十二事件执行页面的一般处理程序或这是页面的PR方法，开始页面的生命周期： 第一步：创建控件树BuildercontroTree内部就是将整个页面控件树的结构创建好，如果是普通的C#代码将被编译到一个方法体里。 第二步：判断是否是ISPostBack,确定当前请求是否是回发，通过Viewstate实现，如果Viewstate不为null，那么ViewState则是true。 第三步：Init方法对控件树赋初始值 包含Preinit init initcomplet 第四步：加载ViewState，加载页面的状态，解析页面上的隐藏域中的ViewState 第五步：处理回发数据，将ViewState解析的数据与提交的数据进行对比，判断改变事件和点击事件，把它们放到一个事件集合，等待后面的方法来触发 第六步：LoadPage加载页面，执行用户编写的LoadPage中的方法 第七步：ProcessPostData第二次处理回发数据 第八步：触发改变的事件和点击事件 第九步：页面加载完成 第十步：预渲染，对控件树进行最后一次处理 第十一步：保存当前页面的状态即SaveViewstate 第十二步：页面渲染 至此整个页面的生命周期结束，形成了页面，回到管道中执行管道中之后的事件。","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"技术教程","slug":"技术教程","permalink":"http://xj8c.cc/tags/技术教程/"}]},{"title":"什么是大数据，什么是红海、蓝海、互联网思维？什么是O2O？什么是众筹？","date":"2015-07-06T07:41:52.000Z","path":"2015/07/06/bigdata-internet-thinking-O2O-crowdfunding/","text":"大数据某必胜客店的电话铃响了，客服人员拿起电话。 客服：必胜客。您好，请问有什么需要我为您服务， 顾客：你好，我想要—份 客服：先生，烦请先把您的会员卡号告诉我。 顾客：16846146-。 客服：陈先生，您好。您是住在泉州路一号12楼1205室，您家电话是2646-，您公司电话是4666-，您的手机是1391234-。请问您想用哪—个电话付费’顾客：你为什么知道我所有的电话号码？ 客服：陈先生，因为番们联机到CRM系统。 顾客：我想要—个海鲜披萨。 客服：陈先生，海鲜披萨不适合您。 顾客：为什么？ 客服：目据您的医疗记录，你的血压和胆固醇都偏高。 顾客：那你们有什么可以推荐的？ 客服：您可以试试我们的低脂健康披萨。 顾客：你怎么知道我会喜欢吃这种的？ 客服：您上星期在国家图书馆借了一本《低脂健康食谱》。 顾客：好。那我要—个家庭特大号披萨，要付多少钱？ 客服：99元，这个足够您一家六口吃了。但您母亲应该少吃，她上个月刚刚做了心脏搭桥手术，还处在恢复期。 顾客：那可以刷卡吗? 客服：陈先生，对不起。请您付现款，因为您的信用卡已经刷爆了，您现在还欠银4807元，而且还不包括房贷利息。 顾客：那我先去附近提款自机提款。 客服：陈先生，根据您的记录，您已经超过提款限额。 顾客：算了，你们直接把披萨送我家吧，家里有现金。你们多久会送到？ 客服：大约30分钟。如果您不想等，可以自己骑车来。 顾客：为什么？ 客服：根据我们CRM全球定位系统的车辆行驶自动跟踪系统记录。您登记有辆车号为SB-748的摩托车，而目前您正在解放路东段华联商场右侧骑着这辆摩托车。 顾客当即晕倒。。。。。。 O2O大款以每月20000的价格包养女大学生B，B女生竟每月从包养费中拿出10000包养适龄男学生C（也就是B2C），C男觉得不平衡，每月花5000包养起o小女生，o小女生拉现自己是这条生物链的最底端后，很不爽，直接微信了大款，于是两人踢了B和C（砍掉中间环节），直接交易，每月8000。这就是020! 蓝海昨天在香格里拉门口停车，看见—个车位，这时有辆迈巴赫要停进车位。我走上前敲了敲他玻璃，甩出去一百块钱对他说：“这个车位我看中了，你去别的地方停”他觉得我小看他了，冲我脸上甩来十几张一百的叫我滚—边儿去。后来，我又如法炮制…妈呀，一晚上我竟然赚了两万多。这就叫蓝海。 红海把自己的赚钱经历传上网了，大家都在转发，—下子有许多人都想学习我，如法炮制。这时候，满大街都是手持百元钱的人，他们都在寻找车位的豪车。这就叫红海。 互联网思维看到这么多人拿着一百元在街上转悠，我知道自己的机会来了：于是，我租一辆豪华迈巴赫车开到大街上，冲着这些手持一百元等豪车的人开过去。这时候，谁递过来一百元要让车位，我就直接收下他的百元…不说了，又—个手拿百的人过来了 这就叫互联网思维。 众筹天冷了，想吃火锅，又懒得出去，咋办呢？首先你要邀请5个人。给第1个电话说：顺路买点菜来，就差蔬菜了。”接着跟第2个说：”顺路买点羊肉，就差肉了。”然后第3个：”顺路买点冻豆腐各种丸子啥的，就差这个了。“之后第4个：‘就差酒了。“最后第5个说：‘火锅底料不太够了，让他带点底料“最后，你挂电话，烧锅开水坐等其他几个人到来… 看笑了吗，笑的同时想到了上面提到的品牌名称了吗，这就叫互联网(guang)营(gao)销(gou)","tags":[{"name":"互联网","slug":"互联网","permalink":"http://xj8c.cc/tags/互联网/"},{"name":"大数据","slug":"大数据","permalink":"http://xj8c.cc/tags/大数据/"}]},{"title":"Asp.net知识点总结(二)","date":"2015-07-04T13:02:22.000Z","path":"2015/07/04/asp.net-knowledge-point-summary-2/","text":"VIEWSTATE简介：ASP.NET的 .aspx页面特有，页面级的；就是在页面上的一个隐藏域中保存客户端单独使用的数据的一种方式；服务器端控件的值都自动保存在ViewState中 方式：用户数据保存方式：1ViewState[”myKey”]=”MyData”; 读取数据方式：123string myData;if(ViewState[”myKey”]!=null)&#123; myData=(string)ViewState[”myKey”]; &#125; 注意：ViewState不能存储所有的数据类型，仅支持可序列化对象。非单值服务器控件的状态也自动保存在ViewState中列入：下拉框。（文本框是单值控件，所以不会保存在ViewState中） 原理：使用ViewState的前提：页面上必须有一个服务器端窗体标记 &lt;form runat=“server”&gt;服务器在接收到用户请求一个页面后，会自动在请求报文中找看是否包含VIEWSTATE的隐藏域，如果有，则将中间的值解码后添加到页面的ViewState属性中。服务器在输出的时候，也会自动的将ViewState中的值添加到表单里名叫VIEWSTATE的隐藏域中 VIEWSTATE适用于同一个页面在不关闭的情况下多次与服务器交互关于ViewState禁用（知道）：禁用ViewState的方法，禁用单个控件的ViewState设定enableviewstate=false，禁用ViewState以后TextBox版本不受影响，Div版本受影响，因为input的value不依靠ViewState。禁用整个页面的，在aspx的Page指令区加上EnableViewState=”false” 。内网系统、互联网的后台可以尽情的用ViewState。当某些控件的某些属性不属于浏览器表单的提交范围时，fw将会把这些属性添加到ViewState中保存。 WebForm的IsPostBack依赖于__ViewStateIsPostBackIsPostBack是Page类有一个bool类型的属性，用来判断针对当前Form的请求是第一次还是非第一次请求。当IsPostBack＝true时表示非第一次请求，我们称为PostBack，当IsPostBack＝false时表示第一次请求。IsPostBack是用来判断是否是回发数据的，在页面生命周期的第二步会判断，如果不是回发的，则为false，ViewState等不会加载，如果是回发的，则为true，ViewState等会在之后加载等，IsPostBack属性可以用来模拟ViewState的执行原理。 http协议什么是协议？协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。 什么是HTTP协议？HTTP,即超文本传输协议是一种通信协议，是一个基于应用层的通信规范，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。目前主流的是Http/1.1版本 TCP协议：通俗–两个电话机通过电话线进行数据交互的格式约定HTTP协议：通俗–两个人通过电话机说话的语法。Http协议的几个概念：1.连接(Connection)：浏览器和服务器之间传输数据的通道。 一般请求完毕就关闭，http不保持连接。不保持连接会降低处理速度（因为建立连接速度很慢），保持连接的话就会降低服务器的处理的客户端请求数，而不保持连接服务器可以处理更多的请求。2.请求(Request)：浏览器向服务器发送的“我要*”的消息，包含请求的类型、请求的数据、浏览器的信息（语言、浏览器版本等）。3.响应(Response)：服务器对浏览器请求的返回的数据，包含是否成功、状态码等。","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"技术教程","slug":"技术教程","permalink":"http://xj8c.cc/tags/技术教程/"}]},{"title":"Asp.net知识点总结(一)","date":"2015-07-03T10:25:50.000Z","path":"2015/07/03/asp.net-knowledge-point-summary-1/","text":"Asp.net六大对象1.Request–&gt;读取客户端在Web请求期间发送的值常用方法: 1、Request.UrlReferrer请求的来源，可以根据这个判断从百度搜的哪个关键词、防下载盗链、防图片盗链，可以伪造(比如迅雷)。 (使用全局一般处理程序)2、Request.UserHostAddress获得访问者的IP地址3、Request.MapPath(virtulPath)将虚拟路径转换为磁盘上的物理路径,Request.MapPath(“./a/b.aspx”)就会得到D:\\WebSites\\a\\b.aspx Server.MapPath里就是调用的Request.MapPath 4、Request.Url.GetComponents(UriComponents.HostAndPort,UriFormat.SafeUnescaped) 获取当前请求的网站的域名和端口号Request对象主要是让服务器取得客户端浏览器的一些数据,包括从HTML表单用Post或者GET方法传递的参数、Cookie和用户认证。因为Request对象是Page对象的成员之一，所以在程序中不需要做任何的声明即可直接使用；其类名为HttpRequest属性很多，但方法很少，只有一个BinaryRead() 1.使用Request.Form属性获取数据通过该属性，读取之间的表单数据.注意：提交方式要设置为“Post”。与Get方法相比较，使用Post方法可以将大量数据发送到服务器端 2.利用Request.QueryString属性获取数据Request对象的QuerySting属性可以获取HTTP查询字符串变量集合。 通过该属性，我们可以读取地址信息http://localhost/aaa.aspx?uid=tom&amp;pwd=abc其中标识为红色部分的数据.注意：提交方式要设置为“Get” 3.问题：Request.Form用于表单提交方式为Post的情况，而Request.QueryString用于表单提交方式为Get的情况，如果用错，则获取不到数据。解决方法：利用Request(“元素名”)来简化操作。 4.Request.ServerVariables(“环境变量名称”) 类似的还有：UserHostAddress,Browser,Cookies,ContentType,IsAuthenticated Item,Params2.Response–&gt;封装了页面执行期后返回到Http客户端的输出Response对象用语输出数据到客户端，包括向浏览器输出数据、重定向浏览器到另一个URL或向浏览器输出Cookie文件。其类名为httpResponse 属性和方法 Response.Write() 向客户端发送字符串信息 Response.Buffer、Response.BufferOutput：经过Reflector反编译，发现两个属性是一样的，Buffer内部就是调用的BufferOutput。这个属性用来控制是否采用响应缓存，默认是true。 Response.Clear()清空缓存区中的数据，这样在缓存区中的没有发送到浏览器端的数据被清空，不会被发送到浏览器。 Redirect() 网页转向地址Response.ContentEncoding输出流的编码。 Response.ContentType输出流的内容类型，比如是html（text/html）还是普通文本（text/plain）还是JPEG图片（image/JPEG）。 Response.OutputStream输出流，在输出图片、Excel文件等非文本内容的时候要使用它 Response.End() 终止响应，将之前缓存中的数据发给浏览器，End()之后的代码不会被继续执行,End方法里调用了Flush()方法。在终止一些非法请求的时候，比如盗链等可以用End()立即终止请求。 WriteFile() 读取一个文件，并且写入客户端输出流（实质：打开文件，并且输出到客户端。） 1.Response.Write变量数据或字符串1234Response.Write (变量数据或字符串) &lt;%=…%&gt; Response.Write(“&lt;script language=javascript&gt;alert(‘欢迎学习ASP.NET’)&lt;/script&gt;”) Response.Write(“&lt;script&gt;window.open(‘WebForm2.aspx’)&lt;/script&gt;”) 2.Response对象的Redirect方法将客户端浏览器重定向到另外的URL上，即跳转到另一个网页。例如:1Response.Redirect(“http://www.163.net/”) 3. Response.End() 终止当前页的运行4.Response.WriteFile(FileName)其中： FileName指代需向浏览器输出的文件的文件名 3.Server–&gt;提供对服务器上的属性和方法的访问Server对象提供对服务器上的方法和属性进行的访问 .其类名称是HttpServerUtility. Server对象的主要属性有：MachineName：获取服务器的计算机名称。 ScriptTimeout：获取和设置请求超时（以秒计）。 方法名称 说明CreateObject创建COM对象的一个服务器实例。 Execute执行当前服务器上的另一个aspx页，执行完该页后再返回本页继续执行 HtmlEncode对要在浏览器中显示的字符串进行HTML编码并返回已编码的字符串。 HtmlDecode对HTML编码的字符串进行解码，并返回已解码的字符串。 MapPath返回与Web服务器上的指定虚拟路径相对应的物理文件路径。 Transfer终止当前页的执行，并为当前请求开始执行新页。 UrlEncode将代表URL的字符串进行编码，以便通过URL从Web服务器到客户端进行可靠的HTTP传输。 UrlDecode对已被编码的URL字符串进行解码，并返回已解码的字符串。 UrlPathEncode对URL字符串的路径部分进行URL编码，并返回已编码的字符串。 编码： Server.HtmlEncode(“HTML代码”) 解码： Server.HtmlDecode(“已编码的HTML”) Server对象的MapPath方法将虚拟路径或相对于当前页的相对路径转化为Web服务器上的物理文件路径。 语法：Server.MapPath(“虚拟路径”)String FilePath FilePath = Server.MapPath(“/”) Response.Write(FilePath) Server.HtmlDecode()、Server.HtmlEncode() Server.UrlEncode()、 Server.UrlDecode()是对HttpUtility类中相应方法的一个代理调用。 推荐总是使用HttpUtility，因为有的地方很难拿到Server对象，而且Server的存在是为以前ASP程序员习惯而留的。 别把HtmlEncode、UrlEncode混了，UrlEncode是处理超链接中的中文问题， HtmlEncode是处理html代码的。还是推荐用HttpUtility.HtmlEncode。 Server.Transfer(path) 内部重定向请求，Server.Transfer(“JieBanRen.aspx”)将用户的请求重定向给JieBanRen.aspx处理，是服务器内部的接管（不能重定向到外部网站），浏览器是意识不到这个接管的，不是象Response.Redirect那样经历“通知浏览器‘请重新访问url这个网址’和浏览器接到命令访问新网址的过程”，是一次http请求，因此浏览器地址栏不会变化。 因为是内部接管，所以在被重定向到的页面中是可以访问到Request、Cookies等这些来源页面接受的参数的，就像这些参数是传递给他的，而Redirect则不行，因为是让浏览器去访问的。 注意Transfer是内部接管，因此不能像Redirect那样重定向到外部网站。 (常考)Response.Redirect就可以重定向到外部网站。 不能内部重定向到ashx，否则会报错“执行子请求出错”. 4.Application–&gt;作用于整个运行期的状态对象Application对象在实际网络开发中的用途就是记录整个网络的信息，如上线人数、在线名单、意见调查和网上选举等。 在给定的应用程序的多有用户之间共享信息，并在服务器运行期间持久的保存数据。 而且Application对象还有控制访问应用层数据的方法和可用于在应用程序启动和停止时触发过程的事件。 1.使用Application对象保存信息使用Application对象保存信息 Application(“键名”) = 值 或 Application(“键名”，值) 获取Application对象信息 变量名 = Application(“键名”) 或：变量名 = Application.Item(“键名”) 或：变量名 = Application.Get(“键名”) 更新Application对象的值 Application.Set(“键名”, 值) 删除一个键Application.Remove(“键名”, 值) 删除所有键Application.RemoveAll() 或Application.Clear() 2.有可能存在多个用户同时存取同一个Application对象的情况。这样就有可能出现多个用户修改同一个Application命名对象，造成数据不一致的问题。HttpApplicationState类提供两种方法Lock和Unlock，以解决对Application对象的访问同步问题，一次只允许一个线程访问应用程序状态变量。 关于锁定与解锁 锁定：Application.Lock() 访问：Application(“键名”) = 值 解锁：Application.Unlock() 注意：Lock方法和UnLock方法应该成对使用。 可用于网站访问人数，聊天室等设备 3. 使用Application事件在ASP.NET应用程序中可以包含一个特殊的可选文件—Global.asax文件，也称作ASP.NET应用程序文件，它包含用于响应ASP.NET或HTTP模块引发的应用程序级别事件的代码。 Global.asax文件提供了7个事件，其中5个应用于Application对象事件名称 说明Application_Start在应用程序启动时激发 Application_BeginRequest在每个请求开始时激发 Application_AuthenticateRequest尝试对使用者进行身份验证时激发 Application_Error在发生错误时激发 Application_End在应用程序结束时激发 5.Session–&gt;会话期状态保持对象，用于跟踪单一用户的会话Session即会话，是指一个用户在一段时间内对某一个站点的一次访问。 Session对象在.NET中对应HttpSessionState类，表示“会话状态”，可以保存与当前用户会话相关的信息。 Session对象用于存储从一个用户开始访问某个特定的aspx的页面起，到用户离开为止，特定的用户会话所需要的信息。用户在应用程序的页面切换时，Session对象的变量不会被清除。 对于一个Web应用程序而言，所有用户访问到的Application对象的内容是完全一样的；而不同用户会话访问到的Session对象的内容则各不相同。 Session可以保存变量，该变量只能供一个用户使用，也就是说，每一个网页浏览者都有自己的Session对象变量，即Session对象具有唯一性。 （1）将新的项添加到会话状态中语法格式为： Session (“键名”) = 值 或者 Session.Add( “键名” , 值) （2）按名称获取会话状态中的值语法格式为： 变量 = Session (“键名”) 或者 变量 = Session.Item(“键名”) （3）删除会话状态集合中的项语法格式为： Session.Remove(“键名”) （4）清除会话状态中的所有值语法格式为： Session.RemoveAll() 或者 Session.Clear() （5）取消当前会话语法格式为： Session.Abandon() （6）设置会话状态的超时期限，以分钟为单位。语法格式为： Session.TimeOut = 数值 Global.asax文件中有2个事件应用于Session对象 事件名称 说明 Session_Start在会话启动时激发 Session_End在会话结束时激发 6.Cookie–&gt;客户端保持会话信息的一种方式Cookie就是Web服务器保存在用户硬盘上的一段文本。 Cookie允许一个Web站点在用户的电脑上保存信息并且随后再取回它。信息的片断以‘键/值’对的形式存储。 Cookie是保存在客户机硬盘上的一个文本文件，可以存储有关特定客户端、会话或应用程序的信息，在.NET中对应HttpCookie类。 有两种类型的Cookie：会话Cookie（Session Cookie）和持久性Cookie。 前者是临时性的，一旦会话状态结束它将不复存在；后者则具有确定的过期日期，在过期之前Cookie在用户的计算机上以文本文件的形式存储。 在服务器上创建并向客户端输出Cookie可以利用Response对象实现。 Response对象支持一个名为Cookies的集合，可以将Cookie对象添加到该集合中，从而向客户端输出Cookie。 通过Request对象的Cookies集合来访问Cookie","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://xj8c.cc/tags/ASP-NET/"},{"name":"技术教程","slug":"技术教程","permalink":"http://xj8c.cc/tags/技术教程/"}]},{"title":"Shopping Online","date":"2015-05-25T09:50:23.000Z","path":"2015/05/25/shopping-online/","text":"Electronic Commerce has become a fact of modern life, with millions of people now regularly shopping from the convenience of their computers. With the development of technology, online shopping has become popular in people’s life. The advantage of online shopping is obvious, it can save time, for those who are busy with work and study. By clicking on them, they can get whatever they want.Take Taobao as an example, introduce how to shop. First open the Taobao - in search box to enter the items you need to buy or service. For example, “autumn dress was thin”. After clicking on the search, you will see a lot of products for your recommendation, and if you can see it too wide, you can also filter it out. To find their favorite products, the point to see the goods, if you meet the needs can be purchased. Pay attention to choosing the size of the goods, color, view the seller reputation, commodity profile, etc. Select the size, color, style, etc. to tick, if you now buy, click on the purchase, if you want to choose a look, you can click to join a shopping cart “.To immediately buy as an example, click on immediately after the purchase will jump out of the dialog box, need to log in information - user name, password, click to confirm. In order to determine the link, select your fill in the delivery address, contact information, the recipient information Message to the seller, fill in your other requirements or remarks. Finally click submit orders. Enter the payment page, you can choose to pay PayPal (if your PayPal money, then), enter the password can be. Also choose to pay online banking, more convenient is quick payment, do not need to password and other links, enter the password can be. If you do not choose a shortcut, you need to choose a bank card, and follow the instructions, enter the bank card number, password, payment password payment. After the payment of the success of the success of the page to pay a successful payment, the purchase process end. The advantage of online shopping is no doubt, I hope that through my explanation can give you help, and finally I wish you a pleasant online shopping.","tags":[]},{"title":"sql数据库|SqlServer2008 R2_x86&x64","date":"2015-05-04T13:13:08.000Z","path":"2015/05/04/SqlServer2008/","text":"Microsoft SQL Server 2008 R2 提供完整的企业级技术与工具，帮助您以最低的总拥有成本获得最有价值的信息。 您可以充分享受高性能，高可用性，高安全性，使用更多的高效管理与开发工具，利用自服务的商业智能实现更为广泛深入的商业洞察。 发现很多朋友一直困惑于SqlServer的正确版本寻找，今天提供给大家。SqlServer x86和SqlServer x64两个版本。 SQLEXPRADV_x86_CHSSQLEXPRADV_x86_CHS SQLEXPRADV_x64_CHSSQLEXPRADV_x64_CHS","tags":[{"name":"绿色软件","slug":"绿色软件","permalink":"http://xj8c.cc/tags/绿色软件/"},{"name":"SqlServer","slug":"SqlServer","permalink":"http://xj8c.cc/tags/SqlServer/"},{"name":"数据库","slug":"数据库","permalink":"http://xj8c.cc/tags/数据库/"}]},{"title":"揭秘：中国手机号码为什么是11位数？","date":"2015-04-17T08:37:14.000Z","path":"2015/04/17/why-is-the-chinese-mobile-number-11/","text":"目前,我国使用的手机号码为11位,为什么偏偏是11位呢?这是由号码格式和段容量决定的。 手机号可分为三段,各段有不同的编码方向:前3位是网络识别号;4-7位是地区编码;8-11位是用户号码。 电话号码为什么是11位呢?1、由号码格式决定的3位网号+4位HLR号+4位的个人代码,这样的配置既能够最大程度的利用号码资源,不至于浪费,又能够在各运营商各地区之间进行灵活分配。 2、号码段容量问题国内的手机号码,是由国家信息产业部统一规划的。原来是10位,由于用户的不断增长,10位的号码不够使用,于是升为11位。 现在的手机号码格式是中国的手机号码目前是11位,是世界上最长的电话号码,为什么是11位呢,原因很简单。 因为一个11位数的组合数一共有千亿个号码。而且即便除去头两位的“13”剩下9位数,而一个9位数的组合数也就是从13000000000——13999999999一共可以容纳10亿个不同的号码,中国才多少人?10来亿人,电话普及率还没达到100%吧,所以完全够用。 即便到未来普及率到100%或者一人两个电话的时候,我们把首位的“1”固定下来,第二位换一个数字就又增加10亿个号码的容量。","tags":[{"name":"手机","slug":"手机","permalink":"http://xj8c.cc/tags/手机/"}]},{"title":"中国最有意境的33句诗文，欣赏下吧！","date":"2015-04-13T16:00:38.000Z","path":"2015/04/14/33-poems-of-the-most-artistic-conception-in-China/","text":"1.若我白发苍苍，容颜迟暮，你会不会，依旧如此，牵我双手，倾世温柔。 2.当年相知未回音，空叹年华似流水。 3.花开两生面，人生佛魔间。 4.想人间婆娑，全无着落；看万般红紫，过眼成灰。 5.人的一生会遇到两个人，一个惊艳了时光，一个温柔了岁月。 6.玲珑骰子安红豆，入骨相思知不知。 7.心微动，奈何情已远，物也非，人也非，事事非，往日不可重。 8.时间很短，天涯很远，往后的一山一水，一朝一夕，自己安静地走完。倘若不慎走失迷途，跌入水中，也应该记得，有一条河流，叫重生。这世上任何地方，都可以生长；任何去处，都是归宿。那么，你别来找我，我亦不去寻你。守着剩下的流年，看一段岁月静好，现世安稳。 9.繁华尽处，寻一处无人山谷，建一木制小屋，铺一青石小路，与你晨钟暮鼓，安之若素。 10.无端坠入红尘梦，惹却三千烦恼丝。 11.人生一梦，白云苍狗，错错对对，恩恩怨怨，终不过日月无声，水过无痕，所为弃者，一点执念而已。 12.若君为我赠玉簪，我便为君绾长发。洗尽铅华，从此以后，日暮天涯。 13.宠辱不惊，看庭前花开花落；去留无意，望天空云卷云舒。 14.秋来春去，谁怜曲院风荷，韶华白首，不过浮生一阙。 15.我恨生前未积缘，古佛青灯度流年。 16.一生一世一双人，半醉半醒半浮生。 17.回忆如墓，淡薄如素，我们是否该相忘于江湖。 18.时光静好，与君语；细水流年，与君同；繁华落尽，与君老。 19.一念起，天涯咫尺；一念灭，咫尺天涯。 20.雾未散尽，你支一小舟，在江南里慢摇。 21.阳光温热，岁月静好，你还不来，我怎敢老去。 22.宫灯夜明昙华正盛，共饮逍遥一世悠然。 23.半窗疏影，一梦千年，琴歌萧萧笛声怜。 24.问君食可足，谓君衣可暖，心念不敢对君语，恐君有所牵，卿今随军往，他年何时还，念君不许，心虔一卦祷君安。 25.来时糊涂去时迷，空在人间走一回，生我之前谁是我，生我之后我是谁，不如不来亦不去，也无欢喜也无悲。 26.九马画山数命运，一生伴君不羡仙。 27.花开本无岸，魂落忘川犹在川。醉里不知烟波浩，梦中依稀灯火寒。花叶千年不相见，缘尽缘生舞翩迁，花不解语花颔首，佛度我心佛空叹。——曼珠沙华彼岸花 28.佛曰：三千繁华，弹指刹那，百年过后，不过一捧黄沙。 29.一念花开，一念花落，这山长水远的人世，终究是要自己走下去。 30.一念繁华一念灰，一念成悦，处处繁华处处锦。一念成执，寸寸相思寸寸灰。 31.不恋尘世浮华，不写红尘纷扰，不叹世道苍凉，不惹情思哀怨。闲看花开，静待花落，冷暖自知，干净如始。 32.一花一世界，一叶一如来，一砂一极乐，一笑一尘埃。 33.多少黄昏烟雨斜檐，翻开诗篇，勾起一纸江南。","tags":[{"name":"诗文","slug":"诗文","permalink":"http://xj8c.cc/tags/诗文/"}]},{"title":"Win7运行命令大全|开始-运行-命令总汇","date":"2015-04-05T13:29:05.000Z","path":"2015/04/05/win7-cmd/","text":"命令行大全cleanmgr–打开磁盘清理工具 compmgmt.msc－－－计算机管理 conf—-启动 netmeetingcharmap–－启动字符映射表 calc—-启动计算器chkdsk.exe–－Chkdsk磁盘检查 cmd.exe–－CMD命令提示符 certmgr.msc–证书管理实用程序 cliconfg–SQL SERVER 客户端网络实用程序 Clipbrd–－剪贴板查看器 ciadv.msc–－－索引服务程序 dvdplay–－DVD播放器 diskmgmt.msc－－－磁盘管理实用程序 dfrg.msc–磁盘碎片整理程序 devmgmt.msc－－－ 设备管理器 drwtsn32–－－ 系统医生 dxdiag–－－检查DirectX信息 dcomcnfg–打开系统组件服务 ddeshare–打开DDE共享设置 explorer–打开资源管理器 eventvwr–事件查看器 eudcedit–造字程序 fsmgmt.msc–－共享文件夹管理器 gpedit.msc–－组策略 iexpress–*工具，系统自带 logoff–注销命令 lusrmgr.msc–本机用户和组 mstsc–远程桌面连接 Msconfig.exe－－－系统配置实用程序 mem.exe–－显示内存使用情况（如果直接运行无效，可以先运行cmd，在命令提示符里输入mem.exe&gt;d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。） mplayer2–媒体播放机 magnify–－放大镜实用程序 mmc—-－打开控制台 mobsync–－同步命令 notepad–－打开记事本 net start messenger–开始信使服务 net stop messenger–－停止信使服务 net start messenger–开始信使服务 notepad–－打开记事本 nslookup–网络管理的工具向导 ntbackup–系统备份和还原 narrator–屏幕“讲述人” ntmsmgr.msc–移动存储管理器 ntmsoprq.msc－－－移动存储管理员操作请求 netstat －an–(TC)命令检查接口 Nslookup–IP地址侦测器 oobe/msoobe /a–检查windows是否激活 osk—-－打开屏幕键盘 odbcad32–ODBC数据源管理器 progman–－程序管理器 perfmon.msc–计算机性能监测程序 packager–对象包装程序 rononce －p –15秒关机 regsvr32 /u .dll–停止dll文件运行（把号换成要停止的dll文件名） regedt32–注册表编辑器 rsop.msc–组策略结果集 regedit.exe–注册表 regsvr32 /u zipfldr.dll–－－取消ZIP支持 sndrec32–录音机 services.msc－－－本地服务设置 syncapp–－创建一个公文包 sysedit–－系统配置编辑器 sigverif–文件签名验证程序 sndrec32–录音机 shrpubw–－创建共享文件夹 secpol.msc–－本地安全策略 syskey–－－系统加密 Sndvol32–音量控制程序 sfc.exe–－系统文件检查器 sfc /scannow－－－windows文件保护（扫描错误并复原） tsshutdn–60秒倒计时关机命令 taskmgr–－任务管理器 utilman–－辅助工具管理器 winchat–自带局域网聊天 winmsd–－－系统信息 winver–－－检查Windows版本 wmimgmt.msc–打开windows管理体系结构(WMI) wupdmgr–－windows更新程序 （不是正版系统不要打开） Wscript.exe–－windows脚本宿主设置 write–－－－写字板 iaacmgr–扫描仪和照相机向导 Windows7有哪些运行命令呢？下面我们就一起来看看吧1、cleanmgr: 打开磁盘清理工具 2、compmgmt.msc: 计算机管理 3、conf: 启动系统配置实用程序 4、charmap: 启动字符映射表 5、calc: 启动计算器 6、chkdsk.exe: Chkdsk磁盘检查 7、cmd.exe: CMD命令提示符 8、certmgr.msc: 证书管理实用程序9、Clipbrd: 剪贴板查看器 10、dvdplay: DVD播放器 11、diskmgmt.msc: 磁盘管理实用程序 12、dfrg.msc: 磁盘碎片整理程序 13、devmgmt.msc: 设备管理器 14、dxdiag: 检查DirectX信息 15、dcomcnfg: 打开系统组件服务 16、explorer: 打开资源管理器 17、eventvwr: 事件查看器 18、eudcedit: 造字程序 19、fsmgmt.msc: 共享文件夹管理器 20、gpedit.msc: 组策略 21、iexpress: 工具，系统自带 22、logoff: 注销命令 23、lusrmgr.msc: 本机用户和组 24、MdSched:来启动Windows内存诊断程序 25、mstsc: 远程桌面连接 26、Msconfig.exe: 系统配置实用程序 27、mplayer2: 简易widnows media player 28、mspaint: 画图板 29、magnify: 放大镜实用程序 30、mmc: 打开控制台 31、mobsync: 同步命令 32、notepad: 打开记事本 33、nslookup: 网络管理的工具向导 34、narrator: 屏幕“讲述人” 35、netstat : an(TC)命令检查接口 36、OptionalFeatures：打开“打开或关闭Windows功能”对话框 37、osk: 打开屏幕键盘 38、perfmon.msc: 计算机性能监测程序 39、regedt32: 注册表编辑器 40、rsop.msc: 组策略结果集 41、regedit.exe: 注册表 42、services.msc: 本地服务设置 43、sysedit: 系统配置编辑器 44、sigverif: 文件签名验证程序 45、shrpubw: 创建共享文件夹 46、secpol.msc: 本地安全策略 47、syskey: 系统加密 48、Sndvol: 音量控制程序 49、sfc.exe: 系统文件检查器 50、sfc /scannow: windows文件保护（扫描错误并复原） 51、taskmgr: 任务管理器 52、utilman: 辅助工具管理器 53、winver: 检查Windows版本 54、wmimgmt.msc: 打开windows管理体系结构(WMI) 55、Wscript.exe: windows脚本宿主设置 56、write: 写字板 57、wiaacmgr: 扫描仪和照相机向导 58、psr：问题步骤记录器 59、PowerShell：提供强大远程处理能力 60、colorcpl：颜色管理，配置显示器和打印机等中的色彩。 61、credwiz：备份或还原储存的用户名和密码 62、eventvwr：事件查看器管理单元(MMC) ，主要用于查看系统日志等信息。 63、wuapp：Windows更新管理器，建议设置为更新提醒模式 64、wf.msc：高级安全Windows防火墙 65、soundrecorder：录音机，没有录音时间的限制 66、snippingtool：截图工具，支持无规则截图 67、slui：Windows激活，查看系统激活信息 68、sdclt：备份状态与配置，就是查看系统是否已备份 69、Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项 70、msdt：微软支持诊断工具 71、lpksetup：语言包安装/删除向导，安装向导会提示下载语言包","tags":[{"name":"win7","slug":"win7","permalink":"http://xj8c.cc/tags/win7/"},{"name":"命令行","slug":"命令行","permalink":"http://xj8c.cc/tags/命令行/"}]},{"title":"请不要做浮躁的IT人","date":"2015-03-30T16:00:00.000Z","path":"2015/03/31/please-don't-be-a-fickle-IT-man/","text":"•1、不要看到别人的回复第一句话就说：给个代码吧！你应该想想为什么。当你自己想出来再参考别人的提示，你就知道自己和别人思路的差异。 •2、初学者请不要看太多太多的书那会误人子弟的，先找本系统的学，很多人用了很久都是只对部分功能熟悉而已，不系统还是不够的。 •3、看帮助,不要因为很难而自己是初学者所以就不看；帮助永远是最好的参考手册，虽然帮助的文字有时候很难看懂，总觉得不够直观。•4、不要被对象、属性、方法等词汇所迷惑；最根本的是先了解最基础知识。 •5、不要放过任何一个看上去很简单的小问题–他们往往并不那么简单，或者可以引伸出很多知识点；不会举一反三你就永远学不会。 •6、知道一点东西，并不能说明你会写脚本，脚本是需要经验积累的。 •7、学脚本并不难，JSP、ASP、PHP等等也不过如此–难的是长期坚持实践和不遗余力的博览群书； •8、看再多的书是学不全脚本的，要多实践。 •9、把时髦的技术挂在嘴边，还不如把过时的技术记在心里； •10、学习脚本最好的方法之一就是多练习； •11、在任何时刻都不要认为自己手中的书已经足够了； •12、看得懂的书，请仔细看；看不懂的书，请硬着头皮看； •13、别指望看第一遍书就能记住和掌握什么——请看第二遍、第三遍； •14、请把书上的例子亲手到电脑上实践，即使配套光盘中有源文件； •15、把在书中看到的有意义的例子扩充；并将其切实的运用到自己的工作中； •16、不要漏掉书中任何一个练习——请全部做完并记录下思路； •17、当你用脚本到一半却发现自己用的方法很拙劣时，请不要马上停手；请尽快将余下的部分粗略的完成以保证这个代码的完整性，然后分析自己的错误并重新编写和工作。 •18、别心急，写脚本确实不容易；水平是在不断的实践中完善和发展的； •19、每学到一个脚本难点的时候，尝试着对别人讲解这个知识点并让他理解—-你能讲清楚才说明你真的理解了； •20、记录下在和别人交流时发现的自己忽视或不理解的知识点； •21、保存好你做过的所有的源文件—-那是你最好的积累之一； •22、对于网络，还是希望大家能多利用一下，很多问题不是非要到论坛来问的，首先你要学会自己找答案，比如google、百度都是很好的搜索引擎，你只要输入关键字就能找到很多相关资料，别老是等待别人给你希望，看的出你平时一定也很懒！ •23、到一个论坛，你学会去看以前的帖子，不要什么都不看就发帖子问，也许你的问题早就有人问过了，你再问，别人已经不想再重复了，做为初学者，谁也不希望自己的帖子没人回的。 •24、虽然不是打击初学者，但是这句话还是要说：论坛论坛，就是大家讨论的地方，如果你总期望有高手总无偿指点你，除非他是你亲戚！！讨论者，起码是水平相当的才有讨论的说法，如果水平真差距太远了，连基本操作都需要别人给解答，谁还跟你讨论呢。能找到很多相关资料，别老是等待别人给你希望，看的出你平时一定也很懒！ 浮躁的人容易问：我到底该学什么；—-别问，学就对了； 浮躁的人容易问：JS有钱途吗；—-建议你去抢银行； 浮躁的人容易说：我要中文版！我英文不行！—-不行？学呀！ 浮躁的人分两种：只观望而不学的人；只学而不坚持的人； 浮躁的人永远不是一个高手。","tags":[{"name":"IT","slug":"IT","permalink":"http://xj8c.cc/tags/IT/"}]},{"title":"各大互联网公司命名的由来，值得你了解。","date":"2015-03-29T09:00:17.000Z","path":"2015/03/29/the-name-of-the-big-internet-companies/","text":"1、腾讯 马化腾给公司起名为腾讯，饱含着深长的意味。一方面，马化腾的名字里有个“腾”字，公司和自己密切相关；另一方面，“腾”也有腾飞、发达的意思。后缀为 “讯”，更多是因为老东家润讯对马化腾的影响。至于英文命名Tencent，更多是参考著名的通讯公司朗讯(lucent)而起的。后来腾讯在香港上市，Tencent的英文名被香港人称为“十分钱”(ten cent)，正好那时的腾讯至多是家SP(短信内容提供商)公司，用户所发的短信腾讯收费一毛钱一条，正好十分钱，起名很是贴切和形象。 2、阿里巴巴 马云有一次在美国一家餐厅吃饭时，他突发奇想，找来了餐厅服务员，问他是否知道阿里巴巴这个名字。服务员回答说知道，并且还跟马云说阿里巴巴打开宝藏的咒语是“芝麻开门”。之后马云又在各地反复地询问他人，经过这个测试，马云发现阿里巴巴的故事被全世界的人所熟知，并且不论语种，发音也近乎一致。“从我外婆到我儿子，他们都读阿里巴巴。”就这样，一锤定音，马云将“阿里巴巴”确定为公司的名字。 马云说：我取名字叫阿里巴巴不是为了中国，而是为了全球，我做淘宝，有一天也要打向全球。我们从一开始就不仅仅是为了赚钱，而是为了创建一家全球化的、可以做102年的优秀公司。不过，“阿里巴巴”域名已被一个加拿大人买下了。马云认准了这个域名将来会流传全世界，他在当时的启动资金50万元中，拿出了1万美元从那个加拿大人手中买回了阿里巴巴的域名。 3、百度 “百度”二字源于中国宋朝词人辛弃疾的《青玉案·元夕》诗句：“众里寻她千百度，那人却在灯火阑珊处”。李彦宏说：我从小就喜欢唐诗宋词，对中国传统文化的认同度非常强。当时的想法是，网站的名字要有中文的含义，要让中国人能明白。还要有简单的拼音，能表现搜索的含义，但不能很直接地就叫搜什么，要有文化的底蕴。想来想去，突然就冒出辛弃疾的这句词，当即就拍板了。因为“百度”两字把我们想要表达的东西全都涵盖了。 4、苹果 比较官方的说法是，乔布斯当年雄心勃勃，立志要把公司打造成神级大牛，所以一开始设计的标志是牛顿拿着一个苹果，因为牛顿被苹果砸出万有引力定律的传说已经家喻户晓。后来觉得太复杂了，就把牛顿删了，只留下苹果。还有一个说法是，因为乔布斯喜欢苹果，所以标志选了个苹果，但是设计好以后发现远远看去仿佛一个屁股，恐怕要被人嘲笑，所以就在苹果上咬一口，这样大家就知道这是一个苹果而绝不是一个屁股。 5、Google “googol”一词，指的是10的100次幂，写出的形式为数字1后跟100个零，可用来代表在互联网+上可以获得的海量的资源。但想出此名字的是斯坦福大学学生肖恩·安德森，他在互联网域名注册数据库里面搜索时，把这个词打成了“google .com”，他发现这个域名刚好可以使用。 6、NOKIA 诺基亚(Nokia)指的是生活在芬兰的一种长着黑色长毛与利爪的野兽，这种野兽主要生活在芬兰境内一条河的两岸，因此，人们就以这个怪兽的名字来命名了这条河，称之为诺基亚河(River Nokia).1865年，当弗雷德里克-依德斯塔姆(Fredrik Idestam)准备开始创业的时候，选择了在诺基亚河的岸边设立它的公司。 7、Yahoo 《格列佛游记》的作者Jonathan Swift发明了yaho这个单词。在小说里，它代表了一个在外表和行为举止上都令人厌恶的家伙，简直都不能算是一个人。David Filo和杨致远坚持选择这个名称的原因是他们喜欢字典里对Yahoo的定义“粗鲁，不通世故，粗俗”，觉得他们自己就是这种人。 8、Microsoft BillGate起了这个名字，其首次出现于盖茨1975年给微软另一创始人保罗·艾伦的信中。表示公司将专注于MICROcomputerSOFT-ware(微型计算机软件)，让人感觉这是混合“微型计算机”和“软件”而成的单词。原来叫做Mi-cro-Soft，后来把中间的“-”去掉了。 9、Facebook Facebook究竟是马克·扎克伯格(Mark Zuckerberg)还是其他哈佛大学学生在几年前的创意曾多有争论。但毫无疑问，它是来自与百年前的一种花花游戏。百年前曾有一种画画游戏，即在“主人”的“脸谱集”(Face Book)中留下注解或画上图像；此外，在19世纪和20世纪，收藏留有访客或朋友写下的想法或笑话的留言本的做法也很常见。Facebook的名称即来源于此。 10、Twitter 创始人Jack Dorsey在一次接受洛杉矶时报(LA Times)的采访中表示，曾为了选一个合适的名字而煞费苦心，想出了很多名字，希望能表达一种世界各地都在嘁嘁喳喳谈论的感觉，本想采用 “twitch(抽动)”一词，但它无法让人的脑中浮现出正确的图像。之后只得在字典中寻找相近的字词，“Twitter”是一种鸟叫声，创始人认为鸟叫是短、频、快的，符合网站的内涵，因此选择了“Twitter”为网站名称。","tags":[{"name":"互联网","slug":"互联网","permalink":"http://xj8c.cc/tags/互联网/"}]},{"title":"30部黑客电影，你看过哪几部？","date":"2015-03-25T15:03:56.000Z","path":"2015/03/25/30-the-hacker-movie/","text":"1、《社交网络The Social Network》(2010)《社交网络》是2010年电影作品，由大卫·芬奇执导，改编自2009年畅销书籍《Facebook：性爱与金钱、天才与背叛交织的秘辛》，描述Facebook创办人马克·扎克伯格以一个哈佛学生的身分，创办了改变全球网络通信的社交网站脸书，及背后背叛秘辛故事。 2、《硅谷传奇(Pirates of Silicon Valley)》(1999)1999年电影，是部描述苹果公司与微软的，非官方授权的传记式电影。电影改编自保罗·弗列柏格与米迦勒·史文 所撰写的《硅谷之火》。电影由马汀·伯克编导，于1999年在 透纳电视网播出。 3、《大买卖(The Score)》(2001)尼克·威尔斯是满誉江湖的大盗，不过他早已金盆洗手了，和女朋友戴安一起经营着他们的合法营生：蒙特利尔的一家爵士乐俱乐部。可是，尼克的老朋友兼销赃人马克斯却不愿看到他就这样退出江湖，在马克斯的威逼利诱下，尼克迫不得已重拾老.. 4、《碟中谍4(Mission: Impossible - Ghost Protocol)》(2011)当特工伊桑·亨特在莫斯科执行一个秘密的间谍活动的时候，一个恐怖分子安置的炸弹炸掉了俄罗斯的标志性建筑：克林姆林宫。俄罗斯政府随即宣布，这起袭击已经超越了一般的恐怖袭击的范畴，是完完全全的”战争的挑衅”。俄罗斯政府的.. 5、《反托拉斯行动(Antitrust)》(2001)电脑高手米罗（莱恩·菲利浦饰）是有个当画家的漂亮女友（克莱尔·弗拉妮饰），年轻的他有着大好的前程。正当他着手和朋友泰迪创办自己的公司时，却意外地被硅谷一间拥有数亿美金资产的大公司——NURV相中，这间公司的持有者，正是电脑.. 6、《操作系统革命(Revolution OS)》(2001)《操作系统革命》是一部2001年由J·T·S·摩尔导演的纪录片电影，该电影追述了GNU、Linux、自由软件运动以及开放源代码运动长达二十余年的历史。该片的主演有理查德·斯托曼、林纳斯·托瓦兹、布鲁斯·斐伦斯、拉里·奥古斯丁与埃里克·雷蒙等。 7、《偷天换日The Italian Job》(2003)一个完美无缺的计画、一项天衣无缝的行动、一次干净俐落的逃亡，但是窃盗集团首脑柯查理却没料到他的左右手竟然背叛他。查理和他的伙伴－犯案高手史提夫、电脑天才小赖、飙悍驾驶帅哥罗柏、爆破专家左耳和开锁老手布约翰－在威尼斯.. 8、《异次元骇客The Thirteenth Floor》(1999)在一栋公共大楼的十三楼，想象力丰富的道格拉斯霍尔（克莱格比科）和汉农富勒（阿明穆勒斯太尔）将虚拟现实发挥到了极限，他们在计算机上模拟了1937年的洛杉矶。霍尔在迷惘中醒来，发现富勒被谋杀，而他的房子里有一件带血的衬衫。.. 9、《黑客帝国(The Matrix)》(1999)《黑客帝国》是一部1999年好莱坞科幻电影，由沃卓斯基兄弟执导，基努·里维斯、劳伦斯·菲什伯恩、凯莉·安摩丝及雨果·威文等人主演，并由香港电影界的袁和平担任动作指导。这部影片在中国大陆也是1999年中影引进的，上海电影译制厂译制，当时个人计算机和互联网正在大陆普及，门户网站也在兴起中。 10、《龙纹身的女孩(The Girl with the Dragon Tattoo)》2011《龙纹身的女孩》（英语：The Girl with the Dragon Tattoo）是一部英语惊悚电影，根据瑞典作家史迪格·拉森于2005年出版的同名小说改编而成。导演是大卫·芬奇，丹尼尔·克雷格和鲁妮·玛拉主演。北美于2011年12月20日上映。 11、《天地逃生Gamer》(2009)在并不遥远的未来世界里，网络游戏风靡全球，不过玩法跟如今动动鼠标键盘的操作方式不太一样，而是将玩家的神经末梢接入，可以直接操作游戏角色，而被控制的这些游戏角色，都是活生生的真人。游戏的开发商是亿万富翁肯•卡索，他利.. 12、《天才除草人The Lawnmower Man》(1992)到千年之交时，一种名为”虚拟现实”的技术将得到广泛应用，它能使人进入一个由电脑创造出来的、如同想象力般无限丰富的虚幻世界，它的创造者预测这种技术将为人类社会的发展发挥无数积极的作用，而有些人则担心它会被一些人利用，.. 13、《地心抢险记The Core》(2003)地心毁灭是美国一部科幻灾难电影，于2003年上映。电影讲述地球的核心因不明原因停止转动，以致电磁场减弱。在失去地磁的保护下，地球会遭到致命的高能宇宙微波辐射袭击，造成灾难。此时有6人组成团队，驾驶一艘名为”维尔吉号”的潜地艇，钻进炽热地幔，放置并引爆核弹，使地核再次转动，重生地磁，最后成功。 14、《时空悍将Virtuosity》(1995)在完全计算机化的时代，一名邪恶的科学家研制出一个强大的杀人程序：里面融合了超过150个连环杀手的变态心理和杀人手法。而这个程序的职能使他挣脱了科学家的控制独立行凶。他拥有人的外形，并能任意修复身体的损伤，他的名字叫Sid 15、《剑鱼行动Swordfish》(2001)加布利尔(约翰·特拉沃尔塔饰)是个在江湖上闯荡多年的间谍特工，他决定窃取一笔高达95亿美金的非法政府基金，找到了世界上最顶尖的电脑黑客之一的斯坦利(休·杰克曼饰)。当年他将FBI引以为傲的高级计算机监视系统搞了个天翻地覆，.. 16、《感官游戏eXistenZ》(1999)在科技发展到尖端的未来，爱丽拉·盖勒这位美丽性感的设计师有若电玩界的女王，她所设计的[X接触]远远超越时代，它非常真实引人入胜，在试玩大会上，各方玩家齐聚一堂，体验爱丽拉的最新杰作，想不到半途杀进一群狂热者企图刺杀.. 17、《神鬼妙计Foolproof》(2003)凯文，珊曼莎及罗博三人原本生活的安全无虑，唯一的梦想便是能够创出一番丰功伟业；他们的秘密基地是经由精密科技所打造而成的，为了达成三人的梦想，他们开始着手一件史上最大宗，也是最不可能成功的抢案。 原因就在于，他.. 18、《创：战纪Tron: Legacy》(2010)影片以一对父子的冒险故事为线索层层展开，将电子网络中的与现实中的探险交相呼应。影片的主角萨姆·弗林（加莱特·赫德兰饰）是一个27岁的叛逆青年，他的父亲凯文·弗林由曾获得奥斯卡奖和金球奖的杰夫·布里奇斯扮演，影片中男主.. 19、《骇客追缉令Takedown》(2000)凯文密尼克可称为有史以来最厉害的电脑骇客，他侵入家电信公司，入侵联邦调查局的电脑，在网路世界中成为最难以捉摸的骇客之王，然而他却希望能遇上一个真正的挑战，当他开始入侵著名物理学家兼电脑天才下村勤的电脑系统后，他的愿.. 20、《对话The Conversation》(1974)由美国科波拉影片公司出品，弗朗西斯．福特．科波拉编剧兼导演。本片是科波拉的批判现实主义杰作，被誉为70年代最优秀的电影之一。编导的倾向性非常明显，主题是谴责丧失隐私的现代社会使人更加孤独、相互猜忌，加速了人际关系的紧张和人的异化。主角拆毁屋子以寻找窃听器的场景已成为经典。该片获1974年戛纳国际电影节金棕榈奖；美国奥斯卡奖三项提名；全美影评家联合会最佳导演奖。 21、《黑客Hackers》(1995)除了Sandra Bullock主演的《The Net》外，05年另外一部以未来网络世界为主题的科幻犯罪片《Hackers》也相当精彩。从今天的眼光看来，本片Cast堪称强大——虽然在当时他们都只是新晋演员：Johnny Lee Miller和Angelina Jolie联袂演出，但也许是对黑客的身份过度想象的缘故，两人的演出过于板着面孔。看着影片中所幻想的一一变为现实，而影片的演员亦成为好莱坞当家花旦，确是赏心乐事。 22、《电子世界争霸战Tron》(1982)《电子世界争霸战》是一部1982年迪士尼科幻电影。由Steven Lisberger执导、杰夫·布里吉斯等主演，及台湾动画公司宏广负责了绝大部分的手绘上色工程。本片另于2010年推出续集－－《创：战纪》。 23、《战争游戏War Games》(1983)皆大欢喜的娱乐性科幻片《战争游戏》准确地把握住大多数观众的”厌战”心理，以主人公戴维和其女友詹尼弗的爱情贯穿始终，十分巧妙地处理了关于核武器和战争的场面，使影片避免了所谓的”悲惨结局”，从而赢得了观众的欢迎和喜爱。 24、《大盗Sneakers》(1992)这部影片表现电脑的现代化及让人大开眼界。利用电脑进行犯罪活动的案例不时见诸报端，但像本片那样透过细节描绘所表现出来的触目惊心的事件，使人强烈地感受到人类对科技未来发展的潜在所可能带来的危机。故事的引人之处是缜密而细致的描写那副”黑盒”的可怕功能，以及以罗伯特·雷德福为首的几个主要角色的智慧。 25、《虎胆龙威4 Live Free or Die Hard》(2007)这是《虎胆龙威》系列特别营造的一个惯例：约翰·迈克莱恩总是在错误的时间出现在错误的地方，然后被迫卷进一系列的麻烦之中。话说不知道是哪一年的7月4日，恰好是一个周末，虽说纽约警察约翰·迈克莱恩正在度假中，可是他还来不及和他那已经上大学的女儿露西道别，就被总部的电话叫走了，他接到一个任务：逮捕黑客马特·法莱尔，然后送到FBI那里接受审讯……怎么看这都是一件稀松平常的案子，可是你不要忘了约翰那天生吸引麻烦的体质。约翰刚刚抵达马特的公寓，就像触动了什么机关似的，各种各样的混乱接踵而来。 26、《007之黄金眼Golden Eye》(1995)作为第17部007电影，《黄金眼》的问世可谓历尽艰辛。由于1989年的《杀人执照》成为票房业绩最差的007电影，所以新作的前景令人堪忧。同年，澳大利亚广电集团Qintex收购了米高梅／联美电影公司，后者面临着与Pathé电影公司合并的命运，而EON Productions的母公司Danjaq又将米高梅／联美电影公司告上法庭，因为后者未经Danjaq的许可就准备授权Pathé电影公司在多国电视台播放007电影。这些错综复杂的法律纠纷让新片的拍摄搁置了数年。 27、《觅踪Untraceable》(2008)当制片人汤姆·罗森伯格(Tom Rosenberg)和加里·卢切西(Gary Lucchesi)读到一个由罗伯特·菲佛伦特(Robert Fyvolent)和马克·布里克(Mark Brinker)共同创造的名叫《觅踪》的剧本时，一个如此合时宜的故事瞬间就突破了他们的防线，卢切西说：”FBI中的网络犯罪调查组并没有成立很长的时间，也就只有6、7年的历史。而《觅踪》却对焦在了一个非常与众不同的案件上，因为它和侵犯儿童以及信用卡偷窃完全不搭边，讲述的是一个正在实行谋杀的罪犯，只是在利用网络使一切更容易进展而已–网民们都关注于此，越多的人登陆，牺牲品也就死得越快。” 28、《时空线索Deja Vu》(2006)《时空线索》，美国科幻悬疑电影，于2006年11月22日首度上映。片名标题在法语中，为”时光倒流七十年”的意思。本片剧情认为有平行宇宙的存在，当人类出现时光倒流七十年的情形时就是在平行宇宙的另一个自己已死亡而出现意识结合。 29、《神秘幻影(One Point O) 》2004Simon 是一个计算机程序师,一天早晨他醒来发现他的公寓里有一个简单的褐色包裹。 他打开它，但是里面什么也没有。 尽管他尝试锁好他的公寓,神秘的包裹却继续出现。从安全摄像镜头观察他的行踪,Simon 渐渐变得神经质，开始怀疑公寓里的每一个人。当他们的其中之一忽然死亡的时候, Simon 被推到了危险的边缘。在这种精神折磨中,他疯狂地寻找改变了他的生活的神秘力量到底意味着什么。 30、《叛逆性骚扰Disclosure》(1994)故事场景是西雅图的一家尖端高科技公司，迈克·道格拉斯是未来副总裁的最佳人选，不料公司与大企业合并后，夺得此一高位的人竟是他十年前的同居女友黛咪·摩尔。摩尔以老朋友的身份邀道格拉斯在下班后到她办公室叙旧，不料却主动勾引他..","tags":[{"name":"黑客","slug":"黑客","permalink":"http://xj8c.cc/tags/黑客/"},{"name":"电影","slug":"电影","permalink":"http://xj8c.cc/tags/电影/"}]},{"title":"2015年 十大热门 IT 工作","date":"2015-03-22T08:30:28.000Z","path":"2015/03/22/top 10 IT jobs in 2015/","text":"无论你想设计程序、建立计算机系统或预防网络袭击，对你来说这些都是热门工作。随着就业机会和薪资不断增长，科技行业职位的吸引力也越来越大。2015年最热门科技工作榜单显示，软件开发工程师居首。 1、软件开发工程师平均年薪：92660美元 失业率：2.7% 期望职位：139900个 软件开发工程师的职位可以让你娱乐自己，同时帮助提高生产力。这些拥有创新思维的思想家专门从事设计、测试、维护以及提高应用与操作系统软件性能的工作。 2、计算机系统分析师平均年薪：81190美元 失业率：3.5% 期望职位：127700个 这些分析师中，超过1/4为计算机系统设计公司效力，但科学、医疗、银行以及金融等领域有望增加新的岗位。美国劳动统计局预测，到2022年，计算机系统分析师的岗位需求将增加24.5%。 3、信息安全分析师平均年薪：88590美元 失业率：3.5% 期望职位：27400个 这些分析师的任务是预测网络攻击，并确保公司数据和系统安全。他们主要从事危险评估、弱点评估以及制定预防公司或政府数据遭到黑客袭击的防御计划等。 4、网站开发工程师平均年薪：63160美元 失业率：3.8% 期望职位：28500个 这些网站开发工程师负责你最喜欢的网站的设计、导航以及功能开发。为了开始这个职业，你应该掌握编程技术，熟悉当前设计趋势等。 5、机械工程师平均年薪：82100美元 失业率：2.7% 期望职位：11600个 机械工程师利用研究、设计、建造和测试技术，研发安全高质量的机械驱动产品。在学士泛滥后，许多雇主可能要求求职者拥有硕士学位，而美国多个州都要求工程师必须获得许可证。 6、IT经理平均年薪：123950美元 失业率：3.5% 期望职位：50900个 IT经理引导公司将现代技术与他们的商业结构、需求以及目标相匹配。他们被期望拥有高级计算机和技术技能，管理技能同样重要。 7、土木工程师平均年薪：80770美元 失业率：3.4% 期望职位：53700个 土木工程师负责设计基础设施，比如公路、隧道、铁路系统、机场、供水与污水处理系统等，他们可能为政府部门工作，也可能为私人企业效力。许多土木工程师也从事设计、建造以及教育工作。 8、计算机系统管理员平均年薪：74000美元 失业率：3% 期望职位：42900个 随着企业向新技术基础设施加大投资，计算机系统管理员的需求也日益增加。他们需要创建系统去管理公司的工作流、识别和解决网络问题、维护设备与软件等。 9、数据库管理员平均年薪：78520美元 失业率：3.1% 期望职位：17900个 数据库管理员需要了解所从事行业的分析和设计技巧，并建立企业数据库。这些传统上的专业人员通常每周要工作40小时以上，以建立适合雇主需要的数据库。 10、计算机程序员平均年薪：76140美元 失业率：4.2% 期望职位：28400个 计算机程序员是技术领域的语言专家。利用C++和Java等编程语言，他们可以开发出运行在我们电脑上的软件。电脑程序员必须依靠团队协作来完成项目。","tags":[{"name":"互联网","slug":"互联网","permalink":"http://xj8c.cc/tags/互联网/"},{"name":"IT","slug":"IT","permalink":"http://xj8c.cc/tags/IT/"}]},{"title":"A year's plan starts with spring ！","date":"2015-03-10T09:30:33.000Z","path":"2015/03/10/a-years-plan-starts-with-spring/","text":"冷至极寒，迎来立春。经历了苦寒迎来了温暖。历经痛苦的磨难才有了成功的曙光。寒极必暖，春日临近，阳气重又上升，开始了新一年的轮回。春回大地万物生，有着无穷的力量，绵绵不绝的生命再次吹响了春天的号角。早春仿佛是大变革的前夜，虽静寂但已呈现出无限上升的力量，瞬息间的巨变将如潮水般涌来，势不可挡！早春是细腻的，要用心体验。春天是转暖后第一缕阳光，不再苍白无情；红润的太阳拨开了生机盎然的春的序幕。春天是第一瞬温暖的空气，不再寒冷刺骨；和煦的春风如恋人饱含爱意的眼波，融化了厚厚的冰层。春天是掠过柳梢的那一缕春风，融融的春风拂开了柳的心扉，传达着爱的讯息；萌动的树心涌动着春的激情。啊！春意已抹上柳梢。这陈年的枝条吸取了春日的养分，孕育了饱涨的芽苞。无数的芽苞缀满枝条，充满了无限的希望。试想不久芽苞将发出新芽，抽出新枝，为多彩的春日增添一份自己的亮色。远远望去微黄而苍黑的枝冠正是卷卷水墨画，诗意盎然；虽色彩单调但淡淡微黄中透出了复苏的迹象。质朴的树冠正如苍苍老农，卑微的生命中却蕴含着无穷的、不可压制的力量。 春天是枯草丛下那嫩嫩的草芽，顽强的小生命感知到了春的来临，迫不及待的从土中钻出来。虽时时还有寒流侵袭，但它急切生长已呈燎原之势。过不了多少时日，漫山遍野的绿色便统治整个世界。 春天是刚刚融化的河水，潺潺流水唱出春的赞歌。春水有了话语权，将冰封已久的肺腑言滔滔不绝地诉给岸边的水草。流经之处，一路欢歌。澎湃的流水是春日涌动的、不停息的音符。春天是一个梦幻的、迷人的季节。万物不再沉寂，转向喧哗，走向繁华。 春天是农人舒展开皱纹的微笑。播下希望收获丰收的硕果。春天来了，便不再贫寒。有了春日的阳光，古老而厚重的土地再次披上春装，变成崭新的世界。松软的土壤洋溢着泥土的芬芳，让人仿佛嗅到了粮食、瓜果的芳香。春天来了，生命得以延续，即便贫贱但亦有了生存的希望；只要希望不破灭，不息的生命才有奇迹。 如果没有春天，便没有多彩的世界。看吧，春风拂过，唤醒了沉睡的万物。各种植物争先恐后吐出新绿，动物们也不甘示弱，结束冬眠，在春光中谈情说爱、繁衍后代。大地重回生机勃勃、多彩多姿的世界。 正是春天给人们带来了无限的希望，故而多少人讴歌春天、赞美春天。无数度春风吹尽，纵看几千年历史中，真正的春天没有几日。“人世难逢开口笑，上疆场彼此弯弓月，流遍了，郊原血。”正是历史的真实写照。抚今追昔，生活在春天中的人们是何等幸福啊！春天来了，人们纷纷换上漂亮的春装，在大好春光中享受生活，努力工作。 一年之计在于春，又是一年春风到。春回大地，万象更新。“春天是刚落地的娃娃，从头到脚都是新的”。清新的春风吹尽一切旧的、衰老的东西，清澈的春水荡涤污浊之气，送来全新的春天。","tags":[{"name":"春天","slug":"春天","permalink":"http://xj8c.cc/tags/春天/"}]},{"title":"珍惜每一天","date":"2015-02-28T14:00:45.000Z","path":"2015/02/28/cherish-every-day/","text":"珍惜每一天 此时，心乱如麻 尘世间的纷纷扰扰 让心，无法安静 眼看时间一分一秒的流逝 却，无能为力，无法挽回心里有很多的故事 想写，却无从写起 心里有很多的话 要说，却无从说起 想打开封存已久的日记 可是却找不到看的理由 也许，过去的已经过去 尘封的往事不该再回忆 时间可能会让我们 淡忘曾经受过的伤与痛 但却抹不掉心中的疤痕 偶尔想起 疤，还是会有些痛，有些痒 也许，人生就是一种历练 不经历风雨的人 就永远见不到真正的彩虹 没有受过伤的人生 也就不算是真正的人生 既然，昨天已经远去 那么，我们应该珍惜今天 把握今天，让今天过的更精彩 让我们用幸福甜蜜的笑容 来迎接——更美好的明天吧!","tags":[]},{"title":"Adobe Photoshop 绿色安装版","date":"2015-02-28T04:22:00.000Z","path":"2015/02/28/adobe-photoshop/","text":"Photoshop介绍Adobe Photoshop CS5 Extended 是电影、视频和多媒体领域的专业人士, 使用 3D 和动画的图形和 Web 设计人员, 以及工程和科学领域的专业人士的理想选择。呈现3D图像并将它合并到 2D 复合图像中。轻松编辑视频图层上的动画图形, 让时间停下来。以及使用测量、计数和可视化工具, 探查您的图像。2010年4月12日北京时间23时，Adobe Creative Suite 5设计套装软件正式发布。 AdobeCS5总共有15个独立程序和相关技术，五种不同的组合构成了五个不同的组合版本，分别是大师典藏版、设计高级版、设计标准版、网络高级版、产品高级版。 Photoshop CS5不仅兼容Vista和Windows7 ，而且有几十个全新特性，诸如支持宽屏显示器的新式版面、集20多个窗口于一身的dock、占用面积更小的工具栏、多张照片自动生成全景、灵活的黑白转换、更易调节的选择工具、智能的滤镜、改进的消失点特性、更好的32位HDR图像支持，等等等等。 另外，Photoshop从CS5首次开始分为两个版本，分别是常规的标准版和支持3D功能的Extended(扩展)版 。Photoshop CS5标准版适合摄影师以及印刷设计人员使用，Photoshop CS5扩展版除了包含标准版的功能外还添加了用于创建和编辑 3D 和基于动画的内容的突破性工具。 Photoshop 下载：点击下载","tags":[{"name":"绿色软件","slug":"绿色软件","permalink":"http://xj8c.cc/tags/绿色软件/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://xj8c.cc/tags/Photoshop/"}]},{"title":"全国计算机一级Office2010+win7版（未来教育）考试练习软件","date":"2015-02-20T06:48:05.000Z","path":"2015/02/20/national-computer-level-office2010/","text":"全国计算机等级考试是社会考试，就考试性质而言，它是一种重视应试人员对计算机和软件的实际运用能力的考试。 考试分为四个等级，不同等级的内容不同，一级主要考核微型计算机基础知识和使用办公软件及因特网（Internet）的基本技能。 一级分为DOS版和Windows版，考核应试者计算机基本知识和使用微机系统的初步能力。 一级MS Office 采用无纸化考试,上机操作。考试时间为90 分钟。 软件环境:Windows 7 操作系统,Microsoft Office 2010 办公软件。 在指定时间内,完成下列各项操作: 选择题(计算机基础知识和网络的基本知识)。(20 分) Windows 操作系统的使用。(10 分) Excel 操作。(20 分) owerPoint 操作。(15 分) 浏览器(IE)的简单使用和电子邮件收发。(10 分) 全国计算机一级Office2010+win7版（未来教育）考试练习软件一级软件下载 证书一级证书表明持有人具有计算机的基础知识和初步应用能力，掌握文字、电子表格和演示文稿等办公自动化软件（MS Office、WPS Office）的使用及因特网（Internet）应用的基本技能，具备从事机关、企事业单位文秘和办公信息计算机化工作的能力。","tags":[{"name":"office2010","slug":"office2010","permalink":"http://xj8c.cc/tags/office2010/"},{"name":"计算机一级","slug":"计算机一级","permalink":"http://xj8c.cc/tags/计算机一级/"}]},{"title":"Win7电脑常用快捷键大全有哪些?","date":"2015-02-17T07:29:28.000Z","path":"2015/02/17/win7-shortcuts/","text":"前言记得有位电脑达人说过，真正的电脑高手其实是很少使用鼠标操作电脑的，键盘为主，鼠标为辅，不管你信不信，会一些电脑日常操作的快捷键真的很方便。 1.很多时候，需要暂时离开座位去做别的事情，如果对自己的电脑安全很重视，不妨按住windows键后，再按L键，这样电脑就直接锁屏了，这样就不用担心电脑的资料外泄啦 2.要找电脑上的文件时，一般人会先找到“我的电脑”，然后点击打开，而高手总是很酷的，轻轻按下键盘上的Windows键不放然后再按E键，直接打开电脑的资源管理器，而一般人还在慢慢寻找“我的电脑”的图标呢，嗯，高手就是这样直接把一般人给秒杀了的 正在玩游戏或看羞羞的东西的时候，Boss进来了！鼠标一下子点不到右下角的显示桌面，怎么办，怎么办？别紧张！直接按下Windows键和D键，看，桌面闪现！ 4.一个小花招，蛮炫的。 按下windows键按后再按Tab键，可以以3D效果显示切换窗口 5.windows自带的录像功能。按下windows键+R，输入psr.exe回车，然后就可以开始记录了。 6.你知道怎样一次过调整显示器亮度、音量大小，打开无线网，还能够看到本本电池电量吗？把本本的画面放到电视上，已经连好线了，需要怎么设置？小case啦，想要这些功能，你只需要按下Windows键+X，一次性满足你的所有愿望啦！ 7.Windows + R 输入osk，出现炫酷虚拟键盘！你按下一个键，它也会同样显示出来按下的状态喔！ 8.图片太小，眼神不好使咋办？ 试试windows键和+++++++++，放大镜出现！ 现在很多程序，比如QQ，IE，都是在同一个窗口里面打开几个页面。用Ctrl+Tab，可以在几个页面之间互相切换。用Ctrl+w，可以关闭当前的页面。 10.按下windows键不放，再按下Fn，再按下Home，你就可以打开系统属性了。（其实用鼠标在我的电脑上面右键-&gt;属性也一样，不过不觉得用键盘操作更帅嘛~^^ 再加一点常用的1.shift + 任务栏的窗口图标 = 新建一个该窗口 2.Ctrl+S 保存 3.Ctrl+W 关闭程序 4.Ctrl+N 新建 5.Ctrl+O 打开 6.Ctrl+Z 撤销 7.Ctrl+F 查找 8.Ctrl+X 剪切 9.Ctrl+C 复制 10.Ctrl+V 粘贴 11.Ctrl+A 全选 12.Ctrl+[ 缩小文字 13.Ctrl+] 放大文字 14.Ctrl+B 粗体 15.Ctrl+I 斜体 16.Ctrl+U 下划线 17.Ctrl+Shift 输入法切换 18.Ctrl+空格 中英文切换 19.Ctrl+回车 QQ中发送信息 20.Ctrl+Home 光标快速移到文件头 21.Ctrl+End 光标快速移到文件尾 22.Ctrl+Esc 显示开始菜单 23.Ctrl+Shift+&lt; 快速缩小文字 24.Ctrl+Shift+&gt; 快速放大文字 25.Ctrl+F5 在IE中强行刷新 26.Ctrl+拖动文件 复制文件 27.Ctrl+Backspace 启动\\关闭输入法 拖动文件时按住 28.Ctrl+Shift 创建快捷方式 29.Alt+空格+C 关闭窗口 30.Alt+空格+N 最小化当前窗口 31.Alt+空格+R 恢复最小化窗口 32.Alt+空格+X 最大化当前窗口 33.Alt+空格+M 移动窗口 34.lt+空格+S 改变窗口大小 35.Alt+Tab 两个程序交换 36.Alt+255 QQ号中输入无名人 37.Alt+F 打开文件菜单 38.Alt+V 打开视图菜单 39.Alt+E 打开编辑菜单 40.Alt+I 打开插入菜单 41.Alt+O 打开格式菜单 42.Alt+T 打开工具菜单 43.Alt+A 打开表格菜单 44.Alt+W 打开窗口菜单 45.Alt+H 打开帮助菜单 46.Alt+回车 查看文件属性 47.Alt+双击文件 查看文件属性 48.Alt+X 关闭C语言 49.Shift快捷键 50.Shift+空格 半\\全角切换 51.Shift + Delete 永久删除所选项，而不将它放到“回收站”中。 拖动某一项时按 CTRL 复制所选项。 拖动某一项时按 CTRL + SHIFT 创建所选项目的快捷键。","tags":[{"name":"win7","slug":"win7","permalink":"http://xj8c.cc/tags/win7/"},{"name":"快捷键","slug":"快捷键","permalink":"http://xj8c.cc/tags/快捷键/"}]},{"title":"Microsoft office 2010","date":"2015-02-15T08:08:30.000Z","path":"2015/02/15/microsoft-office-2010/","text":"Microsoft Office 2010，是微软推出的新一代办公软件，开发代号为Office 14，实际是第12个发行版。 该软件共有6个版本，分别是初级版、家庭及学生版、家庭及商业版、标准版、专业版和专业高级版，此外还推出Office 2010免费版本，其中仅包括Word和Excel应用。 除了完整版以外，微软还将发布针对Office 2007的升级版Office 2010。Office 2010可支持32位和64位vista及Windows7，仅支持32位WindowsXP，不支持64位XP。现已推出最新版本Microsoft Office 2013。 Microsoft Office 2010的新界面简洁明快，标识也改为了全橙色。 Office 2010将采用Ribbon新界面主题，由于程序功能的日益增多，微软专门为Office 2010开发了这套界面。 从Outlook 2010界面可以看出，与Outlook 2003和2007相比，新界面干净整洁，清晰明了，没有丝毫混淆感。 office 2010","tags":[{"name":"office2010","slug":"office2010","permalink":"http://xj8c.cc/tags/office2010/"},{"name":"绿色软件","slug":"绿色软件","permalink":"http://xj8c.cc/tags/绿色软件/"}]}]