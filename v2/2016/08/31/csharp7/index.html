<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="当然我在瞎扯啊"><title>C＃7.0中有哪些新特性？ | 当然我在瞎扯</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C＃7.0中有哪些新特性？</h1><a id="logo" href="/.">当然我在瞎扯</a><p class="description">生命不息，奋斗不止</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于我</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C＃7.0中有哪些新特性？</h1><div class="post-meta">Aug 31, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h3 id="以下将是-C-7-0-中所有计划的语言特性的描述。随着-Visual-Studio-“15”-Preview-4-版本的发布，这些特性中的大部分将活跃起来。现在是时候来展示这些特性，你也告诉借此告诉我们你的想法！"><a href="#以下将是-C-7-0-中所有计划的语言特性的描述。随着-Visual-Studio-“15”-Preview-4-版本的发布，这些特性中的大部分将活跃起来。现在是时候来展示这些特性，你也告诉借此告诉我们你的想法！" class="headerlink" title="以下将是 C# 7.0 中所有计划的语言特性的描述。随着 Visual Studio “15” Preview 4 版本的发布，这些特性中的大部分将活跃起来。现在是时候来展示这些特性，你也告诉借此告诉我们你的想法！"></a>以下将是 C# 7.0 中所有计划的语言特性的描述。随着 Visual Studio “15” Preview 4 版本的发布，这些特性中的大部分将活跃起来。现在是时候来展示这些特性，你也告诉借此告诉我们你的想法！</h3><h3 id="C＃7-0-增加了许多新功能，并专注于数据消费，简化代码和性能的改善。或许最大的特性就是元祖和模式匹配，元祖可以很容易地拥有多个返回结果，而模型匹配可以根据数据的“形”的不同来简化代码。我们希望，将它们结合起来，从而使你的代码更加简洁高效，也可以使你更加快乐并富有成效。"><a href="#C＃7-0-增加了许多新功能，并专注于数据消费，简化代码和性能的改善。或许最大的特性就是元祖和模式匹配，元祖可以很容易地拥有多个返回结果，而模型匹配可以根据数据的“形”的不同来简化代码。我们希望，将它们结合起来，从而使你的代码更加简洁高效，也可以使你更加快乐并富有成效。" class="headerlink" title="C＃7.0 增加了许多新功能，并专注于数据消费，简化代码和性能的改善。或许最大的特性就是元祖和模式匹配，元祖可以很容易地拥有多个返回结果，而模型匹配可以根据数据的“形”的不同来简化代码。我们希望，将它们结合起来，从而使你的代码更加简洁高效，也可以使你更加快乐并富有成效。"></a>C＃7.0 增加了许多新功能，并专注于数据消费，简化代码和性能的改善。或许最大的特性就是元祖和模式匹配，元祖可以很容易地拥有多个返回结果，而模型匹配可以根据数据的“形”的不同来简化代码。我们希望，将它们结合起来，从而使你的代码更加简洁高效，也可以使你更加快乐并富有成效。</h3><h3 id="请点击-Visual-Studio-窗口顶部的反馈按钮，告诉我们哪些是你不期待的特性或者你关于提升这些特性的思考。还有许多功能没有在-Preview-4-版本中实现。接下来我会描述一些我们发布的最终版本里将会起作用的特性，和一些一旦不起作用机即会删除掉的特性。我也是支持对这些计划作出改变，尤其是作为我们从你那儿得到反馈的结果。当最终版本发布时，这些特性中的一些将会改变或者删除。"><a href="#请点击-Visual-Studio-窗口顶部的反馈按钮，告诉我们哪些是你不期待的特性或者你关于提升这些特性的思考。还有许多功能没有在-Preview-4-版本中实现。接下来我会描述一些我们发布的最终版本里将会起作用的特性，和一些一旦不起作用机即会删除掉的特性。我也是支持对这些计划作出改变，尤其是作为我们从你那儿得到反馈的结果。当最终版本发布时，这些特性中的一些将会改变或者删除。" class="headerlink" title="请点击 Visual Studio 窗口顶部的反馈按钮，告诉我们哪些是你不期待的特性或者你关于提升这些特性的思考。还有许多功能没有在 Preview 4 版本中实现。接下来我会描述一些我们发布的最终版本里将会起作用的特性，和一些一旦不起作用机即会删除掉的特性。我也是支持对这些计划作出改变，尤其是作为我们从你那儿得到反馈的结果。当最终版本发布时，这些特性中的一些将会改变或者删除。"></a>请点击 Visual Studio 窗口顶部的反馈按钮，告诉我们哪些是你不期待的特性或者你关于提升这些特性的思考。还有许多功能没有在 Preview 4 版本中实现。接下来我会描述一些我们发布的最终版本里将会起作用的特性，和一些一旦不起作用机即会删除掉的特性。我也是支持对这些计划作出改变，尤其是作为我们从你那儿得到反馈的结果。当最终版本发布时，这些特性中的一些将会改变或者删除。</h3><a id="more"></a>
<h3 id="如果你好奇这些特性的设计过程，你可以在-Roslyn-GitHub-site-上找到很多设计笔记和讨论。"><a href="#如果你好奇这些特性的设计过程，你可以在-Roslyn-GitHub-site-上找到很多设计笔记和讨论。" class="headerlink" title="如果你好奇这些特性的设计过程，你可以在 Roslyn GitHub site 上找到很多设计笔记和讨论。"></a>如果你好奇这些特性的设计过程，你可以在 Roslyn GitHub site 上找到很多设计笔记和讨论。</h3><h3 id="希望-C＃7-0-能带给你快乐！"><a href="#希望-C＃7-0-能带给你快乐！" class="headerlink" title="希望 C＃7.0 能带给你快乐！"></a>希望 C＃7.0 能带给你快乐！</h3><h2 id="输出变量"><a href="#输出变量" class="headerlink" title="输出变量"></a>输出变量</h2><h3 id="在当前的-C＃-中，使用输出参数并不像我们想的那样方便。在你调用一个无输出参数的方法之前，首先必须声明一个变量并传递给它。如果你没有初始化这些变量，你就无法使用-var-来声明它们，除非先指定完整的类型："><a href="#在当前的-C＃-中，使用输出参数并不像我们想的那样方便。在你调用一个无输出参数的方法之前，首先必须声明一个变量并传递给它。如果你没有初始化这些变量，你就无法使用-var-来声明它们，除非先指定完整的类型：" class="headerlink" title="在当前的 C＃ 中，使用输出参数并不像我们想的那样方便。在你调用一个无输出参数的方法之前，首先必须声明一个变量并传递给它。如果你没有初始化这些变量，你就无法使用 var 来声明它们，除非先指定完整的类型："></a>在当前的 C＃ 中，使用输出参数并不像我们想的那样方便。在你调用一个无输出参数的方法之前，首先必须声明一个变量并传递给它。如果你没有初始化这些变量，你就无法使用 var 来声明它们，除非先指定完整的类型：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void PrintCoordinates(Point p)</div><div class="line">&#123;    int x, y; // have to &quot;predeclare&quot;</div><div class="line">    p.GetCoordinates(out x, out y);</div><div class="line">    WriteLine($&quot;(&#123;x&#125;, &#123;y&#125;)&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在-C＃7-0-中，我们正在增加输出变量和声明一个作为能够被传递的输出实参的变量的能力："><a href="#在-C＃7-0-中，我们正在增加输出变量和声明一个作为能够被传递的输出实参的变量的能力：" class="headerlink" title="在 C＃7.0 中，我们正在增加输出变量和声明一个作为能够被传递的输出实参的变量的能力："></a>在 C＃7.0 中，我们正在增加输出变量和声明一个作为能够被传递的输出实参的变量的能力：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void PrintCoordinates(Point p)</div><div class="line">&#123;</div><div class="line">    p.GetCoordinates(out int x, out int y);</div><div class="line">    WriteLine($&quot;(&#123;x&#125;, &#123;y&#125;)&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="注意，变量是在封闭块的范围内，所以后续也可以使用它们。大多数类型的声明不建立自己的范围，因此在他们中声明的变量通常会被引入到封闭范围。"><a href="#注意，变量是在封闭块的范围内，所以后续也可以使用它们。大多数类型的声明不建立自己的范围，因此在他们中声明的变量通常会被引入到封闭范围。" class="headerlink" title="注意，变量是在封闭块的范围内，所以后续也可以使用它们。大多数类型的声明不建立自己的范围，因此在他们中声明的变量通常会被引入到封闭范围。"></a>注意，变量是在封闭块的范围内，所以后续也可以使用它们。大多数类型的声明不建立自己的范围，因此在他们中声明的变量通常会被引入到封闭范围。</h3><h3 id="Note：在-Preview-4-中，适用范围规则更为严格：输出变量的作用域是声明它们的语句，因此直到下个版本发布时，上面的示例才会起作用。"><a href="#Note：在-Preview-4-中，适用范围规则更为严格：输出变量的作用域是声明它们的语句，因此直到下个版本发布时，上面的示例才会起作用。" class="headerlink" title="Note：在 Preview 4 中，适用范围规则更为严格：输出变量的作用域是声明它们的语句，因此直到下个版本发布时，上面的示例才会起作用。"></a>Note：在 Preview 4 中，适用范围规则更为严格：输出变量的作用域是声明它们的语句，因此直到下个版本发布时，上面的示例才会起作用。</h3><h3 id="由于输出变量直接被声明为实参传递给输出形参，编译器通常会告诉他们应该是的类型（除非有冲突过载），所以使用-var-来代替声明它们的方式是比较好的："><a href="#由于输出变量直接被声明为实参传递给输出形参，编译器通常会告诉他们应该是的类型（除非有冲突过载），所以使用-var-来代替声明它们的方式是比较好的：" class="headerlink" title="由于输出变量直接被声明为实参传递给输出形参，编译器通常会告诉他们应该是的类型（除非有冲突过载），所以使用 var 来代替声明它们的方式是比较好的："></a>由于输出变量直接被声明为实参传递给输出形参，编译器通常会告诉他们应该是的类型（除非有冲突过载），所以使用 var 来代替声明它们的方式是比较好的：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.GetCoordinates(out var x, out var y);</div></pre></td></tr></table></figure>
<h3 id="输出参数的一种常见用法是Try模式，其中一个布尔返回值表示成功，输出参数就会携带所获的结果："><a href="#输出参数的一种常见用法是Try模式，其中一个布尔返回值表示成功，输出参数就会携带所获的结果：" class="headerlink" title="输出参数的一种常见用法是Try模式，其中一个布尔返回值表示成功，输出参数就会携带所获的结果："></a>输出参数的一种常见用法是Try模式，其中一个布尔返回值表示成功，输出参数就会携带所获的结果：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void PrintStars(string s)</div><div class="line">&#123;  </div><div class="line"> if (int.TryParse(s, out var i))</div><div class="line">&#123;</div><div class="line">WriteLine(new string(&apos;*&apos;, i));</div><div class="line">&#125;  </div><div class="line"> else</div><div class="line">&#123;</div><div class="line">WriteLine(&quot;Cloudy - no stars tonight!&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="注意：这里i只用在-if-语句来定义它，所以-Preview-4-可以将这个处理的很好。"><a href="#注意：这里i只用在-if-语句来定义它，所以-Preview-4-可以将这个处理的很好。" class="headerlink" title="注意：这里i只用在 if 语句来定义它，所以 Preview 4 可以将这个处理的很好。"></a>注意：这里i只用在 if 语句来定义它，所以 Preview 4 可以将这个处理的很好。</h3><h3 id="我们计划允许以-a-为形式的“通配符”作为输出参数，这会让你忽略了你不关心参数："><a href="#我们计划允许以-a-为形式的“通配符”作为输出参数，这会让你忽略了你不关心参数：" class="headerlink" title="我们计划允许以 a* 为形式的“通配符”作为输出参数，这会让你忽略了你不关心参数："></a>我们计划允许以 a* 为形式的“通配符”作为输出参数，这会让你忽略了你不关心参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.GetCoordinates(out int x, out *); // I only care about x</div></pre></td></tr></table></figure>
<h3 id="Note：在-C-7-0-中是否会包含通配符还不确定。"><a href="#Note：在-C-7-0-中是否会包含通配符还不确定。" class="headerlink" title="Note：在 C#7.0 中是否会包含通配符还不确定。"></a>Note：在 C#7.0 中是否会包含通配符还不确定。</h3><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><h3 id="C＃-7-0-引入了模式概念。抽象地讲，模式是句法元素，能用来测试一个数据是否具有某种“形”，并在被应用时，从值中提取有效信息。"><a href="#C＃-7-0-引入了模式概念。抽象地讲，模式是句法元素，能用来测试一个数据是否具有某种“形”，并在被应用时，从值中提取有效信息。" class="headerlink" title="C＃ 7.0 引入了模式概念。抽象地讲，模式是句法元素，能用来测试一个数据是否具有某种“形”，并在被应用时，从值中提取有效信息。"></a>C＃ 7.0 引入了模式概念。抽象地讲，模式是句法元素，能用来测试一个数据是否具有某种“形”，并在被应用时，从值中提取有效信息。</h3><h3 id="C＃7-0-中的模式示例："><a href="#C＃7-0-中的模式示例：" class="headerlink" title="C＃7.0 中的模式示例："></a>C＃7.0 中的模式示例：</h3><ul>
<li>C 形式的常量模式（C是C#中的常量表达式），可以测试输入是否等于C</li>
<li>T X 形式的类型模式（T是一种类型、X是一个标识符），可以测试输入是否是T类型，如果是，会将输入值提取成T类型的新变量X</li>
<li>Var x 形式的 Var 模式（x是一个标识符），它总是匹配的，并简单地将输入值以它原本的类型存入一个新变量X中。</li>
</ul>
<h3 id="这仅仅是个开始-模式是一种新型的-C＃-中的语言元素。未来，我们希望增加更多的模式到-C-中。"><a href="#这仅仅是个开始-模式是一种新型的-C＃-中的语言元素。未来，我们希望增加更多的模式到-C-中。" class="headerlink" title="这仅仅是个开始 - 模式是一种新型的 C＃ 中的语言元素。未来，我们希望增加更多的模式到 C# 中。"></a>这仅仅是个开始 - 模式是一种新型的 C＃ 中的语言元素。未来，我们希望增加更多的模式到 C# 中。</h3><h3 id="在-C＃7-0，我们正在加强两个现有的具有模式的语言结构："><a href="#在-C＃7-0，我们正在加强两个现有的具有模式的语言结构：" class="headerlink" title="在 C＃7.0，我们正在加强两个现有的具有模式的语言结构："></a>在 C＃7.0，我们正在加强两个现有的具有模式的语言结构：</h3><ul>
<li>is 表达式现在具有一种右手侧的模式，而不仅仅是一种类型</li>
<li>switch 语句中的 case 语句现在可以使用匹配模式，不只是常数值在 C＃的未来版本中，我们可能会增加更多的被用到的模式。</li>
</ul>
<h3 id="具有模式的-IS-表达式"><a href="#具有模式的-IS-表达式" class="headerlink" title="具有模式的 IS 表达式"></a>具有模式的 IS 表达式</h3><h3 id="下面是使用-is-表达式的示例，其中利用了常量模式和类型模式："><a href="#下面是使用-is-表达式的示例，其中利用了常量模式和类型模式：" class="headerlink" title="下面是使用 is 表达式的示例，其中利用了常量模式和类型模式："></a>下面是使用 is 表达式的示例，其中利用了常量模式和类型模式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void PrintStars(object o)</div><div class="line">&#123;    if (o is null)</div><div class="line">return;     // constant pattern &quot;null&quot;</div><div class="line">    if (!(o is int i))</div><div class="line">return; // type pattern &quot;int i&quot;</div><div class="line">    WriteLine(new string(&apos;*&apos;, i));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="正如你们看到，模式变量（模式引入的变量）和早前描述的输出变量比较类似，它们可以在表达式中间声明，并在最近的范围内使用。就像输出变量一样，模式变量是可变的。"><a href="#正如你们看到，模式变量（模式引入的变量）和早前描述的输出变量比较类似，它们可以在表达式中间声明，并在最近的范围内使用。就像输出变量一样，模式变量是可变的。" class="headerlink" title="正如你们看到，模式变量（模式引入的变量）和早前描述的输出变量比较类似，它们可以在表达式中间声明，并在最近的范围内使用。就像输出变量一样，模式变量是可变的。"></a>正如你们看到，模式变量（模式引入的变量）和早前描述的输出变量比较类似，它们可以在表达式中间声明，并在最近的范围内使用。就像输出变量一样，模式变量是可变的。</h3><h3 id="注：就像输出变量一样，严格范围规则适用于Preview-4。"><a href="#注：就像输出变量一样，严格范围规则适用于Preview-4。" class="headerlink" title="注：就像输出变量一样，严格范围规则适用于Preview 4。"></a>注：就像输出变量一样，严格范围规则适用于Preview 4。</h3><h3 id="模式和-Try方法可以很好地协同："><a href="#模式和-Try方法可以很好地协同：" class="headerlink" title="模式和 Try方法可以很好地协同："></a>模式和 Try方法可以很好地协同：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (o is int i || (o is string s &amp;&amp; int.TryParse(s, out i)) &#123; /* use i */ &#125;</div></pre></td></tr></table></figure>
<h2 id="具有模式的-Switch-语句"><a href="#具有模式的-Switch-语句" class="headerlink" title="具有模式的 Switch 语句"></a>具有模式的 Switch 语句</h2><h3 id="我们正在归纳-Switch-语句："><a href="#我们正在归纳-Switch-语句：" class="headerlink" title="我们正在归纳 Switch 语句："></a>我们正在归纳 Switch 语句：</h3><h3 id="可以设定任何类型的-Switch-语句（不只是原始类型）"><a href="#可以设定任何类型的-Switch-语句（不只是原始类型）" class="headerlink" title="可以设定任何类型的 Switch 语句（不只是原始类型）"></a>可以设定任何类型的 Switch 语句（不只是原始类型）</h3><h3 id="模式可以用在-case-语句中"><a href="#模式可以用在-case-语句中" class="headerlink" title="模式可以用在 case 语句中"></a>模式可以用在 case 语句中</h3><h3 id="Case-语句可以有特殊的条件"><a href="#Case-语句可以有特殊的条件" class="headerlink" title="Case 语句可以有特殊的条件"></a>Case 语句可以有特殊的条件</h3><h3 id="下面是一个简单的例子："><a href="#下面是一个简单的例子：" class="headerlink" title="下面是一个简单的例子："></a>下面是一个简单的例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">switch(shape)</div><div class="line">&#123;    case Circle c:</div><div class="line">              WriteLine($&quot;circle with radius &#123;c.Radius&#125;&quot;);    </div><div class="line">   break;  </div><div class="line"> case Rectangle s when (s.Length == s.Height):</div><div class="line">               WriteLine($&quot;&#123;s.Length&#125; x &#123;s.Height&#125; square&quot;);        </div><div class="line">break;    </div><div class="line">case Rectangle r:</div><div class="line">                WriteLine($&quot;&#123;r.Length&#125; x &#123;r.Height&#125; rectangle&quot;);  </div><div class="line">     break;  </div><div class="line"> default:</div><div class="line">        WriteLine(&quot;&lt;unknown shape&gt;&quot;);      </div><div class="line"> break;</div><div class="line"> case null:    </div><div class="line">   throw new ArgumentNullException(nameof(shape));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于新扩展的-switch-语句，有几点需要注意："><a href="#关于新扩展的-switch-语句，有几点需要注意：" class="headerlink" title="关于新扩展的 switch 语句，有几点需要注意："></a>关于新扩展的 switch 语句，有几点需要注意：</h3><h3 id="Case-语句的顺序现在变得重要：就像-catch-语句一样，case-语句的范围现在可以相交，第一个匹配上的会被选中。此外，就像-catch-语句一样，编译器通过去除明显不会进入的-case-来帮助你。在此之前，你甚至不需要告诉判断的顺序，所以这并不是一个使用-case-语句的巨大的改变。"><a href="#Case-语句的顺序现在变得重要：就像-catch-语句一样，case-语句的范围现在可以相交，第一个匹配上的会被选中。此外，就像-catch-语句一样，编译器通过去除明显不会进入的-case-来帮助你。在此之前，你甚至不需要告诉判断的顺序，所以这并不是一个使用-case-语句的巨大的改变。" class="headerlink" title="Case 语句的顺序现在变得重要：就像 catch 语句一样，case 语句的范围现在可以相交，第一个匹配上的会被选中。此外，就像 catch 语句一样，编译器通过去除明显不会进入的 case 来帮助你。在此之前，你甚至不需要告诉判断的顺序，所以这并不是一个使用 case 语句的巨大的改变。"></a>Case 语句的顺序现在变得重要：就像 catch 语句一样，case 语句的范围现在可以相交，第一个匹配上的会被选中。此外，就像 catch 语句一样，编译器通过去除明显不会进入的 case 来帮助你。在此之前，你甚至不需要告诉判断的顺序，所以这并不是一个使用 case 语句的巨大的改变。</h3><h3 id="默认的语句还是最后被判断：尽管-null-的-case-语句在最后语句之前出现，它也会在默认语句被选中之前被测试。这是与现有-Switch-语义兼容的。然而，好的做法通常会将默认语句放到最后。"><a href="#默认的语句还是最后被判断：尽管-null-的-case-语句在最后语句之前出现，它也会在默认语句被选中之前被测试。这是与现有-Switch-语义兼容的。然而，好的做法通常会将默认语句放到最后。" class="headerlink" title="默认的语句还是最后被判断：尽管 null 的 case 语句在最后语句之前出现，它也会在默认语句被选中之前被测试。这是与现有 Switch 语义兼容的。然而，好的做法通常会将默认语句放到最后。"></a>默认的语句还是最后被判断：尽管 null 的 case 语句在最后语句之前出现，它也会在默认语句被选中之前被测试。这是与现有 Switch 语义兼容的。然而，好的做法通常会将默认语句放到最后。</h3><h3 id="Switch-不会到最后的-null-语句：这是因为当前-IS-表达式的例子具有类型匹配，不会匹配到-null。这保证了空值不会不小心被任何的类型模式匹配上的情况-你必须更明确如何处理它们（或放弃它而使用默认语句）。"><a href="#Switch-不会到最后的-null-语句：这是因为当前-IS-表达式的例子具有类型匹配，不会匹配到-null。这保证了空值不会不小心被任何的类型模式匹配上的情况-你必须更明确如何处理它们（或放弃它而使用默认语句）。" class="headerlink" title="Switch 不会到最后的 null 语句：这是因为当前 IS 表达式的例子具有类型匹配，不会匹配到 null。这保证了空值不会不小心被任何的类型模式匹配上的情况;你必须更明确如何处理它们（或放弃它而使用默认语句）。"></a>Switch 不会到最后的 null 语句：这是因为当前 IS 表达式的例子具有类型匹配，不会匹配到 null。这保证了空值不会不小心被任何的类型模式匹配上的情况;你必须更明确如何处理它们（或放弃它而使用默认语句）。</h3><h3 id="通过一个-case-引入模式变量-标签仅在相应的-Switch-范围内。"><a href="#通过一个-case-引入模式变量-标签仅在相应的-Switch-范围内。" class="headerlink" title="通过一个 case 引入模式变量:标签仅在相应的 Switch 范围内。"></a>通过一个 case 引入模式变量:标签仅在相应的 Switch 范围内。</h3><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="这是一个从方法中返回多个值的常见模式。目前可选用的选项并非是最佳的："><a href="#这是一个从方法中返回多个值的常见模式。目前可选用的选项并非是最佳的：" class="headerlink" title="这是一个从方法中返回多个值的常见模式。目前可选用的选项并非是最佳的："></a>这是一个从方法中返回多个值的常见模式。目前可选用的选项并非是最佳的：</h3><h3 id="输出参数：使用起来比较笨拙（即使有上述的改进），他们在使用异步方法是不起作用的。"><a href="#输出参数：使用起来比较笨拙（即使有上述的改进），他们在使用异步方法是不起作用的。" class="headerlink" title="输出参数：使用起来比较笨拙（即使有上述的改进），他们在使用异步方法是不起作用的。"></a>输出参数：使用起来比较笨拙（即使有上述的改进），他们在使用异步方法是不起作用的。</h3><h3 id="System-Tuple-lt-…-gt-返回类型：冗余使用和请求一个元组对象的分配。"><a href="#System-Tuple-lt-…-gt-返回类型：冗余使用和请求一个元组对象的分配。" class="headerlink" title="System.Tuple&lt;…&gt; 返回类型：冗余使用和请求一个元组对象的分配。"></a>System.Tuple&lt;…&gt; 返回类型：冗余使用和请求一个元组对象的分配。</h3><h3 id="方法的定制传输类型：对于类型，具有大量的代码开销，其目的只是暂时将一些值组合起来。"><a href="#方法的定制传输类型：对于类型，具有大量的代码开销，其目的只是暂时将一些值组合起来。" class="headerlink" title="方法的定制传输类型：对于类型，具有大量的代码开销，其目的只是暂时将一些值组合起来。"></a>方法的定制传输类型：对于类型，具有大量的代码开销，其目的只是暂时将一些值组合起来。</h3><h3 id="通过动态返回类型返回匿名类型：很高的性能开销，没有静态类型检查。"><a href="#通过动态返回类型返回匿名类型：很高的性能开销，没有静态类型检查。" class="headerlink" title="通过动态返回类型返回匿名类型：很高的性能开销，没有静态类型检查。"></a>通过动态返回类型返回匿名类型：很高的性能开销，没有静态类型检查。</h3><h3 id="在这点要做到更好，C＃7-0-增加的元组类型和元组文字："><a href="#在这点要做到更好，C＃7-0-增加的元组类型和元组文字：" class="headerlink" title="在这点要做到更好，C＃7.0 增加的元组类型和元组文字："></a>在这点要做到更好，C＃7.0 增加的元组类型和元组文字：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(string, string, string) LookupName(long id) // tuple return type&#123;</div><div class="line">    ... // retrieve first, middle and last from data storage</div><div class="line">    return (first, middle, last); // tuple literal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="这个方法可以有效地返回三个字符串，以元素的形式包含在一个元组值里。"><a href="#这个方法可以有效地返回三个字符串，以元素的形式包含在一个元组值里。" class="headerlink" title="这个方法可以有效地返回三个字符串，以元素的形式包含在一个元组值里。"></a>这个方法可以有效地返回三个字符串，以元素的形式包含在一个元组值里。</h3><h3 id="这种方法的调用将会收到一个元组，并且可以单独地访问其中的元素："><a href="#这种方法的调用将会收到一个元组，并且可以单独地访问其中的元素：" class="headerlink" title="这种方法的调用将会收到一个元组，并且可以单独地访问其中的元素："></a>这种方法的调用将会收到一个元组，并且可以单独地访问其中的元素：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var names = LookupName(id);</div><div class="line">WriteLine($&quot;found &#123;names.Item1&#125; &#123;names.Item3&#125;.&quot;);</div></pre></td></tr></table></figure>
<h3 id="Item1-等是元组元素的默认名称，也可以被一直使用。但他们不具有描述性，所以你可以选择添加更好的："><a href="#Item1-等是元组元素的默认名称，也可以被一直使用。但他们不具有描述性，所以你可以选择添加更好的：" class="headerlink" title="Item1 等是元组元素的默认名称，也可以被一直使用。但他们不具有描述性，所以你可以选择添加更好的："></a>Item1 等是元组元素的默认名称，也可以被一直使用。但他们不具有描述性，所以你可以选择添加更好的：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(string first, string middle, string last) LookupName(long id) // tuple elements have names</div></pre></td></tr></table></figure>
<h3 id="现在元组的接收者有多个具有描述性的名称可用："><a href="#现在元组的接收者有多个具有描述性的名称可用：" class="headerlink" title="现在元组的接收者有多个具有描述性的名称可用："></a>现在元组的接收者有多个具有描述性的名称可用：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var names = LookupName(id);</div><div class="line">WriteLine($&quot;found &#123;names.first&#125; &#123;names.last&#125;.&quot;);</div></pre></td></tr></table></figure>
<h3 id="你也可以直接在元组文字指定元素名称："><a href="#你也可以直接在元组文字指定元素名称：" class="headerlink" title="你也可以直接在元组文字指定元素名称："></a>你也可以直接在元组文字指定元素名称：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return (first: first, middle: middle, last: last); // named tuple elements in a literal</div></pre></td></tr></table></figure>
<h3 id="一般可以给元组类型分配一些彼此无关的名称：只要各个元素是可分配的，元组类型就可以自如地转换为其他的元组类型。也有一些限制，特别是对元组文字，即常见的和告警错误，如不慎交换元素名称的情况下，就会出现错误。"><a href="#一般可以给元组类型分配一些彼此无关的名称：只要各个元素是可分配的，元组类型就可以自如地转换为其他的元组类型。也有一些限制，特别是对元组文字，即常见的和告警错误，如不慎交换元素名称的情况下，就会出现错误。" class="headerlink" title="一般可以给元组类型分配一些彼此无关的名称：只要各个元素是可分配的，元组类型就可以自如地转换为其他的元组类型。也有一些限制，特别是对元组文字，即常见的和告警错误，如不慎交换元素名称的情况下，就会出现错误。"></a>一般可以给元组类型分配一些彼此无关的名称：只要各个元素是可分配的，元组类型就可以自如地转换为其他的元组类型。也有一些限制，特别是对元组文字，即常见的和告警错误，如不慎交换元素名称的情况下，就会出现错误。</h3><h3 id="Note：这些限制尚未在-Preview-4-中实现。"><a href="#Note：这些限制尚未在-Preview-4-中实现。" class="headerlink" title="Note：这些限制尚未在 Preview 4 中实现。"></a>Note：这些限制尚未在 Preview 4 中实现。</h3><h3 id="元组是值类型的，它们的元素是公开的，可变的。他们有值相等，如果所有的元素都是成对相等的（并且具有相同的哈希值），那么这两个元组也是相等的（并且具有相同的哈希值）。"><a href="#元组是值类型的，它们的元素是公开的，可变的。他们有值相等，如果所有的元素都是成对相等的（并且具有相同的哈希值），那么这两个元组也是相等的（并且具有相同的哈希值）。" class="headerlink" title="元组是值类型的，它们的元素是公开的，可变的。他们有值相等，如果所有的元素都是成对相等的（并且具有相同的哈希值），那么这两个元组也是相等的（并且具有相同的哈希值）。"></a>元组是值类型的，它们的元素是公开的，可变的。他们有值相等，如果所有的元素都是成对相等的（并且具有相同的哈希值），那么这两个元组也是相等的（并且具有相同的哈希值）。</h3><h3 id="这使得在需要返回多个值的情况下，元组会非常有用。举例来说，如果你需要多个-key-值的字典，使用元组作为你的-key-值，一切会非常顺利。如果你需要在每个位置都具有多个值的列表，使用元组进行列表搜索，会工作的很好。"><a href="#这使得在需要返回多个值的情况下，元组会非常有用。举例来说，如果你需要多个-key-值的字典，使用元组作为你的-key-值，一切会非常顺利。如果你需要在每个位置都具有多个值的列表，使用元组进行列表搜索，会工作的很好。" class="headerlink" title="这使得在需要返回多个值的情况下，元组会非常有用。举例来说，如果你需要多个 key 值的字典，使用元组作为你的 key 值，一切会非常顺利。如果你需要在每个位置都具有多个值的列表，使用元组进行列表搜索，会工作的很好。"></a>这使得在需要返回多个值的情况下，元组会非常有用。举例来说，如果你需要多个 key 值的字典，使用元组作为你的 key 值，一切会非常顺利。如果你需要在每个位置都具有多个值的列表，使用元组进行列表搜索，会工作的很好。</h3><h3 id="Note：元组依赖于一组基本类型，却不包括在-Preview-4-中。为了使该特性工作，你可以通过-NuGet-获取它们："><a href="#Note：元组依赖于一组基本类型，却不包括在-Preview-4-中。为了使该特性工作，你可以通过-NuGet-获取它们：" class="headerlink" title="Note：元组依赖于一组基本类型，却不包括在 Preview 4 中。为了使该特性工作，你可以通过 NuGet 获取它们："></a>Note：元组依赖于一组基本类型，却不包括在 Preview 4 中。为了使该特性工作，你可以通过 NuGet 获取它们：</h3><h3 id="右键单击-Solution-Explorer-中的项目，然后选择“管理的NuGet包……”"><a href="#右键单击-Solution-Explorer-中的项目，然后选择“管理的NuGet包……”" class="headerlink" title="右键单击 Solution Explorer 中的项目，然后选择“管理的NuGet包……”"></a>右键单击 Solution Explorer 中的项目，然后选择“管理的NuGet包……”</h3><h3 id="选择“Browse”选项卡，选中“Include-prerelease”，选择“nuget-org”作为“Package-source”"><a href="#选择“Browse”选项卡，选中“Include-prerelease”，选择“nuget-org”作为“Package-source”" class="headerlink" title="选择“Browse”选项卡，选中“Include prerelease”，选择“nuget.org”作为“Package source”"></a>选择“Browse”选项卡，选中“Include prerelease”，选择“nuget.org”作为“Package source”</h3><h3 id="搜索“System-ValueTuple”并安装它。"><a href="#搜索“System-ValueTuple”并安装它。" class="headerlink" title="搜索“System.ValueTuple”并安装它。"></a>搜索“System.ValueTuple”并安装它。</h3><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="消耗元组的另一种方法是将解构它们。一个解构声明是一个将元组（或其他值）分割成部分并单独分配到新变量的语法："><a href="#消耗元组的另一种方法是将解构它们。一个解构声明是一个将元组（或其他值）分割成部分并单独分配到新变量的语法：" class="headerlink" title="消耗元组的另一种方法是将解构它们。一个解构声明是一个将元组（或其他值）分割成部分并单独分配到新变量的语法："></a>消耗元组的另一种方法是将解构它们。一个解构声明是一个将元组（或其他值）分割成部分并单独分配到新变量的语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(string first, string middle, string last) = LookupName(id1);</div><div class="line">// deconstructing declaration</div><div class="line">WriteLine($&quot;found &#123;first&#125; &#123;last&#125;.&quot;);</div></pre></td></tr></table></figure>
<h3 id="在解构声明中，您可以使用-var-来声明单独的变量："><a href="#在解构声明中，您可以使用-var-来声明单独的变量：" class="headerlink" title="在解构声明中，您可以使用 var 来声明单独的变量："></a>在解构声明中，您可以使用 var 来声明单独的变量：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(var first, var middle, var last) = LookupName(id1); // var inside</div></pre></td></tr></table></figure>
<p>或者将一个单独的 var 作为一个缩写放入圆括号外面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var (first, middle, last) = LookupName(id1); // var outside</div></pre></td></tr></table></figure>
<p>你也可以使用解构任务来解构成现有的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(first, middle, last) = LookupName(id2); // deconstructing assignment</div></pre></td></tr></table></figure>
<h3 id="解构不只是应用于元组。任何的类型都可以被解构，只要它具有（实例或扩展）的解构方法："><a href="#解构不只是应用于元组。任何的类型都可以被解构，只要它具有（实例或扩展）的解构方法：" class="headerlink" title="解构不只是应用于元组。任何的类型都可以被解构，只要它具有（实例或扩展）的解构方法："></a>解构不只是应用于元组。任何的类型都可以被解构，只要它具有（实例或扩展）的解构方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void Deconstruct(out T1 x1, ..., out Tn xn) &#123; ... &#125;</div></pre></td></tr></table></figure>
<h3 id="输出参数构成了解构结果中的值。"><a href="#输出参数构成了解构结果中的值。" class="headerlink" title="输出参数构成了解构结果中的值。"></a>输出参数构成了解构结果中的值。</h3><h3 id="（为什么它使用了参数，而不是返回一个元组？这是为了让你针对不同的值拥有多个重载）。"><a href="#（为什么它使用了参数，而不是返回一个元组？这是为了让你针对不同的值拥有多个重载）。" class="headerlink" title="（为什么它使用了参数，而不是返回一个元组？这是为了让你针对不同的值拥有多个重载）。"></a>（为什么它使用了参数，而不是返回一个元组？这是为了让你针对不同的值拥有多个重载）。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Point</div><div class="line">&#123;  </div><div class="line"> public int X &#123; get; &#125;    public int Y &#123; get; &#125; </div><div class="line">    public Point(int x, int y) &#123; X = x; Y = y; &#125;  </div><div class="line"> public void Deconstruct(out int x, out int y) &#123; x = X; y = Y; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">(var myX, var myY) = GetPoint(); // calls Deconstruct(out myX, out myY);</div></pre></td></tr></table></figure>
<h3 id="这是一种常见的模式，以一种对称的方式包含了构建和解构。"><a href="#这是一种常见的模式，以一种对称的方式包含了构建和解构。" class="headerlink" title="这是一种常见的模式，以一种对称的方式包含了构建和解构。"></a>这是一种常见的模式，以一种对称的方式包含了构建和解构。</h3><h3 id="对于输出变量，我们计划在解构中加入通配符，来化简你不关心的变量："><a href="#对于输出变量，我们计划在解构中加入通配符，来化简你不关心的变量：" class="headerlink" title="对于输出变量，我们计划在解构中加入通配符，来化简你不关心的变量："></a>对于输出变量，我们计划在解构中加入通配符，来化简你不关心的变量：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(var myX, *) = GetPoint(); // I only care about myX</div></pre></td></tr></table></figure>
<h3 id="Note：通配符是否会出现在C＃7-0中，这仍是未知数。"><a href="#Note：通配符是否会出现在C＃7-0中，这仍是未知数。" class="headerlink" title="Note：通配符是否会出现在C＃7.0中，这仍是未知数。"></a>Note：通配符是否会出现在C＃7.0中，这仍是未知数。</h3><h2 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h2><h3 id="有时候，一个辅助函数可以在一个独立函数内部起作用。现在，你可以以一个局部函数的方式在其它函数内部声明这样的函数："><a href="#有时候，一个辅助函数可以在一个独立函数内部起作用。现在，你可以以一个局部函数的方式在其它函数内部声明这样的函数：" class="headerlink" title="有时候，一个辅助函数可以在一个独立函数内部起作用。现在，你可以以一个局部函数的方式在其它函数内部声明这样的函数："></a>有时候，一个辅助函数可以在一个独立函数内部起作用。现在，你可以以一个局部函数的方式在其它函数内部声明这样的函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public int Fibonacci(int x)</div><div class="line">&#123;    if (x &lt; 0)</div><div class="line">throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x));  </div><div class="line"> return Fib(x).current;</div><div class="line"></div><div class="line">    (int current, int previous) Fib(int i)</div><div class="line">    &#123;      </div><div class="line"> if (i == 0)</div><div class="line">return (1, 0);      </div><div class="line"> var (p, pp) = Fib(i - 1);    </div><div class="line">   return (p + pp, p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="闭合范围内的参数和局部变量在局部函数的内部是可用的，就如同它们在-lambda-表达式中一样。"><a href="#闭合范围内的参数和局部变量在局部函数的内部是可用的，就如同它们在-lambda-表达式中一样。" class="headerlink" title="闭合范围内的参数和局部变量在局部函数的内部是可用的，就如同它们在 lambda 表达式中一样。"></a>闭合范围内的参数和局部变量在局部函数的内部是可用的，就如同它们在 lambda 表达式中一样。</h3><h3 id="举一个例子，迭代的方法实现通常需要一个非迭代的封装方法，以便在调用时检查实参。（迭代器本身不启动运行，直到-MoveNext-被调用）。局部函数非常适合这样的场景："><a href="#举一个例子，迭代的方法实现通常需要一个非迭代的封装方法，以便在调用时检查实参。（迭代器本身不启动运行，直到-MoveNext-被调用）。局部函数非常适合这样的场景：" class="headerlink" title="举一个例子，迭代的方法实现通常需要一个非迭代的封装方法，以便在调用时检查实参。（迭代器本身不启动运行，直到 MoveNext 被调用）。局部函数非常适合这样的场景："></a>举一个例子，迭代的方法实现通常需要一个非迭代的封装方法，以便在调用时检查实参。（迭代器本身不启动运行，直到 MoveNext 被调用）。局部函数非常适合这样的场景：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; filter)</div><div class="line">&#123;  </div><div class="line"> if (source == null)</div><div class="line">throw new ArgumentNullException(nameof(source));  </div><div class="line"> if (filter == null)</div><div class="line">throw new ArgumentNullException(nameof(filter)); </div><div class="line">    return Iterator();</div><div class="line"></div><div class="line">    IEnumerable&lt;T&gt; Iterator()</div><div class="line">    &#123;    </div><div class="line">   foreach (var element in source) </div><div class="line">        &#123;          </div><div class="line"> if (filter(element)) &#123; yield return element; &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="如果迭代器有一个私有方法传递给过滤器，那么当其它成员意外的使用迭代器时，迭代器也变得可用（即使没有参数检查）。此外，还会采取相同的实参作为过滤器，以便替换范围内的参数。"><a href="#如果迭代器有一个私有方法传递给过滤器，那么当其它成员意外的使用迭代器时，迭代器也变得可用（即使没有参数检查）。此外，还会采取相同的实参作为过滤器，以便替换范围内的参数。" class="headerlink" title="如果迭代器有一个私有方法传递给过滤器，那么当其它成员意外的使用迭代器时，迭代器也变得可用（即使没有参数检查）。此外，还会采取相同的实参作为过滤器，以便替换范围内的参数。"></a>如果迭代器有一个私有方法传递给过滤器，那么当其它成员意外的使用迭代器时，迭代器也变得可用（即使没有参数检查）。此外，还会采取相同的实参作为过滤器，以便替换范围内的参数。</h3><h3 id="注意：在-Preview-4，局部函数在调用之前，必须被声明。这个限制将会被松开，以便使得局部函数从定义分配中读取时，能够被调用。"><a href="#注意：在-Preview-4，局部函数在调用之前，必须被声明。这个限制将会被松开，以便使得局部函数从定义分配中读取时，能够被调用。" class="headerlink" title="注意：在 Preview 4，局部函数在调用之前，必须被声明。这个限制将会被松开，以便使得局部函数从定义分配中读取时，能够被调用。"></a>注意：在 Preview 4，局部函数在调用之前，必须被声明。这个限制将会被松开，以便使得局部函数从定义分配中读取时，能够被调用。</h3><h2 id="文字改进"><a href="#文字改进" class="headerlink" title="文字改进"></a>文字改进</h2><h3 id="C＃7-0-允许-出现，作为数字分隔号："><a href="#C＃7-0-允许-出现，作为数字分隔号：" class="headerlink" title="C＃7.0 允许 _ 出现，作为数字分隔号："></a>C＃7.0 允许 _ 出现，作为数字分隔号：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var d = 123_456;</div><div class="line">var x = 0xAB_CD_EF;</div></pre></td></tr></table></figure>
<h3 id="你可以将-放入任意的数字之间，以提高可读性，它们对值没有影响。"><a href="#你可以将-放入任意的数字之间，以提高可读性，它们对值没有影响。" class="headerlink" title="你可以将 _ 放入任意的数字之间，以提高可读性，它们对值没有影响。"></a>你可以将 _ 放入任意的数字之间，以提高可读性，它们对值没有影响。</h3><h3 id="此外，C＃7-0-引入了二进制文字，这样你就可以指定二进制模式而不用去了解十六进制。"><a href="#此外，C＃7-0-引入了二进制文字，这样你就可以指定二进制模式而不用去了解十六进制。" class="headerlink" title="此外，C＃7.0 引入了二进制文字，这样你就可以指定二进制模式而不用去了解十六进制。"></a>此外，C＃7.0 引入了二进制文字，这样你就可以指定二进制模式而不用去了解十六进制。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var b = 0b1010_1011_1100_1101_1110_1111;</div></pre></td></tr></table></figure>
<h3 id="引用返回和局部引用"><a href="#引用返回和局部引用" class="headerlink" title="引用返回和局部引用"></a>引用返回和局部引用</h3><h3 id="就像在-C-中通过引用来传递参数（使用引用修改器），你现在也可以通过引用来返回参数，同样也可以以局部变量的方式存储参数。"><a href="#就像在-C-中通过引用来传递参数（使用引用修改器），你现在也可以通过引用来返回参数，同样也可以以局部变量的方式存储参数。" class="headerlink" title="就像在 C# 中通过引用来传递参数（使用引用修改器），你现在也可以通过引用来返回参数，同样也可以以局部变量的方式存储参数。"></a>就像在 C# 中通过引用来传递参数（使用引用修改器），你现在也可以通过引用来返回参数，同样也可以以局部变量的方式存储参数。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public ref int Find(int number, int[] numbers)</div><div class="line">&#123;    </div><div class="line">for (int i = 0; i &lt; numbers.Length; i++)</div><div class="line">     &#123;    </div><div class="line">   if (numbers[i] == number) </div><div class="line">            &#123;    </div><div class="line">       return ref numbers[i];</div><div class="line">// return the storage location, not the value    &#125;</div><div class="line">        &#125;  </div><div class="line"> throw new IndexOutOfRangeException($&quot;&#123;nameof(number)&#125; not found&quot;);</div><div class="line">&#125; </div><div class="line">int[] array = &#123; 1, 15, -39, 0, 7, 14, -12 &#125;;</div><div class="line">ref int place = ref Find(7, array); // aliases 7&apos;s place in the arrayplace = 9; // replaces 7 with 9 in the arrayWriteLine(array[4]); // prints 9</div></pre></td></tr></table></figure>
<h3 id="这是绕过占位符进入大数据结构的好方法。例如，一个游戏也许会将它的数据保存在大型预分配的阵列结构中（为了避免垃圾回收机制暂停）。方法可以将直接引用返回成一个结构，通过它的调用者可以读取和修改它。"><a href="#这是绕过占位符进入大数据结构的好方法。例如，一个游戏也许会将它的数据保存在大型预分配的阵列结构中（为了避免垃圾回收机制暂停）。方法可以将直接引用返回成一个结构，通过它的调用者可以读取和修改它。" class="headerlink" title="这是绕过占位符进入大数据结构的好方法。例如，一个游戏也许会将它的数据保存在大型预分配的阵列结构中（为了避免垃圾回收机制暂停）。方法可以将直接引用返回成一个结构，通过它的调用者可以读取和修改它。"></a>这是绕过占位符进入大数据结构的好方法。例如，一个游戏也许会将它的数据保存在大型预分配的阵列结构中（为了避免垃圾回收机制暂停）。方法可以将直接引用返回成一个结构，通过它的调用者可以读取和修改它。</h3><h3 id="也有一些限制，以确保安全："><a href="#也有一些限制，以确保安全：" class="headerlink" title="也有一些限制，以确保安全："></a>也有一些限制，以确保安全：</h3><h3 id="你只能返回“安全返回”的引用：一个是传递给你的引用，一个是指向对象中的引用。"><a href="#你只能返回“安全返回”的引用：一个是传递给你的引用，一个是指向对象中的引用。" class="headerlink" title="你只能返回“安全返回”的引用：一个是传递给你的引用，一个是指向对象中的引用。"></a>你只能返回“安全返回”的引用：一个是传递给你的引用，一个是指向对象中的引用。</h3><h3 id="本地引用会被初始化成一个本地存储，并且不能指向另一个存储。"><a href="#本地引用会被初始化成一个本地存储，并且不能指向另一个存储。" class="headerlink" title="本地引用会被初始化成一个本地存储，并且不能指向另一个存储。"></a>本地引用会被初始化成一个本地存储，并且不能指向另一个存储。</h3><h2 id="异步返回类型"><a href="#异步返回类型" class="headerlink" title="异步返回类型"></a>异步返回类型</h2><h3 id="到现在为止，C＃-的异步方法必须返回-void，Task-或-Task。C＃7-0-允许其它类型以这种能从一个方法中返回的方式被定义，因为它们可以以异步方法被返回的方式来定义其它类型。"><a href="#到现在为止，C＃-的异步方法必须返回-void，Task-或-Task。C＃7-0-允许其它类型以这种能从一个方法中返回的方式被定义，因为它们可以以异步方法被返回的方式来定义其它类型。" class="headerlink" title="到现在为止，C＃ 的异步方法必须返回 void，Task 或 Task。C＃7.0 允许其它类型以这种能从一个方法中返回的方式被定义，因为它们可以以异步方法被返回的方式来定义其它类型。"></a>到现在为止，C＃ 的异步方法必须返回 void，Task 或 Task<t>。C＃7.0 允许其它类型以这种能从一个方法中返回的方式被定义，因为它们可以以异步方法被返回的方式来定义其它类型。</t></h3><h3 id="例如我们计划建立一个-ValueTask-结构类型的数据。建立它是为了防止异步运行的结果在等待时已可用的情境下，对-Task-进行分配。对于许多实例中设计缓冲的异步场景，这可以大大减少分配的数量并显著地提升性能。"><a href="#例如我们计划建立一个-ValueTask-结构类型的数据。建立它是为了防止异步运行的结果在等待时已可用的情境下，对-Task-进行分配。对于许多实例中设计缓冲的异步场景，这可以大大减少分配的数量并显著地提升性能。" class="headerlink" title="例如我们计划建立一个 ValueTask 结构类型的数据。建立它是为了防止异步运行的结果在等待时已可用的情境下，对 Task 进行分配。对于许多实例中设计缓冲的异步场景，这可以大大减少分配的数量并显著地提升性能。"></a>例如我们计划建立一个 ValueTask<t> 结构类型的数据。建立它是为了防止异步运行的结果在等待时已可用的情境下，对 Task<t> 进行分配。对于许多实例中设计缓冲的异步场景，这可以大大减少分配的数量并显著地提升性能。</t></t></h3><h3 id="Note：异步返回类型尚未在-Preview-4-中提供。"><a href="#Note：异步返回类型尚未在-Preview-4-中提供。" class="headerlink" title="Note：异步返回类型尚未在 Preview 4 中提供。"></a>Note：异步返回类型尚未在 Preview 4 中提供。</h3><h3 id="更多的-expression-bodied-成员："><a href="#更多的-expression-bodied-成员：" class="headerlink" title="更多的 expression bodied 成员："></a>更多的 expression bodied 成员：</h3><h3 id="expression-bodied-的方法和属性是对-C-6-0-的巨大提升。C-7-0-为-expression-bodied-事件列表增加了访问器，结构器和终结器。"><a href="#expression-bodied-的方法和属性是对-C-6-0-的巨大提升。C-7-0-为-expression-bodied-事件列表增加了访问器，结构器和终结器。" class="headerlink" title="expression bodied 的方法和属性是对 C# 6.0 的巨大提升。C# 7.0 为 expression bodied 事件列表增加了访问器，结构器和终结器。"></a>expression bodied 的方法和属性是对 C# 6.0 的巨大提升。C# 7.0 为 expression bodied 事件列表增加了访问器，结构器和终结器。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Person</div><div class="line">&#123;  </div><div class="line"> private static ConcurrentDictionary&lt;int, string&gt; names = new ConcurrentDictionary&lt;int, string&gt;();  </div><div class="line"></div><div class="line"> private int id = GetId(); </div><div class="line">    public Person(string name) =&gt; names.TryAdd(id, name); // constructors</div><div class="line">    ~Person() =&gt; names.TryRemove(id, out *);              // destructors</div><div class="line">    public string Name</div><div class="line">    &#123;        get =&gt; names[id];                                 // getters</div><div class="line">        set =&gt; names[id] = value;                         // setters    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Note：这些额外增加的-expression-bodied-的成员尚未在-Preview-4-中提供。"><a href="#Note：这些额外增加的-expression-bodied-的成员尚未在-Preview-4-中提供。" class="headerlink" title="Note：这些额外增加的 expression bodied 的成员尚未在 Preview 4 中提供。"></a>Note：这些额外增加的 expression bodied 的成员尚未在 Preview 4 中提供。</h3><h3 id="这是社区共享的示例，而不是-Microsoft-C-编译团队提供的，还是开源的！"><a href="#这是社区共享的示例，而不是-Microsoft-C-编译团队提供的，还是开源的！" class="headerlink" title="这是社区共享的示例，而不是 Microsoft C# 编译团队提供的，还是开源的！"></a>这是社区共享的示例，而不是 Microsoft C# 编译团队提供的，还是开源的！</h3><h2 id="Throw-表达式"><a href="#Throw-表达式" class="headerlink" title="Throw 表达式"></a>Throw 表达式</h2><h3 id="在表达式中间抛出一个异常是很容易的：只需为自己的代码调用一个方法！但在-C＃7-0-中，我们允许在任意地方抛出一个表达式："><a href="#在表达式中间抛出一个异常是很容易的：只需为自己的代码调用一个方法！但在-C＃7-0-中，我们允许在任意地方抛出一个表达式：" class="headerlink" title="在表达式中间抛出一个异常是很容易的：只需为自己的代码调用一个方法！但在 C＃7.0 中，我们允许在任意地方抛出一个表达式："></a>在表达式中间抛出一个异常是很容易的：只需为自己的代码调用一个方法！但在 C＃7.0 中，我们允许在任意地方抛出一个表达式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Person</div><div class="line">&#123;  </div><div class="line"> public string Name &#123; get; &#125;    </div><div class="line">public Person(string name) =&gt; Name = name ?? throw new ArgumentNullException(name);  </div><div class="line"></div><div class="line"> public string GetFirstName()</div><div class="line">            &#123;        </div><div class="line">var parts = Name.Split(&quot; &quot;);  </div><div class="line">     return (parts.Length &gt; 0) ? parts[0] : throw new InvalidOperationException(&quot;No name!&quot;);</div><div class="line">             &#125;    </div><div class="line"></div><div class="line">public string GetLastName() =&gt; throw new NotImplementedException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Note：Throw-表达式尚未在Preview-4中提供。"><a href="#Note：Throw-表达式尚未在Preview-4中提供。" class="headerlink" title="Note：Throw 表达式尚未在Preview 4中提供。"></a>Note：Throw 表达式尚未在Preview 4中提供。</h3></div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/AliPayQR.png&amp;GitHub=https://github.com/Meowv&amp;BTCQR=undefined&amp;BTCKEY=undefined&amp;PayPal=undefined" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/C/">C#</a></div><div class="post-nav"><a href="/2017/01/04/2016-year-end-summary/" class="pre">2016年终总结</a><a href="/2016/05/18/internship-experience/" class="next">武汉路博特工程科技有限公司实习“满月”工作感受</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=1.0.0"><script src="/js/gitment.browser.js?v=1.0.0"></script><script>var gitment = new Gitment({
  owner: 'Meowv',
  repo: 'meowv.github.io',
  oauth: {
    client_id: '8b9d5a517ebad5add0cc',
    client_secret: '61ca179ff1d9c8aedd440e95521efd7240453d8b',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://xj8c.cc"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/诗文/" style="font-size: 15px;">诗文</a> <a href="/tags/CEAC/" style="font-size: 15px;">CEAC</a> <a href="/tags/office2010/" style="font-size: 15px;">office2010</a> <a href="/tags/绿色软件/" style="font-size: 15px;">绿色软件</a> <a href="/tags/HtmlAgilityPack/" style="font-size: 15px;">HtmlAgilityPack</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/ReactNative/" style="font-size: 15px;">ReactNative</a> <a href="/tags/Regex/" style="font-size: 15px;">Regex</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/SqlServer/" style="font-size: 15px;">SqlServer</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/今日头条/" style="font-size: 15px;">今日头条</a> <a href="/tags/Newtonsoft-Json/" style="font-size: 15px;">Newtonsoft.Json</a> <a href="/tags/知乎/" style="font-size: 15px;">知乎</a> <a href="/tags/win10/" style="font-size: 15px;">win10</a> <a href="/tags/微软/" style="font-size: 15px;">微软</a> <a href="/tags/春天/" style="font-size: 15px;">春天</a> <a href="/tags/Photoshop/" style="font-size: 15px;">Photoshop</a> <a href="/tags/ASP-NET/" style="font-size: 15px;">ASP.NET</a> <a href="/tags/技术教程/" style="font-size: 15px;">技术教程</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/软件测试/" style="font-size: 15px;">软件测试</a> <a href="/tags/互联网/" style="font-size: 15px;">互联网</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/年终总结/" style="font-size: 15px;">年终总结</a> <a href="/tags/计算机基础/" style="font-size: 15px;">计算机基础</a> <a href="/tags/进制转换/" style="font-size: 15px;">进制转换</a> <a href="/tags/get/" style="font-size: 15px;">get</a> <a href="/tags/post/" style="font-size: 15px;">post</a> <a href="/tags/毕业答辩/" style="font-size: 15px;">毕业答辩</a> <a href="/tags/计算机一级/" style="font-size: 15px;">计算机一级</a> <a href="/tags/IT/" style="font-size: 15px;">IT</a> <a href="/tags/实习感受/" style="font-size: 15px;">实习感受</a> <a href="/tags/逆袭/" style="font-size: 15px;">逆袭</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a> <a href="/tags/小说/" style="font-size: 15px;">小说</a> <a href="/tags/程序员/" style="font-size: 15px;">程序员</a> <a href="/tags/Visual-Studio/" style="font-size: 15px;">Visual Studio</a> <a href="/tags/三层架构/" style="font-size: 15px;">三层架构</a> <a href="/tags/琅琊榜/" style="font-size: 15px;">琅琊榜</a> <a href="/tags/手机/" style="font-size: 15px;">手机</a> <a href="/tags/win7/" style="font-size: 15px;">win7</a> <a href="/tags/快捷键/" style="font-size: 15px;">快捷键</a> <a href="/tags/命令行/" style="font-size: 15px;">命令行</a> <a href="/tags/原版系统/" style="font-size: 15px;">原版系统</a> <a href="/tags/xml/" style="font-size: 15px;">xml</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/黑客/" style="font-size: 15px;">黑客</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/Regex-chinese-english-comparison-table/">正则表达式术语中英文对照表</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/12/Regex-cheat-sheet/">正则表达式速查表</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/12/Regex-7/">正则表达式编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/12/Regex-6/">正则表达式的构建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/11/Regex-5/">正则表达式的拆分</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/11/Regex-4/">正则表达式回溯法原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/10/Regex-3/">正则表达式括号的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/Regex-2/">正则表达式位置匹配攻略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/28/Regex-1/">正则表达式字符匹配攻略</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/ToutiaoNews/">今日头条全站新闻文章数据爬取</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://meowv.com/" title="喵呜网" target="_blank">喵呜网</a><ul></ul><a href="http://v.xj8c.cc/" title="VIP电影在线播放" target="_blank">VIP电影在线播放</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2015 - 2017 <a href="/." rel="nofollow">当然我在瞎扯.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>