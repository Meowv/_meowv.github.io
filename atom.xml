<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当然我在瞎扯</title>
  <subtitle>生命不息，奋斗不止</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xj8c.cc/"/>
  <updated>2017-10-13T01:44:09.530Z</updated>
  <id>http://xj8c.cc/</id>
  
  <author>
    <name>阿星Plus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式术语中英文对照表</title>
    <link href="http://xj8c.cc/2017/10/13/Regex-chinese-english-comparison-table/"/>
    <id>http://xj8c.cc/2017/10/13/Regex-chinese-english-comparison-table/</id>
    <published>2017-10-13T01:37:20.000Z</published>
    <updated>2017-10-13T01:44:09.530Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">术语中英文对照表</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">正则表达式</td>
<td style="text-align:left">regular expressions</td>
</tr>
<tr>
<td style="text-align:left">字符组</td>
<td style="text-align:left">character classes</td>
</tr>
<tr>
<td style="text-align:left">反义字符组</td>
<td style="text-align:left">negated character classes</td>
</tr>
<tr>
<td style="text-align:left">范围表达式法</td>
<td style="text-align:left">range expressions</td>
</tr>
<tr>
<td style="text-align:left">元字符</td>
<td style="text-align:left">metacharacters</td>
</tr>
<tr>
<td style="text-align:left">通配符</td>
<td style="text-align:left">wildcard character</td>
</tr>
<tr>
<td style="text-align:left">换行符</td>
<td style="text-align:left">newline charactor</td>
</tr>
<tr>
<td style="text-align:left">回车符</td>
<td style="text-align:left">carriage return character</td>
</tr>
<tr>
<td style="text-align:left">水平制表符</td>
<td style="text-align:left">tab character</td>
</tr>
<tr>
<td style="text-align:left">垂直制表符</td>
<td style="text-align:left">vertical tab charecter</td>
</tr>
<tr>
<td style="text-align:left">换页符</td>
<td style="text-align:left">form feed character</td>
</tr>
<tr>
<td style="text-align:left">空白符</td>
<td style="text-align:left">whitespace</td>
</tr>
<tr>
<td style="text-align:left">段终止符</td>
<td style="text-align:left">paragraph terminator</td>
</tr>
<tr>
<td style="text-align:left">行终止符</td>
<td style="text-align:left">line terminator</td>
</tr>
<tr>
<td style="text-align:left">单词字符</td>
<td style="text-align:left">word characters</td>
</tr>
<tr>
<td style="text-align:left">非单词字符</td>
<td style="text-align:left">non-word characters</td>
</tr>
<tr>
<td style="text-align:left">数字字符</td>
<td style="text-align:left">digits</td>
</tr>
<tr>
<td style="text-align:left">非数字字符</td>
<td style="text-align:left">non-digits</td>
</tr>
<tr>
<td style="text-align:left">字母数字字符</td>
<td style="text-align:left">alphanumeric characters</td>
</tr>
<tr>
<td style="text-align:left">量词</td>
<td style="text-align:left">quantifiers</td>
</tr>
<tr>
<td style="text-align:left">贪婪量词</td>
<td style="text-align:left">greedy quantifiers</td>
</tr>
<tr>
<td style="text-align:left">惰性量词</td>
<td style="text-align:left">lazy quantifiers</td>
</tr>
<tr>
<td style="text-align:left">位置</td>
<td style="text-align:left">positions</td>
</tr>
<tr>
<td style="text-align:left">锚</td>
<td style="text-align:left">anchors</td>
</tr>
<tr>
<td style="text-align:left">行开头</td>
<td style="text-align:left">beginning of a line</td>
</tr>
<tr>
<td style="text-align:left">行结尾</td>
<td style="text-align:left">end of a line</td>
</tr>
<tr>
<td style="text-align:left">单词边界</td>
<td style="text-align:left">word boundaries</td>
</tr>
<tr>
<td style="text-align:left">非单词边界</td>
<td style="text-align:left">non-word boundaries</td>
</tr>
<tr>
<td style="text-align:left">向前查找</td>
<td style="text-align:left">lookahead</td>
</tr>
<tr>
<td style="text-align:left">正向向前查找</td>
<td style="text-align:left">positive lookahead</td>
</tr>
<tr>
<td style="text-align:left">负向向前查找</td>
<td style="text-align:left">negative lookahead</td>
</tr>
<tr>
<td style="text-align:left">向后查找</td>
<td style="text-align:left">lookbehind</td>
</tr>
<tr>
<td style="text-align:left">正向向后查找</td>
<td style="text-align:left">positive lookbehind</td>
</tr>
<tr>
<td style="text-align:left">负向向后查找</td>
<td style="text-align:left">negative lookbehind</td>
</tr>
<tr>
<td style="text-align:left">分组</td>
<td style="text-align:left">groups</td>
</tr>
<tr>
<td style="text-align:left">捕获分组</td>
<td style="text-align:left">capturing groups</td>
</tr>
<tr>
<td style="text-align:left">非捕获分组</td>
<td style="text-align:left">non-capturing groups</td>
</tr>
<tr>
<td style="text-align:left">分支结构</td>
<td style="text-align:left">alternations</td>
</tr>
<tr>
<td style="text-align:left">反向引用</td>
<td style="text-align:left">back references</td>
</tr>
<tr>
<td style="text-align:left">回溯</td>
<td style="text-align:left">backtracks</td>
</tr>
<tr>
<td style="text-align:left">运算符</td>
<td style="text-align:left">operators</td>
</tr>
<tr>
<td style="text-align:left">优先级</td>
<td style="text-align:left">priority level</td>
</tr>
<tr>
<td style="text-align:left">修饰符</td>
<td style="text-align:left">flags</td>
</tr>
<tr>
<td style="text-align:left">全局匹配修饰符</td>
<td style="text-align:left">global flag</td>
</tr>
<tr>
<td style="text-align:left">忽略大小写修饰符</td>
<td style="text-align:left">ingnoreCase flag</td>
</tr>
<tr>
<td style="text-align:left">多行匹配修饰符</td>
<td style="text-align:left">multiline flag</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;术语中英文对照表&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式速查表</title>
    <link href="http://xj8c.cc/2017/10/12/Regex-cheat-sheet/"/>
    <id>http://xj8c.cc/2017/10/12/Regex-cheat-sheet/</id>
    <published>2017-10-12T10:01:07.000Z</published>
    <updated>2017-10-13T01:51:16.815Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">字面量</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">模式</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left">字母、数字</td>
<td style="text-align:left">匹配字面量本身。比如 <code>/f/</code>，匹配字母 <code>&quot;f&quot;</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>\0</code></td>
<td style="text-align:left">匹配 NUL 字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code></td>
<td style="text-align:left">匹配水平制表符。</td>
</tr>
<tr>
<td style="text-align:left"><code>\v</code></td>
<td style="text-align:left">匹配垂直制表符。</td>
</tr>
<tr>
<td style="text-align:left"><code>\n</code></td>
<td style="text-align:left">匹配换行符。</td>
</tr>
<tr>
<td style="text-align:left"><code>\r</code></td>
<td style="text-align:left">匹配回车符。</td>
</tr>
<tr>
<td style="text-align:left"><code>\f</code></td>
<td style="text-align:left">匹配换页符。</td>
</tr>
<tr>
<td style="text-align:left"><code>\xnn</code></td>
<td style="text-align:left">匹配拉丁字符。比如 <code>\xOA</code> 等价于 <code>\n</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>\uxxxx</code></td>
<td style="text-align:left">匹配 Unicode 字符。比如 <code>\u2028</code> 匹配行终止符，<code>\u2029</code> 匹配段终止符。</td>
</tr>
<tr>
<td style="text-align:left"><code>\cX</code></td>
<td style="text-align:left">匹配 ctrl+X。比如 <code>\cI</code> 匹配 ctrl+I，等价于 <code>\t</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>[\b]</code></td>
<td style="text-align:left">匹配 Backspace 键（特殊记忆）。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:left">字符组</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">模式</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left"><code>[abc]</code></td>
<td style="text-align:left">匹配 <code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code> 其中任何一个字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>[a-d1-4]</code></td>
<td style="text-align:left">匹配 <code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code>、<code>&quot;d&quot;</code>、<code>&quot;1&quot;</code>、<code>&quot;2&quot;</code>、<code>&quot;3&quot;</code>、<code>&quot;4&quot;</code> 其中任何一个字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>[^abc]</code></td>
<td style="text-align:left">匹配除了 <code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code> 之外的任何一个字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>[^a-d1-4]</code></td>
<td style="text-align:left">匹配除了 <code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code>、<code>&quot;d&quot;</code>、<code>&quot;1&quot;</code>、<code>&quot;2&quot;</code>、<code>&quot;3&quot;</code>、<code>&quot;4&quot;</code> 之外的任何一个字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">通配符，匹配除了少数字符（<code>\n</code>）之外的任意字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">匹配数字，等价于 [0-9]。</td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left">匹配非数字，等价于 [^0-9]。</td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">匹配单词字符，等价于 <code>[a-zA-Z0-9_]</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left">匹配非单词字符，等价于 <code>[^a-zA-Z0-9_]</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">匹配空白符，等价于 [ \t\v\n\r\f]。</td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left">匹配非空白符，等价于 <code>[^ \t\v\n\r\f]</code>。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">量词</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">模式</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,m}</code></td>
<td style="text-align:left">连续出现 n 到 m 次。贪婪模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,}</code></td>
<td style="text-align:left">至少连续出现 n 次。贪婪模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>{n}</code></td>
<td style="text-align:left">连续出现 n 次。贪婪模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">等价于 <code>{0,1}</code>。贪婪模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">等价于 <code>{1,}</code>。贪婪模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">等价于 <code>{0,}</code>。贪婪模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,m}?</code></td>
<td style="text-align:left">连续出现 n 到 m 次。惰性模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,}?</code></td>
<td style="text-align:left">至少连续出现 n 次。惰性模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>{n}?</code></td>
<td style="text-align:left">连续出现 n 次。惰性模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>??</code></td>
<td style="text-align:left">等价于 <code>{0,1}?</code>。惰性模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>+?</code></td>
<td style="text-align:left">等价于 <code>{1,}?</code>。惰性模式。</td>
</tr>
<tr>
<td style="text-align:left"><code>*?</code></td>
<td style="text-align:left">等价于 <code>{0,}?</code>。惰性模式。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">位置</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">模式</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">匹配开头的位置，当正则有修饰符 <code>m</code> 时，表示匹配行开头位置。</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">匹配结尾的位置，当正则有修饰符 <code>m</code> 时，表示匹配行结尾位置。</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">匹配单词边界，即，<code>\w</code> 与 <code>\W</code>、<code>^</code> 与 <code>\w</code>、<code>\w</code> 与 <code>$</code> 之间的位置。</td>
</tr>
<tr>
<td style="text-align:left"><code>\B</code></td>
<td style="text-align:left">匹配非单词边界，即，<code>\w</code> 与 <code>\w</code>、<code>\W</code> 与 <code>\W</code>、<code>^</code> 与 <code>\W</code>，<code>\W</code> 与 <code>$</code> 之间的位置。</td>
</tr>
<tr>
<td style="text-align:left"><code>(?=abc)</code></td>
<td style="text-align:left">匹配 <code>&quot;abc&quot;</code> 前面的位置，即此位置后面匹配 <code>&quot;abc&quot;</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>(?!abc)</code></td>
<td style="text-align:left">匹配非 <code>&quot;abc&quot;</code> 前面的位置，即此位置后面不匹配 <code>&quot;abc&quot;</code>。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">括号的作用</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">模式</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left"><code>(ab)</code></td>
<td style="text-align:left">捕获型分组。把 <code>&quot;ab&quot;</code> 当成一个整体，比如 <code>(ab)+</code> 表示 <code>&quot;ab&quot;</code> 至少连续出现一次。</td>
</tr>
<tr>
<td style="text-align:left"><code>(?:ab)</code></td>
<td style="text-align:left">非捕获型分组。与 <code>(ab)</code> 的区别是，它不捕获数据。</td>
</tr>
<tr>
<td style="text-align:left">(good&#124;nice)</td>
<td style="text-align:left">捕获型分支结构。匹配 <code>&quot;good&quot;</code> 或 <code>&quot;nice&quot;</code>。</td>
</tr>
<tr>
<td style="text-align:left">(?:good&#124;nice)</td>
<td style="text-align:left">非捕获型分支结构。与 (good&#124;nice) 的区别是，它不捕获数据。</td>
</tr>
<tr>
<td style="text-align:left"><code>\num</code></td>
<td style="text-align:left">反向引用。比如 <code>\2</code>，表示引用的是第二个括号里的捕获的数据。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">修饰符</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">符号</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left"><code>g</code></td>
<td style="text-align:left">全局匹配，找到所有满足匹配的子串。</td>
</tr>
<tr>
<td style="text-align:left"><code>i</code></td>
<td style="text-align:left">匹配过程中，忽略英文字母大小写。</td>
</tr>
<tr>
<td style="text-align:left"><code>m</code></td>
<td style="text-align:left">多行匹配，把 <code>^</code> 和 <code>$</code> 变成行开头和行结尾。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">String相关实例方法</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">方法作用说明</td>
</tr>
<tr>
<td style="text-align:left"><code>search</code></td>
<td style="text-align:left">返回正则匹配到的第一个子串在目标字符串中的下标位置。</td>
</tr>
<tr>
<td style="text-align:left"><code>split</code></td>
<td style="text-align:left">以正则匹配到的子串，对目标字符串进行切分。返回一个数组。</td>
</tr>
<tr>
<td style="text-align:left"><code>match</code></td>
<td style="text-align:left">对目标字符串执行正则匹配操作，返回的匹配结果数组中包含具体的匹配信息。</td>
</tr>
<tr>
<td style="text-align:left"><code>replace</code></td>
<td style="text-align:left">对目标字符串进行替换操作。正则是其第一个参数。返回替换后的字符串。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">replace第二个参数中的特殊字符</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字符</td>
<td style="text-align:left">说明</td>
</tr>
<tr>
<td style="text-align:left"><code>$1,$2,…,$99</code></td>
<td style="text-align:left">匹配第 1-99 个分组里捕获的文本</td>
</tr>
<tr>
<td style="text-align:left"><code>$&amp;</code></td>
<td style="text-align:left">匹配到的子串文本</td>
</tr>
<tr>
<td style="text-align:left">$`</td>
<td style="text-align:left">匹配到的子串的左边文本</td>
</tr>
<tr>
<td style="text-align:left"><code>$&#39;</code></td>
<td style="text-align:left">匹配到的子串的右边文本</td>
</tr>
<tr>
<td style="text-align:left"><code>$$</code></td>
<td style="text-align:left">美元符号</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">RegExp相关实例方法</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">方法作用说明</td>
</tr>
<tr>
<td style="text-align:left"><code>test</code></td>
<td style="text-align:left">判断目标字符串中是否有满足正则匹配的子串。返回布尔值。</td>
</tr>
<tr>
<td style="text-align:left"><code>exec</code></td>
<td style="text-align:left">比 <code>match</code> 更强大的正则匹配操作。返回结果与 <code>match</code> 一致。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">RegExp静态属性</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:left">方法作用说明</td>
</tr>
<tr>
<td style="text-align:left"><code>$1,…,$9</code></td>
<td style="text-align:left">最近一次第 1-9 个分组捕获的数据。</td>
</tr>
<tr>
<td style="text-align:left"><code>input</code></td>
<td style="text-align:left">最近一次目标字符串，可以简写成 <code>$_</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>lastMatch</code></td>
<td style="text-align:left">最近一次匹配的文本，可以简写成 <code>$&amp;</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>lastParen</code></td>
<td style="text-align:left">最近一次捕获的文本，可以简写成 <code>$+</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>leftContext</code></td>
<td style="text-align:left">目标字符串中 lastMatch 之前的文本，可以简写成 $`。</td>
</tr>
<tr>
<td style="text-align:left"><code>rightContext</code></td>
<td style="text-align:left">目标字符串中 lastMatch 之后的文本，可以简写成 <code>$&#39;</code>。</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;字面量&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;说明&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;字母、数字&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配字面量本身。比如 &lt;code&gt;/f/&lt;/code&gt;，匹配字母 &lt;code&gt;&amp;quot;f&amp;quot;&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\0&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配 NUL 字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\t&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配水平制表符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配垂直制表符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配换行符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\r&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配回车符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\f&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配换页符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\xnn&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配拉丁字符。比如 &lt;code&gt;\xOA&lt;/code&gt; 等价于 &lt;code&gt;\n&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\uxxxx&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配 Unicode 字符。比如 &lt;code&gt;\u2028&lt;/code&gt; 匹配行终止符，&lt;code&gt;\u2029&lt;/code&gt; 匹配段终止符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;\cX&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配 ctrl+X。比如 &lt;code&gt;\cI&lt;/code&gt; 匹配 ctrl+I，等价于 &lt;code&gt;\t&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;code&gt;[\b]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;匹配 Backspace 键（特殊记忆）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式编程</title>
    <link href="http://xj8c.cc/2017/10/12/Regex-7/"/>
    <id>http://xj8c.cc/2017/10/12/Regex-7/</id>
    <published>2017-10-12T05:30:33.000Z</published>
    <updated>2017-10-12T09:56:57.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七章-正则表达式编程"><a href="#第七章-正则表达式编程" class="headerlink" title="第七章 正则表达式编程"></a>第七章 正则表达式编程</h2><p>什么叫知识，能指导我们实践的东西才叫知识。</p>
<p>学习一样东西，如果不能使用，最多只能算作纸上谈兵。正则表达式的学习，也不例外。</p>
<p>掌握了正则表达式的语法后，下一步，也是关键的一步，就是在真实世界中使用它。</p>
<p>那么如何使用正则表达式呢？有哪些关键的点呢？本章就解决这个问题。</p>
<p>内容包括：</p>
<ul>
<li><a href="#正则表达式的四种操作">正则表达式的四种操作</a></li>
<li><a href="#相关 API 注意要点">相关 API 注意要点</a></li>
<li><a href="#真实案例">真实案例</a></li>
</ul>
<a id="more"></a>
<h3 id="正则表达式的四种操作">正则表达式的四种操作</h3>

<p>正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。</p>
<p>有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。</p>
<p>进行任何相关操作，也需要宿主引擎相关 API 的配合使用。当然，在 JavaScript 中，相关 API 也不多。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是正则表达式最直接的应用，比如表单验证。</p>
<p>在说验证之前，先要说清楚匹配是什么概念。</p>
<p>所谓匹配，就是看目标字符串里是否有满足匹配的子串。因此，“匹配”的本质就是“查找”。</p>
<p>有没有匹配，是不是匹配上，判断是否的操作，即称为“验证”。</p>
<p>这里举一个例子，来看看如何使用相关 API 进行验证操作的。</p>
<p>比如，判断一个字符串中是否有数字。</p>
<p>使用 <code>search</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"abc123"</span>;</div><div class="line"><span class="built_in">console</span>.log( !!~string.search(regex) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>使用 <code>test</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"abc123"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>使用 <code>match</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"abc123"</span>;</div><div class="line"><span class="built_in">console</span>.log( !!string.match(regex) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>使用 <code>exec</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"abc123"</span>;</div><div class="line"><span class="built_in">console</span>.log( !!regex.exec(string) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>其中，最常用的是 <code>test</code>。</p>
<h4 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h4><p>匹配上了，我们就可以进行一些操作，比如切分。</p>
<p>所谓“切分”，就是把目标字符串，切成一段一段的。在 JavaScript 中使用的是 <code>split</code>。</p>
<p>比如，目标字符串是 <code>&quot;html,css,javascript&quot;</code>，按逗号来切分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/,/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"html,css,javascript"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.split(regex) );</div><div class="line"><span class="comment">// =&gt; ["html", "css", "javascript"]</span></div></pre></td></tr></table></figure>
<p>又比如，如下的日期格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017/06/26</div><div class="line">2017.06.26</div><div class="line">2017-06-26</div></pre></td></tr></table></figure>
<p>可以使用 <code>split</code> “切出”年月日：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\D/</span>;</div><div class="line"><span class="built_in">console</span>.log( <span class="string">"2017/06/26"</span>.split(regex) );</div><div class="line"><span class="built_in">console</span>.log( <span class="string">"2017.06.26"</span>.split(regex) );</div><div class="line"><span class="built_in">console</span>.log( <span class="string">"2017-06-26"</span>.split(regex) );</div><div class="line"><span class="comment">// =&gt; ["2017", "06", "26"]</span></div><div class="line"><span class="comment">// =&gt; ["2017", "06", "26"]</span></div><div class="line"><span class="comment">// =&gt; ["2017", "06", "26"]</span></div></pre></td></tr></table></figure>
<h4 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h4><p>虽然整体匹配上了，但有时需要提取部分匹配的数据。</p>
<p>此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关 API。</p>
<p>这里，还是以日期为例，提取出年月日。注意下面正则中的括号：</p>
<p>使用 <code>match</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt;["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"]</span></div></pre></td></tr></table></figure>
<p>使用 <code>exec</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.exec(string) );</div><div class="line"><span class="comment">// =&gt;["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"]</span></div></pre></td></tr></table></figure>
<p>使用 <code>test</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</div><div class="line">regex.test(string);</div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">1</span>, <span class="built_in">RegExp</span>.$<span class="number">2</span>, <span class="built_in">RegExp</span>.$<span class="number">3</span> );</div><div class="line"><span class="comment">// =&gt; "2017" "06" "26"</span></div></pre></td></tr></table></figure>
<p>使用 <code>search</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</div><div class="line">string.search(regex);</div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">1</span>, <span class="built_in">RegExp</span>.$<span class="number">2</span>, <span class="built_in">RegExp</span>.$<span class="number">3</span> );</div><div class="line"><span class="comment">// =&gt; "2017" "06" "26"</span></div></pre></td></tr></table></figure>
<p>使用 <code>replace</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</div><div class="line"><span class="keyword">var</span> date = [];</div><div class="line">string.replace(regex, <span class="function"><span class="keyword">function</span> (<span class="params">match, year, month, day</span>) </span>&#123;</div><div class="line"> date.push(year, month, day);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(date);</div><div class="line"><span class="comment">// =&gt; ["2017", "06", "26"]</span></div></pre></td></tr></table></figure>
<p>其中，最常用的是 <code>match</code>。</p>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>找，往往不是目的，通常下一步是为了替换。在 JavaScript 中，使用 <code>replace</code> 进行替换。</p>
<p>比如把日期格式，从 <code>yyyy-mm-dd</code> 替换成 <code>yyyy/mm/dd</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-26"</span>;</div><div class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>( string.replace(<span class="regexp">/-/g</span>, <span class="string">"/"</span>) );</div><div class="line"><span class="built_in">console</span>.log( today );</div><div class="line"><span class="comment">// =&gt; Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间)</span></div></pre></td></tr></table></figure>
<p>这里只是简单地应用了一下 <code>replace</code>。但，<code>replace</code> 方法很是强大的，是需要重点掌握的。</p>
<h3 id="相关 API 注意要点">相关 API 注意要点</h3>

<p>从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String#search</div><div class="line">String#split</div><div class="line">String#match</div><div class="line">String#replace</div><div class="line">RegExp#test</div><div class="line">RegExp#exec</div></pre></td></tr></table></figure>
<p>本章不打算详细地讲解它们的方方面面细节，具体可以参考《JavaScript 权威指南》的第三部分。本章重点列出一些容易忽视的地方，以飨读者。</p>
<h4 id="search-和-match-的参数问题"><a href="#search-和-match-的参数问题" class="headerlink" title="search 和 match 的参数问题"></a><code>search</code> 和 <code>match</code> 的参数问题</h4><p>我们知道字符串实例的那 4 个方法参数都支持正则和字符串。</p>
<p>但 <code>search</code> 和 <code>match</code>，会把字符串转换为正则的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"2017.06.27"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.search(<span class="string">"."</span>) );</div><div class="line"><span class="comment">// =&gt; 0</span></div><div class="line"><span class="comment">//需要修改成下列形式之一</span></div><div class="line"><span class="built_in">console</span>.log( string.search(<span class="string">"\\."</span>) );</div><div class="line"><span class="built_in">console</span>.log( string.search(<span class="regexp">/\./</span>) );</div><div class="line"><span class="comment">// =&gt; 4</span></div><div class="line"><span class="comment">// =&gt; 4</span></div><div class="line"><span class="built_in">console</span>.log( string.match(<span class="string">"."</span>) );</div><div class="line"><span class="comment">// =&gt; ["2", index: 0, input: "2017.06.27"]</span></div><div class="line"><span class="comment">//需要修改成下列形式之一</span></div><div class="line"><span class="built_in">console</span>.log( string.match(<span class="string">"\\."</span>) );</div><div class="line"><span class="built_in">console</span>.log( string.match(<span class="regexp">/\./</span>) );</div><div class="line"><span class="comment">// =&gt; [".", index: 4, input: "2017.06.27"]</span></div><div class="line"><span class="comment">// =&gt; [".", index: 4, input: "2017.06.27"]</span></div><div class="line"><span class="built_in">console</span>.log( string.split(<span class="string">"."</span>) );</div><div class="line"><span class="comment">// =&gt; ["2017", "06", "27"]</span></div><div class="line"><span class="built_in">console</span>.log( string.replace(<span class="string">"."</span>, <span class="string">"/"</span>) );</div><div class="line"><span class="comment">// =&gt; "2017/06.27"</span></div></pre></td></tr></table></figure>
<h4 id="match-返回结果的格式问题"><a href="#match-返回结果的格式问题" class="headerlink" title="match 返回结果的格式问题"></a><code>match</code> 返回结果的格式问题</h4><p><code>match</code> 返回结果的格式，与正则对象是否有修饰符 <code>g</code> 有关。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"2017.06.27"</span>;</div><div class="line"><span class="keyword">var</span> regex1 = <span class="regexp">/\b(\d+)\b/</span>;</div><div class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/\b(\d+)\b/g</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex1) );</div><div class="line"><span class="built_in">console</span>.log( string.match(regex2) );</div><div class="line"><span class="comment">// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"]</span></div><div class="line"><span class="comment">// =&gt; ["2017", "06", "27"]</span></div></pre></td></tr></table></figure>
<p>没有 <code>g</code>，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然<br>后是整体匹配的第一个下标，最后是输入的目标字符串。</p>
<p>有 <code>g</code>，返回的是所有匹配的内容。</p>
<p>当没有匹配时，不管有无 <code>g</code>，都返回 <code>null</code>。</p>
<h4 id="exec-比-match-更强大"><a href="#exec-比-match-更强大" class="headerlink" title="exec 比 match 更强大"></a><code>exec</code> 比 <code>match</code> 更强大</h4><p>当正则没有 <code>g</code> 时，使用 <code>match</code> 返回的信息比较多。但是有 <code>g</code> 后，就没有关键的信息 <code>index</code> 了。</p>
<p>而 <code>exec</code> 方法就能解决这个问题，它能接着上一次匹配后继续匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"2017.06.27"</span>;</div><div class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/\b(\d+)\b/g</span>;</div><div class="line"><span class="built_in">console</span>.log( regex2.exec(string) );</div><div class="line"><span class="built_in">console</span>.log( regex2.lastIndex);</div><div class="line"><span class="built_in">console</span>.log( regex2.exec(string) );</div><div class="line"><span class="built_in">console</span>.log( regex2.lastIndex);</div><div class="line"><span class="built_in">console</span>.log( regex2.exec(string) );</div><div class="line"><span class="built_in">console</span>.log( regex2.lastIndex);</div><div class="line"><span class="built_in">console</span>.log( regex2.exec(string) );</div><div class="line"><span class="built_in">console</span>.log( regex2.lastIndex);</div><div class="line"><span class="comment">// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"]</span></div><div class="line"><span class="comment">// =&gt; 4</span></div><div class="line"><span class="comment">// =&gt; ["06", "06", index: 5, input: "2017.06.27"]</span></div><div class="line"><span class="comment">// =&gt; 7</span></div><div class="line"><span class="comment">// =&gt; ["27", "27", index: 8, input: "2017.06.27"]</span></div><div class="line"><span class="comment">// =&gt; 10</span></div><div class="line"><span class="comment">// =&gt; null</span></div><div class="line"><span class="comment">// =&gt; 0</span></div></pre></td></tr></table></figure>
<p>其中正则实例 <code>lastIndex</code> 属性，表示下一次匹配开始的位置。</p>
<p>比如第一次匹配了 <code>&quot;2017&quot;</code>，开始下标是 0，共 4 个字符，因此这次匹配结束的位置是 3，下一次开始匹配的位置是 4。</p>
<p>从上述代码看出，在使用 <code>exec</code> 时，经常需要配合使用 <code>while</code> 循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"2017.06.27"</span>;</div><div class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/\b(\d+)\b/g</span>;</div><div class="line"><span class="keyword">var</span> result;</div><div class="line"><span class="keyword">while</span> ( result = regex2.exec(string) ) &#123;</div><div class="line"> <span class="built_in">console</span>.log( result, regex2.lastIndex );</div><div class="line">&#125;</div><div class="line"><span class="comment">// =&gt; ["2017", "2017", index: 0, input: "2017.06.27"] 4</span></div><div class="line"><span class="comment">// =&gt; ["06", "06", index: 5, input: "2017.06.27"] 7</span></div><div class="line"><span class="comment">// =&gt; ["27", "27", index: 8, input: "2017.06.27"] 10</span></div></pre></td></tr></table></figure>
<h4 id="修饰符-g，对-exex-和-test-的影响"><a href="#修饰符-g，对-exex-和-test-的影响" class="headerlink" title="修饰符 g，对 exex 和 test 的影响"></a>修饰符 <code>g</code>，对 <code>exex</code> 和 <code>test</code> 的影响</h4><p>上面提到了正则实例的 <code>lastIndex</code> 属性，表示尝试匹配时，从字符串的 <code>lastIndex</code> 位开始去匹配。</p>
<p>字符串的四个方法，每次匹配时，都是从 0 开始的，即 <code>lastIndex</code> 属性始终不变。</p>
<p>而正则实例的两个方法 <code>exec</code>、<code>test</code>，当正则是全局匹配时，每一次匹配完成后，都会修改 <code>lastIndex</code>。下面让我们以 <code>test</code> 为例，看看你是否会迷糊：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/a/g</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"a"</span>), regex.lastIndex );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"aba"</span>), regex.lastIndex );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"ababc"</span>), regex.lastIndex );</div><div class="line"><span class="comment">// =&gt; true 1</span></div><div class="line"><span class="comment">// =&gt; true 3</span></div><div class="line"><span class="comment">// =&gt; false 0</span></div></pre></td></tr></table></figure>
<p>注意上面代码中的第三次调用 test，因为这一次尝试匹配，开始从下标 <code>lastIndex</code>，即 3 位置处开始查找，自然就找不到了。</p>
<p>如果没有 <code>g</code>，自然都是从字符串第 0 个字符处开始尝试匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/a/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"a"</span>), regex.lastIndex );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"aba"</span>), regex.lastIndex );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"ababc"</span>), regex.lastIndex );</div><div class="line"><span class="comment">// =&gt; true 0</span></div><div class="line"><span class="comment">// =&gt; true 0</span></div><div class="line"><span class="comment">// =&gt; true 0</span></div></pre></td></tr></table></figure>
<h4 id="test-整体匹配时需要使用-和"><a href="#test-整体匹配时需要使用-和" class="headerlink" title="test 整体匹配时需要使用 ^ 和 $"></a><code>test</code> 整体匹配时需要使用 <code>^</code> 和 <code>$</code></h4><p>这个相对容易理解，因为 <code>test</code> 是看目标字符串中是否有子串匹配正则，即有部分匹配即可。</p>
<p>如果，要整体匹配，正则前后需要添加开头和结尾：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log( <span class="regexp">/123/</span>.test(<span class="string">"a123b"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="regexp">/^123$/</span>.test(<span class="string">"a123b"</span>) );</div><div class="line"><span class="comment">// =&gt; false</span></div><div class="line"><span class="built_in">console</span>.log( <span class="regexp">/^123$/</span>.test(<span class="string">"123"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<h4 id="split-相关注意事项"><a href="#split-相关注意事项" class="headerlink" title="split 相关注意事项"></a>split 相关注意事项</h4><p><code>split</code> 方法看起来不起眼，但要注意的地方有两个的。</p>
<p>第一，它可以有第二个参数，表示结果数组的最大长度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"html,css,javascript"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.split(<span class="regexp">/,/</span>, <span class="number">2</span>) );</div><div class="line"><span class="comment">// =&gt;["html", "css"]</span></div></pre></td></tr></table></figure>
<p>第二，正则使用分组时，结果数组中是包含分隔符的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"html,css,javascript"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.split(<span class="regexp">/(,)/</span>) );</div><div class="line"><span class="comment">// =&gt;["html", ",", "css", ",", "javascript"]</span></div></pre></td></tr></table></figure>
<h4 id="replace-是很强大的"><a href="#replace-是很强大的" class="headerlink" title="replace 是很强大的"></a><code>replace</code> 是很强大的</h4><p>《JavaScript 权威指南》认为 <code>exec</code> 是这 6 个 API 中最强大的，而我始终认为 <code>replace</code> 才是最强大的。因为它也能拿到该拿到的信息，然后可以假借替换之名，做些其他事情。</p>
<p>总体来说 <code>replace</code> 有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。</p>
<p>当第二个参数是字符串时，如下的字符有特殊的含义：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$1</code>,<code>$2</code>,…,<code>$99</code></td>
<td>匹配第 1-99个 分组里捕获的文本</td>
</tr>
<tr>
<td><code>$&amp;</code></td>
<td>匹配到的子串文本</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配到的子串的左边文本</td>
</tr>
<tr>
<td><code>$&#39;</code></td>
<td>匹配到的子串的右边文本</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>美元符号</td>
</tr>
</tbody>
</table>
<p>例如，把 <code>&quot;2,3,5&quot;</code>，变成 <code>&quot;5=2+3&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"2,3,5"</span>.replace(<span class="regexp">/(\d+),(\d+),(\d+)/</span>, <span class="string">"$3=$1+$2"</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "5=2+3"</span></div></pre></td></tr></table></figure>
<p>又例如，把 <code>&quot;2,3,5&quot;</code>，变成 <code>&quot;222,333,555&quot;</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"2,3,5"</span>.replace(<span class="regexp">/(\d+)/g</span>, <span class="string">"$&amp;$&amp;$&amp;"</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "222,333,555"</span></div></pre></td></tr></table></figure>
<p>再例如，把 <code>&quot;2+3=5&quot;</code>，变成 <code>&quot;2+3=2+3=5=5&quot;</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"2+3=5"</span>.replace(<span class="regexp">/=/</span>, <span class="string">"$&amp;$`$&amp;$'$&amp;"</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "2+3=2+3=5=5"</span></div></pre></td></tr></table></figure>
<p>我们对最后这个进行一下说明。要把 <code>&quot;2+3=5&quot;</code>，变成 <code>&quot;2+3=2+3=5=5&quot;</code>，其实就是想办法把 <code>=</code> 替换成<code>=2+3=5=</code>，其中，<code>$&amp;</code> 匹配的是 =， $` 匹配的是 <code>2+3</code>，$\’ 匹配的是 <code>5</code>。因此使用 “$&amp;$`$&amp;$’$&amp;” 便达成了目的。</p>
<p>当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"1234 2345 3456"</span>.replace(<span class="regexp">/(\d)\d&#123;2&#125;(\d)/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, $<span class="number">1</span>, $<span class="number">2</span>, index, input</span>) </span>&#123;</div><div class="line"> <span class="built_in">console</span>.log([match, $<span class="number">1</span>, $<span class="number">2</span>, index, input]);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// =&gt; ["1234", "1", "4", 0, "1234 2345 3456"]</span></div><div class="line"><span class="comment">// =&gt; ["2345", "2", "5", 5, "1234 2345 3456"]</span></div><div class="line"><span class="comment">// =&gt; ["3456", "3", "6", 10, "1234 2345 3456"]</span></div></pre></td></tr></table></figure>
<p>此时我们可以看到 <code>replace</code> 拿到的信息，并不比 <code>exec</code> 少。</p>
<h4 id="使用构造函数需要注意的问题"><a href="#使用构造函数需要注意的问题" class="headerlink" title="使用构造函数需要注意的问题"></a>使用构造函数需要注意的问题</h4><p>一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 <code>\</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-27 2017.06.27 2017/06/27"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\.|\/)\d&#123;2&#125;\1\d&#123;2&#125;/g</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["2017-06-27", "2017.06.27", "2017/06/27"]</span></div><div class="line">regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;"</span>, <span class="string">"g"</span>);</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["2017-06-27", "2017.06.27", "2017/06/27"]</span></div></pre></td></tr></table></figure>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>ES5 中修饰符，共 3 个：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>g</code></td>
<td>全局匹配，即找到所有匹配的，单词是 global。</td>
</tr>
<tr>
<td><code>i</code></td>
<td>忽略字母大小写，单词是 ingoreCase。</td>
</tr>
<tr>
<td><code>i</code></td>
<td>多行匹配，只影响 <code>^</code> 和 <code>$</code>，二者变成行的概念，即行开头和行结尾。单词是 multiline。</td>
</tr>
</tbody>
</table>
<p>当然正则对象也有相应的只读属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\w/img</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.global );</div><div class="line"><span class="built_in">console</span>.log( regex.ignoreCase );</div><div class="line"><span class="built_in">console</span>.log( regex.multiline );</div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<h4 id="source-属性"><a href="#source-属性" class="headerlink" title="source 属性"></a><code>source</code> 属性</h4><p>正则实例对象属性，除了 <code>global</code>、<code>ingnoreCase</code>、<code>multiline</code>、<code>lastIndex</code> 属性之外，还有一个 <code>source</code> 属性。</p>
<p>它什么时候有用呢？</p>
<p>比如，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> className = <span class="string">"high"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|\\s)"</span> + className + <span class="string">"(\\s|$)"</span>);</div><div class="line"><span class="built_in">console</span>.log( regex.source )</div><div class="line"><span class="comment">// =&gt; (^|\s)high(\s|$) 即字符串"(^|\\s)high(\\s|$)"</span></div></pre></td></tr></table></figure>
<h4 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h4><p>构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是 <code>$1</code>,…,<code>$9</code> 之外，还有几个不太常用的属性（有兼容性问题）：</p>
<table>
<thead>
<tr>
<th>静态属性</th>
<th>描述</th>
<th>简写形式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RegExp.input</code></td>
<td>最近一次目标字符串</td>
<td><code>RegExp[&quot;$_&quot;]</code></td>
</tr>
<tr>
<td><code>RegExp.lastMatch</code></td>
<td>最近一次匹配的文本</td>
<td><code>RegExp[&quot;$&amp;&quot;]</code></td>
</tr>
<tr>
<td><code>RegExp.lastParen</code></td>
<td>最近一次捕获的文本</td>
<td><code>RegExp[&quot;$+&quot;]</code></td>
</tr>
<tr>
<td><code>RegExp.leftContext</code></td>
<td>目标字符串中lastMatch之前的文本</td>
<td>RegExp[“$`”]</td>
</tr>
<tr>
<td><code>RegExp.rightContext</code></td>
<td>目标字符串中lastMatch之后的文本</td>
<td><code>RegExp[&quot;$&#39;&quot;]</code></td>
</tr>
</tbody>
</table>
<p>测试代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/([abc])(\d)/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"a1b2c3d4e5"</span>;</div><div class="line">string.match(regex);</div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.input );</div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>[<span class="string">"$_"</span>]);</div><div class="line"><span class="comment">// =&gt; "a1b2c3d4e5"</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.lastMatch );</div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>] );</div><div class="line"><span class="comment">// =&gt; "c3"</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.lastParen );</div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>[<span class="string">"$+"</span>] );</div><div class="line"><span class="comment">// =&gt; "3"</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.leftContext );</div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>[<span class="string">"$`"</span>] );</div><div class="line"><span class="comment">// =&gt; "a1b2"</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.rightContext );</div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>[<span class="string">"$'"</span>] );</div><div class="line"><span class="comment">// =&gt; "d4e5"</span></div></pre></td></tr></table></figure>
<h3 id="真实案例">真实案例</h3>

<h4 id="使用构造函数生成正则表达式"><a href="#使用构造函数生成正则表达式" class="headerlink" title="使用构造函数生成正则表达式"></a>使用构造函数生成正则表达式</h4><p>我们知道要优先使用字面量来创建正则，但有时正则表达式的主体是不确定的，此时可以使用构造函数来创建。模拟 <code>getElementsByClassName</code> 方法，就是很能说明该问题的一个例子。</p>
<p>这里 <code>getElementsByClassName</code> 函数的实现思路是：</p>
<ul>
<li>比如要获取 <code>className</code> 为 <code>&quot;high&quot;</code> 的 dom 元素；</li>
<li>首先生成一个正则：<code>/(^|\s)high(\s|$)/</code>,</li>
<li>然后再用其逐一验证页面上的所有dom元素的类名，拿到满足匹配的元素即可。</li>
</ul>
<p>代码如下(可以直接复制到本地查看运行效果)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"high"</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"high"</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>3333<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementsByClassName</span> (<span class="params">className</span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);</div><div class="line"> <span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|\\s)"</span> + className + <span class="string">"(\\s|$)"</span>);</div><div class="line"> <span class="keyword">var</span> result = [];</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</div><div class="line"> <span class="keyword">var</span> element = elements[i];</div><div class="line"> <span class="keyword">if</span> (regex.test(element.className)) &#123;</div><div class="line"> result.push(element)</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> highs = getElementsByClassName(<span class="string">'high'</span>);</div><div class="line">highs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line"> item.style.color = <span class="string">'red'</span>;</div><div class="line">&#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="使用字符串保存数据"><a href="#使用字符串保存数据" class="headerlink" title="使用字符串保存数据"></a>使用字符串保存数据</h4><p>一般情况下，我们都愿意使用数组来保存数据。但我看到有的框架中，使用的却是字符串。</p>
<p>使用时，仍需要把字符串切分成数组。虽然不一定用到正则，但总感觉酷酷的，这里分享如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> utils = &#123;&#125;;</div><div class="line"><span class="string">"Boolean|Number|String|Function|Array|Date|RegExp|Object|Error"</span>.split(<span class="string">"|"</span>).forEach(fun</div><div class="line">ction (item) &#123;</div><div class="line"> utils[<span class="string">"is"</span> + item] = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> &#123;&#125;.toString.call(obj) == <span class="string">"[object "</span> + item + <span class="string">"]"</span>;</div><div class="line"> &#125;;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log( utils.isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<h4 id="if-语句中使用正则替代-amp-amp"><a href="#if-语句中使用正则替代-amp-amp" class="headerlink" title="if 语句中使用正则替代 &amp;&amp;"></a><code>if</code> 语句中使用正则替代 <code>&amp;&amp;</code></h4><p>比如，模拟 <code>ready</code> 函数，即加载完毕后再执行回调（不兼容 IE 的）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> readyRE = <span class="regexp">/complete|loaded|interactive/</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ready</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line"> <span class="keyword">if</span> (readyRE.test(<span class="built_in">document</span>.readyState) &amp;&amp; <span class="built_in">document</span>.body) &#123;</div><div class="line"> callback()</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">else</span> &#123;</div><div class="line"> <span class="built_in">document</span>.addEventListener(</div><div class="line"> <span class="string">'DOMContentLoaded'</span>,</div><div class="line"> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> callback()</div><div class="line"> &#125;,</div><div class="line"> <span class="literal">false</span></div><div class="line"> );</div><div class="line"> &#125;</div><div class="line">&#125;;</div><div class="line">ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> alert(<span class="string">"加载完毕！"</span>)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="使用强大的-replace"><a href="#使用强大的-replace" class="headerlink" title="使用强大的 replace"></a>使用强大的 <code>replace</code></h4><p>因为 <code>replace</code> 方法比较强大，有时用它根本不是为了替换，只是拿其匹配到的信息来做文章。</p>
<p>这里以查询字符串（querystring）压缩技术为例，注意下面 <code>replace</code> 方法中，回调函数根本没有返回任何东西。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compress</span> (<span class="params">source</span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> keys = &#123;&#125;;</div><div class="line"> source.replace(<span class="regexp">/([^=&amp;]+)=([^&amp;]*)/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">full, key, value</span>) </span>&#123;</div><div class="line"> keys[key] = (keys[key] ? keys[key] + <span class="string">','</span> : <span class="string">''</span>) + value;</div><div class="line"> &#125;);</div><div class="line"> <span class="keyword">var</span> result = [];</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> keys) &#123;</div><div class="line"> result.push(key + <span class="string">'='</span> + keys[key]);</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> result.join(<span class="string">'&amp;'</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( compress(<span class="string">"a=1&amp;b=2&amp;a=3&amp;b=4"</span>) );</div><div class="line"><span class="comment">// =&gt; "a=1,3&amp;b=2,4"</span></div></pre></td></tr></table></figure>
<h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><p>最后这里再做个简单实用的正则测试器。</p>
<p>具体效果如下：</p>
<p><img src="https://meowv.github.io/images/r.7.1.png" alt="PNG"></p>
<p>代码，直接贴了，相信你能看得懂（代码改编于《JavaScript Regular Expressions》）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"err"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"regex"</span> <span class="attr">placeholder</span>=<span class="string">"请输入正则表达式"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入测试文本"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"run"</span>&gt;</span>测试一下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">section &#123;</div><div class="line">    display: flex;</div><div class="line">    flex-direction: column;</div><div class="line">    justify-content: space-around;</div><div class="line">    height: 300px;</div><div class="line">    padding: 0 200px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">section * &#123;</div><div class="line">    min-height: 30px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#err &#123;</div><div class="line">    color: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#result &#123;</div><div class="line">    line-height: 30px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.info &#123;</div><div class="line">    background: #00c5ff;</div><div class="line">    padding: 2px;</div><div class="line">    margin: 2px;</div><div class="line">    display: inline-block;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 获取相应dom元素</span></div><div class="line">     </div><div class="line">    <span class="keyword">var</span> regexInput = <span class="built_in">document</span>.getElementById(<span class="string">"regex"</span>); </div><div class="line">    <span class="keyword">var</span> textInput = <span class="built_in">document</span>.getElementById(<span class="string">"text"</span>); </div><div class="line">    <span class="keyword">var</span> runBtn = <span class="built_in">document</span>.getElementById(<span class="string">"run"</span>); </div><div class="line">    <span class="keyword">var</span> errBox = <span class="built_in">document</span>.getElementById(<span class="string">"err"</span>); </div><div class="line">    <span class="keyword">var</span> resultBox = <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>);  <span class="comment">// 绑定点击事件</span></div><div class="line">     </div><div class="line">    runBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 清除错误和结果</span></div><div class="line">         </div><div class="line">        errBox.innerHTML = <span class="string">""</span>; </div><div class="line">        resultBox.innerHTML = <span class="string">""</span>;  <span class="comment">// 获取正则和文本</span></div><div class="line">         </div><div class="line">        <span class="keyword">var</span> text = textInput.value; </div><div class="line">        <span class="keyword">var</span> regex = regexInput.value; </div><div class="line">        <span class="keyword">if</span> (regex == <span class="string">""</span>) &#123;  errBox.innerHTML = <span class="string">"请输入正则表达式"</span>;  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">""</span>) &#123;  errBox.innerHTML = <span class="string">"请输入测试文本"</span>;  &#125; <span class="keyword">else</span> &#123; </div><div class="line">            regex = createRegex(regex); </div><div class="line">            <span class="keyword">if</span> (!regex) <span class="keyword">return</span>; </div><div class="line">            <span class="keyword">var</span> result, results = [];  <span class="comment">// 没有修饰符g的话，会死循环</span></div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (regex.global) &#123;  <span class="keyword">while</span> (result = regex.exec(text)) &#123;  results.push(result);  &#125;  &#125; <span class="keyword">else</span> &#123;  results.push(regex.exec(text));  &#125; </div><div class="line">            <span class="keyword">if</span> (results[<span class="number">0</span>] == <span class="literal">null</span>) &#123; </div><div class="line">                resultBox.innerHTML = <span class="string">"匹配到0个结果"</span>; </div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;  <span class="comment">// 倒序是有必要的</span></div><div class="line">             </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = results.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </div><div class="line">                <span class="keyword">var</span> result = results[i]; </div><div class="line">                <span class="keyword">var</span> match = result[<span class="number">0</span>]; </div><div class="line">                <span class="keyword">var</span> prefix = text.substr(<span class="number">0</span>, result.index); </div><div class="line">                <span class="keyword">var</span> suffix = text.substr(result.index + match.length); </div><div class="line">                text = prefix  + <span class="string">'&lt;span class="info"&gt;'</span>  + match  + <span class="string">'&lt;/span&gt;'</span>  + suffix; </div><div class="line">            &#125; </div><div class="line">            resultBox.innerHTML = <span class="string">"匹配到"</span> + results.length + <span class="string">"个结果:&lt;br&gt;"</span> + text; </div><div class="line">        &#125; </div><div class="line">    &#125;;  <span class="comment">// 生成正则表达式，核心函数</span></div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createRegex</span>(<span class="params">regex</span>) </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            <span class="keyword">if</span> (regex[<span class="number">0</span>] == <span class="string">"/"</span>) &#123; </div><div class="line">                regex = regex.split(<span class="string">"/"</span>); </div><div class="line">                regex.shift(); </div><div class="line">                <span class="keyword">var</span> flags = regex.pop(); </div><div class="line">                regex = regex.join(<span class="string">"/"</span>); </div><div class="line">                regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regex, flags); </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(regex, <span class="string">"g"</span>);  &#125; </div><div class="line">            <span class="keyword">return</span> regex; </div><div class="line">        &#125; <span class="keyword">catch</span> (e) &#123;  errBox.innerHTML = <span class="string">"无效的正则表达式"</span>;  <span class="keyword">return</span> <span class="literal">false</span>;  &#125; </div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>相关 API 的注意点，本章基本上算是一网打尽了。</p>
<p>至此，恭喜你，你学完了 JavaScript 正则表达式的所有内容。</p>
<p>纸上得来终觉浅，觉知此事要躬行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第七章-正则表达式编程&quot;&gt;&lt;a href=&quot;#第七章-正则表达式编程&quot; class=&quot;headerlink&quot; title=&quot;第七章 正则表达式编程&quot;&gt;&lt;/a&gt;第七章 正则表达式编程&lt;/h2&gt;&lt;p&gt;什么叫知识，能指导我们实践的东西才叫知识。&lt;/p&gt;
&lt;p&gt;学习一样东西，如果不能使用，最多只能算作纸上谈兵。正则表达式的学习，也不例外。&lt;/p&gt;
&lt;p&gt;掌握了正则表达式的语法后，下一步，也是关键的一步，就是在真实世界中使用它。&lt;/p&gt;
&lt;p&gt;那么如何使用正则表达式呢？有哪些关键的点呢？本章就解决这个问题。&lt;/p&gt;
&lt;p&gt;内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#正则表达式的四种操作&quot;&gt;正则表达式的四种操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#相关 API 注意要点&quot;&gt;相关 API 注意要点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#真实案例&quot;&gt;真实案例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式的构建</title>
    <link href="http://xj8c.cc/2017/10/12/Regex-6/"/>
    <id>http://xj8c.cc/2017/10/12/Regex-6/</id>
    <published>2017-10-12T02:30:30.000Z</published>
    <updated>2017-10-12T02:30:38.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六章-正则表达式的构建"><a href="#第六章-正则表达式的构建" class="headerlink" title="第六章 正则表达式的构建"></a>第六章 正则表达式的构建</h2><p>对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。</p>
<p>不仅要看懂别人的解决方案，也要能独立地解决问题。代码是这样，正则表达式也是这样。</p>
<p>与“读”相比，“写”往往更为重要，这个道理是不言而喻的。</p>
<p>对正则的运用，首重就是：如何针对问题，构建一个合适的正则表达式？</p>
<p>本章就解决该问题，内容包括：</p>
<ul>
<li><a href="#平衡法则">平衡法则</a></li>
<li><a href="#构建正则前提">构建正则前提</a></li>
<li><a href="#准确性">准确性</a></li>
<li><a href="#效率">效率</a></li>
</ul>
<a id="more"></a>
<h3 id="平衡法则">平衡法则</h3>

<p>构建正则有一点非常重要，需要做到下面几点的平衡：</p>
<ul>
<li>匹配预期的字符串</li>
<li>不匹配非预期的字符串</li>
<li>可读性和可维护性</li>
<li>效率</li>
</ul>
<h3 id="构建正则前提">构建正则前提</h3>

<h4 id="是否能使用正则？"><a href="#是否能使用正则？" class="headerlink" title="是否能使用正则？"></a>是否能使用正则？</h4><p>正则太强大了，以至于我们随便遇到一个操作字符串问题时，都会下意识地去想，用正则该怎么做。但我们始终要提醒自己，正则虽然强大，但不是万能的，很多看似很简单的事情，还是做不到的。</p>
<p>比如匹配这样的字符串：<code>1010010001…</code>.</p>
<p>虽然很有规律，但是只靠正则就是无能为力。</p>
<h4 id="是否有必要使用正则？"><a href="#是否有必要使用正则？" class="headerlink" title="是否有必要使用正则？"></a>是否有必要使用正则？</h4><p>要认识到正则的局限，不要去研究根本无法完成的任务。同时，也不能走入另一个极端：无所不用正则。能用字符串 API 解决的简单问题，就不该正则出马。</p>
<p>比如，从日期中提取出年月日，虽然可以使用正则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-07-01"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["2017-07-01", "2017", "07", "01", index: 0, input: "2017-07-01"]</span></div></pre></td></tr></table></figure>
<p>其实，可以使用字符串的 split 方法来做，即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-07-01"</span>;</div><div class="line"><span class="keyword">var</span> result = string.split(<span class="string">"-"</span>);</div><div class="line"><span class="built_in">console</span>.log( result );</div><div class="line"><span class="comment">// =&gt; ["2017", "07", "01"]</span></div></pre></td></tr></table></figure>
<p>比如，判断是否有问号，虽然可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"?id=xx&amp;act=search"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.search(<span class="regexp">/\?/</span>) );</div><div class="line"><span class="comment">// =&gt; 0</span></div></pre></td></tr></table></figure>
<p>其实，可以使用字符串的 indexOf 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"?id=xx&amp;act=search"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.indexOf(<span class="string">"?"</span>) );</div><div class="line"><span class="comment">// =&gt; 0</span></div></pre></td></tr></table></figure>
<p>比如获取子串，虽然可以使用正则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"JavaScript"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(<span class="regexp">/.&#123;4&#125;(.+)/</span>)[<span class="number">1</span>] );</div><div class="line"><span class="comment">// =&gt; Script</span></div></pre></td></tr></table></figure>
<p>其实，可以直接使用字符串的 substring 或 substr 方法来做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"JavaScript"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.substring(<span class="number">4</span>) );</div><div class="line"><span class="comment">// =&gt; Script</span></div></pre></td></tr></table></figure>
<h4 id="是否有必要构建一个复杂的正则？"><a href="#是否有必要构建一个复杂的正则？" class="headerlink" title="是否有必要构建一个复杂的正则？"></a>是否有必要构建一个复杂的正则？</h4><p>比如密码匹配问题，要求密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。</p>
<p>在第2章里，我们写出了正则是：</p>
<p><code>/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/</code></p>
<p>其实可以使用多个小正则来做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex1 = <span class="regexp">/^[0-9A-Za-z]&#123;6,12&#125;$/</span>;</div><div class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/^[0-9]&#123;6,12&#125;$/</span>;</div><div class="line"><span class="keyword">var</span> regex3 = <span class="regexp">/^[A-Z]&#123;6,12&#125;$/</span>;</div><div class="line"><span class="keyword">var</span> regex4 = <span class="regexp">/^[a-z]&#123;6,12&#125;$/</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPassword</span> (<span class="params">string</span>) </span>&#123;</div><div class="line"> <span class="keyword">if</span> (!regex1.test(string)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"> <span class="keyword">if</span> (regex2.test(string)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"> <span class="keyword">if</span> (regex3.test(string)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"> <span class="keyword">if</span> (regex4.test(string)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="准确性">准确性</h3>

<p>所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。</p>
<p>这里提到了“预期”二字，那么我们就需要知道目标的组成规则。</p>
<p>不然没法界定什么样的目标字符串是符合预期的，什么样的又不是符合预期的。</p>
<p>下面将举例说明，当目标字符串构成比较复杂时，该如何构建正则，并考虑到哪些平衡。</p>
<h4 id="匹配固定电话"><a href="#匹配固定电话" class="headerlink" title="匹配固定电话"></a>匹配固定电话</h4><p>比如要匹配如下格式的固定电话号码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">055188888888</div><div class="line">0551-88888888</div><div class="line">(0551)88888888</div></pre></td></tr></table></figure>
<p>第一步，了解各部分的模式规则。</p>
<p>上面的电话，总体上分为区号和号码两部分（不考虑分机号和 <code>&quot;+86&quot;</code> 的情形）。</p>
<p>区号是 <code>&quot;0&quot;</code> 开头的 3 到 4 位数字，对应的正则是：<code>0\d{2,3}</code>，</p>
<p>号码是非 <code>&quot;0&quot;</code> 开头的 7 到 8 位数字，对应的正则是：<code>[1-9]\d{6,7}</code>，</p>
<p>因此，匹配 <code>&quot;055188888888&quot;</code> 的正则是：<code>/^0\d{2,3}[1-9]\d{6,7}$/</code>，</p>
<p>匹配 <code>&quot;0551-88888888&quot;</code> 的正则是：<code>/^0\d{2,3}-[1-9]\d{6,7}$/</code>，</p>
<p>匹配 <code>&quot;(0551)88888888&quot;</code> 的正则是：<code>/^\(0\d{2,3}\)[1-9]\d{6,7}$/</code>。</p>
<p>第二步，明确形式关系。</p>
<p>这三者情形是或的关系，可以构建分支：</p>
<p><code>/^0\d{2,3}[1-9]\d{6,7}$|^0\d{2,3}-[1-9]\d{6,7}$|^\(0\d{2,3}\)[1-9]\d{6,7}$/</code></p>
<p>提取公共部分：</p>
<p><code>/^(0\d{2,3}|0\d{2,3}-|\(0\d{2,3}\))[1-9]\d{6,7}$/</code></p>
<p>进一步简写：</p>
<p><code>/^(0\d{2,3}-?|\(0\d{2,3}\))[1-9]\d{6,7}$/</code></p>
<p>其可视化形式：</p>
<p><img src="https://meowv.github.io/images/r.6.1.png" alt="PNG"></p>
<p>上面的正则构建过程略显罗嗦，但是这样做，能保证正则是准确的。</p>
<p>上述三种情形是或的关系，这一点很重要，不然很容易按字符是否出现的情形把正则写成：</p>
<p><code>/^\(?0\d{2,3}\)?-?[1-9]\d{6,7}$/</code></p>
<p>虽然也能匹配上述目标字符串，但也会匹配 <code>&quot;(0551-88888888&quot;</code> 这样的字符串。当然，这不是我们想要的。</p>
<p>其实这个正则也不是完美的，因为现实中，并不是每个 3 位数和 4 位数都是一个真实的区号。</p>
<p>这就是一个平衡取舍问题，一般够用就行。</p>
<h4 id="匹配浮点数"><a href="#匹配浮点数" class="headerlink" title="匹配浮点数"></a>匹配浮点数</h4><p>要求匹配如下的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.23、+1.23、-1.23</div><div class="line">10、+10、-10</div><div class="line">.2、+.2、-.2</div></pre></td></tr></table></figure>
<p>可以看出正则分为三部分。</p>
<p>符号部分：<code>[+-]</code>，</p>
<p>整数部分：<code>\d+</code>，</p>
<p>小数部分：<code>\.\d+</code>。</p>
<p>上述三个部分，并不是全部都出现。如果此时很容易写出如下的正则：</p>
<p><code>/^[-]?(\d)?(\.\d+)?$/</code></p>
<p>此正则看似没问题，但这个正则也会匹配空字符 <code>&quot;&quot;</code>。</p>
<p>因为目标字符串的形式关系不是要求每部分都是可选的。</p>
<p>要匹配 <code>&quot;1.23&quot;</code>、<code>&quot;+1.23&quot;</code>、<code>&quot;-1.23&quot;</code>，可以用<code>/^[-]?\d\.\d+$/</code>，</p>
<p>要匹配 <code>&quot;10&quot;</code>、<code>&quot;+10&quot;</code>、<code>&quot;-10&quot;</code>，可以用<code>/^[-]?\d$/</code>，</p>
<p>要匹配 <code>&quot;.2&quot;</code>、<code>&quot;+.2&quot;</code>、<code>&quot;-.2&quot;</code>，可以用<code>/^[-]?\.\d$/</code>。</p>
<p>因此整个正则是这三者的或的关系，提取公众部分后是：</p>
<p><code>/^[-]?(\d\.\d+|\d+|\.\d+)$/</code></p>
<p>其可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.6.2.png" alt="PNG"></p>
<p>如果要求不匹配 <code>&quot;+.2&quot;</code> 和 <code>&quot;-.2&quot;</code>，此时正则变成：</p>
<p><img src="https://meowv.github.io/images/r.6.3.png" alt="PNG"></p>
<p>当然，<code>/^[-]?(\d\.\d+|\d+|\.\d+)$/</code> 也不是完美的，我们也是做了些取舍，比如：</p>
<p>它也会匹配 <code>&quot;012&quot;</code> 这样以 <code>&quot;0&quot;</code> 开头的整数。如果要求不匹配的话，需要修改整数部分的正则。一般进行验证操作之前，都要经过 <code>trim</code> 和判空。那样的话，也许那个错误正则也就够用了。也可以进一步改写成：<code>/^[-]?(\d)?(\.)?\d+$/</code>，这样我们就需要考虑可读性和可维护性了。</p>
<h3 id="效率">效率</h3>

<p>保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。</p>
<p>正则表达式的运行分为如下的阶段：</p>
<ol>
<li>编译；</li>
<li>设定起始位置；</li>
<li>尝试匹配；</li>
<li>匹配失败的话，从下一位开始继续第 3 步；</li>
<li>最终结果：匹配成功或失败。</li>
</ol>
<p>下面以代码为例，来看看这几个阶段都做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d+/g</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.lastIndex, regex.exec(<span class="string">"123abc34def"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.lastIndex, regex.exec(<span class="string">"123abc34def"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.lastIndex, regex.exec(<span class="string">"123abc34def"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.lastIndex, regex.exec(<span class="string">"123abc34def"</span>) );</div><div class="line"><span class="comment">// =&gt; 0 ["123", index: 0, input: "123abc34def"]</span></div><div class="line"><span class="comment">// =&gt; 3 ["34", index: 6, input: "123abc34def"]</span></div><div class="line"><span class="comment">// =&gt; 8 null</span></div><div class="line"><span class="comment">// =&gt; 0 ["123", index: 0, input: "123abc34def"]</span></div></pre></td></tr></table></figure>
<p>具体分析如下：</p>
<p><code>var regex = /\d+/g;</code></p>
<p>当生成一个正则时，引擎会对其进行编译。报错与否出现这这个阶段。</p>
<p><code>regex.exec(&quot;123abc34def&quot;)</code></p>
<p>当尝试匹配时，需要确定从哪一位置开始匹配。一般情形都是字符串的开头，即第 0 位。</p>
<p>但当使用 <code>test</code> 和 <code>exec</code> 方法，且正则有 <code>g</code> 时，起始位置是从正则对象的 <code>lastIndex</code> 属性开始。</p>
<p>因此第一次 <code>exec</code> 是从第 0 位开始，而第二次是从 3 开始的。</p>
<p>设定好起始位置后，就开始尝试匹配了。</p>
<p>比如第一次 <code>exec，从</code> 0 开始，去尝试匹配，并且成功地匹配到 3 个数字。此时结束时的下标是 2，因此下一次的起始位置是 3。</p>
<p>而第二次，起始下标是 3，但第 3 个字符是 <code>&quot;a&quot;</code>，并不是数字。但此时并不会直接报匹配失败，而是移动到下一位置，即从第 4 位开始继续尝试匹配，但该字符是 <code>&quot;b&quot;</code>，也不是数字。再移动到下一位，是 <code>&quot;c&quot;</code> 仍不行，再移动一位是数字 <code>&quot;3&quot;</code>，此时匹配到了两位数字 <code>&quot;34&quot;</code>。此时，下一次匹配的位置是 <code>&quot;d&quot;</code> 的位置，即第8 位。</p>
<p>第三次，是从第 8 位开始匹配，直到试到最后一位，也没发现匹配的，因此匹配失败，返回 <code>null。同时设置</code> <code>lastIndex</code> 为 0，即，如要再尝试匹配的话，需从头开始。</p>
<p>从上面可以看出，匹配会出现效率问题，主要出现在上面的第 3 阶段和第 4 阶段。</p>
<p>因此，主要优化手法也是针对这两阶段的。</p>
<h4 id="使用具体型字符组来代替通配符，来消除回溯"><a href="#使用具体型字符组来代替通配符，来消除回溯" class="headerlink" title="使用具体型字符组来代替通配符，来消除回溯"></a>使用具体型字符组来代替通配符，来消除回溯</h4><p>而在第三阶段，最大的问题就是回溯。</p>
<p>例如，匹配双引用号之间的字符。如，匹配字符串 <code>123&quot;abc&quot;456</code> 中的 <code>&quot;abc&quot;</code>。</p>
<p>如果正则用的是：<code>/&quot;.*&quot;/</code>，会在第 3 阶段产生 4 次回溯（粉色表示 <code>.*</code> 匹配的内容）：</p>
<p><img src="https://meowv.github.io/images/r.6.4.png" alt="PNG"></p>
<p>如果正则用的是：<code>/&quot;.*?&quot;/</code>，会产生 2 次回溯（粉色表示 <code>.*?</code> 匹配的内容）：</p>
<p><img src="https://meowv.github.io/images/r.6.5.png" alt="PNG"></p>
<p>因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。</p>
<p>此时要使用具体化的字符组，来代替通配符.，以便消除不必要的字符，此时使用正则 <code>/&quot;[^&quot;]*&quot;/</code>，即可。</p>
<h4 id="使用非捕获型分组"><a href="#使用非捕获型分组" class="headerlink" title="使用非捕获型分组"></a>使用非捕获型分组</h4><p>因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。</p>
<p>当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。</p>
<p>例如，<code>/^[-]?(\d\.\d+|\d+|\.\d+)$/</code> 可以修改成：<code>/^[-]?(?:\d\.\d+|\d+|\.\d+)$/</code>。</p>
<h4 id="独立出确定字符"><a href="#独立出确定字符" class="headerlink" title="独立出确定字符"></a>独立出确定字符</h4><p>例如，<code>/a+/</code> 可以修改成 <code>/aa*/</code>。</p>
<p>因为后者能比前者多确定了字符 <code>&quot;a&quot;</code>。这样会在第四步中，加快判断是否匹配失败，进而加快移位的速度。</p>
<h4 id="提取分支公共部分"><a href="#提取分支公共部分" class="headerlink" title="提取分支公共部分"></a>提取分支公共部分</h4><p>比如，<code>/^abc|^def/</code> 修改成 <code>/^(?:abc|def)/</code>。</p>
<p>又比如， <code>/this|that/</code>修改成 <code>/th(?:is|at)/</code>。</p>
<p>这样做，可以减少匹配过程中可消除的重复。</p>
<h4 id="减少分支的数量，缩小它们的范围"><a href="#减少分支的数量，缩小它们的范围" class="headerlink" title="减少分支的数量，缩小它们的范围"></a>减少分支的数量，缩小它们的范围</h4><p><code>/red|read/</code> 可以修改成 <code>/rea?d/</code>。</p>
<p>此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章涉及的内容并不多。</p>
<p>一般情况下，针对某问题能写出一个满足需求的正则，基本上就可以了。</p>
<p>至于准确性和效率方面的追求，纯属看个人要求了。我觉得够用就行了。</p>
<p>关于准确性，本章关心的是最常用的解决思路：</p>
<p>针对每种情形，分别写出正则，然用分支把它们合并在一起，再提取分支公共部分，就能得到准确的正则。</p>
<p>至于优化，本章没有为了凑数，去写一大堆。了解了匹配原理，常见的优化手法也就这么几种。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第六章-正则表达式的构建&quot;&gt;&lt;a href=&quot;#第六章-正则表达式的构建&quot; class=&quot;headerlink&quot; title=&quot;第六章 正则表达式的构建&quot;&gt;&lt;/a&gt;第六章 正则表达式的构建&lt;/h2&gt;&lt;p&gt;对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。&lt;/p&gt;
&lt;p&gt;不仅要看懂别人的解决方案，也要能独立地解决问题。代码是这样，正则表达式也是这样。&lt;/p&gt;
&lt;p&gt;与“读”相比，“写”往往更为重要，这个道理是不言而喻的。&lt;/p&gt;
&lt;p&gt;对正则的运用，首重就是：如何针对问题，构建一个合适的正则表达式？&lt;/p&gt;
&lt;p&gt;本章就解决该问题，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#平衡法则&quot;&gt;平衡法则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#构建正则前提&quot;&gt;构建正则前提&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#准确性&quot;&gt;准确性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#效率&quot;&gt;效率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式的拆分</title>
    <link href="http://xj8c.cc/2017/10/11/Regex-5/"/>
    <id>http://xj8c.cc/2017/10/11/Regex-5/</id>
    <published>2017-10-11T05:12:10.000Z</published>
    <updated>2017-10-11T06:53:10.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章-正则表达式的拆分"><a href="#第五章-正则表达式的拆分" class="headerlink" title="第五章 正则表达式的拆分"></a>第五章 正则表达式的拆分</h2><p>对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。</p>
<p>不仅要求自己能解决问题，还要看懂别人的解决方案。代码是这样，正则表达式也是这样。</p>
<p>正则这门语言跟其他语言有一点不同，它通常就是一大堆字符，而没有所谓“语句”的概念。</p>
<p>如何能正确地把一大串正则拆分成一块一块的，成为了破解“天书”的关键。</p>
<p>本章就解决这一问题，内容包括：</p>
<ul>
<li><a href="#结构和操作符">结构和操作符</a></li>
<li><a href="#注意要点">注意要点</a></li>
<li><a href="#案例分析">案例分析</a></li>
</ul>
<a id="more"></a>
<h3 id="结构和操作符">结构和操作符</h3>

<p>编程语言一般都有操作符。只要有操作符，就会出现一个问题。当一大堆操作在一起时，先操作谁，又后操作谁呢？为了不产生歧义，就需要语言本身定义好操作顺序，即所谓的优先级。</p>
<p>而在正则表达式中，操作符都体现在结构中，即由特殊字符和普通字符所代表的一个个特殊整体。</p>
<p>JavaScript 正则表达式中，都有哪些结构呢？</p>
<p>字符字面量、字符组、量词、锚、分组、选择分支、反向引用。</p>
<p>具体含义简要回顾如下：</p>
<table>
<thead>
<tr>
<th>结构</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>字面量</td>
<td>匹配一个具体字符，包括不用转义的和需要转义的。比如 <code>a</code> 匹配字符 <code>&quot;a&quot;</code>，又比如 <code>\n</code> 匹配换行符，又比如 <code>\.</code> 匹配小数点。</td>
</tr>
<tr>
<td>字符组</td>
<td>匹配一个字符，可以是多种可能之一，比如 <code>[0-9]</code>，表示匹配一个数字。<br>也有 <code>\d</code> 的简写形式。<br>另外还有反义字符组，表示可以是除了特定字符之外任何一个字符，比如 <code>[^0-9]</code>，表示一个非数字字符，也有 <code>\D</code> 的简写形式。</td>
</tr>
<tr>
<td>量词</td>
<td>表示一个字符连续出现，比如 <code>a{1,3}</code> 表示 <code>&quot;a&quot;</code> 字符连续出现 3 次。<br>另外还有常见的简写形式，比如 <code>a+</code> 表示 <code>&quot;a&quot;</code> 字符连续出现至少一次。</td>
</tr>
<tr>
<td>锚</td>
<td>匹配一个位置，而不是字符。比如 <code>^</code> 匹配字符串的开头，又比如 <code>\b</code> 匹配单词边界，又比如 <code>(?=\d)</code> 表示数字前面的位置。</td>
</tr>
<tr>
<td>分组</td>
<td>用括号表示一个整体，比如 <code>(ab)+</code>，表示 <code>&quot;ab&quot;</code> 两个字符连续出现多次，也可以使用非捕获分组 <code>(?:ab)+</code>。</td>
</tr>
<tr>
<td>分支</td>
<td>多个子表达式多选一，比如 abc&#124;bcd，表达式匹配 <code>&quot;abc&quot;</code> 或者 <code>&quot;bcd&quot;</code> 字符子串。<br>反向引用，比如 <code>\2</code>，表示引用第 2 个分组。</td>
</tr>
</tbody>
</table>
<p>其中涉及到的操作符有：</p>
<table>
<thead>
<tr>
<th>操作符描述</th>
<th>操作符</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>转义符</td>
<td><code>\</code></td>
<td>1</td>
</tr>
<tr>
<td>括号和方括号</td>
<td><code>(…)、(?:…)、(?=…)、(?!…)、[…]</code></td>
<td>2</td>
</tr>
<tr>
<td>量词限定符</td>
<td><code>{m}、{m,n}、{m,}、?、*、+</code></td>
<td>3</td>
</tr>
<tr>
<td>位置和序列</td>
<td><code>^、$、\元字符、一般字符</code></td>
<td>4</td>
</tr>
<tr>
<td>管道符（竖杠）</td>
<td>&#124;</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>上面操作符的优先级从上至下，由高到低。</p>
<p>这里，我们来分析一个正则：</p>
<p><code>/ab?(c|de*)+|fg/</code></p>
<ul>
<li>由于括号的存在，所以，<code>(c|de*)</code> 是一个整体结构。</li>
<li>在 <code>(c|de*)</code> 中，注意其中的量词 ，因此 <code>e</code> 是一个整体结构。</li>
<li>又因为分支结构 | 优先级最低，因此 <code>c</code> 是一个整体、而 <code>de*</code> 是另一个整体。</li>
<li>同理，整个正则分成了 <code>a、b?</code>、<code>(…)+</code>、<code>f</code>、<code>g</code>。而由于分支的原因，又可以分成 <code>ab?(c|de*)+</code> 和 <code>fg</code> 这两部分。</li>
</ul>
<p>希望你没被我绕晕，上面的分析可用其可视化形式描述如下：</p>
<p><img src="https://meowv.github.io/images/r.5.1.png" alt="PNG"></p>
<h3 id="注意要点">注意要点</h3>

<p>关于结构和操作符，还是有几点需要强调：</p>
<h4 id="匹配字符串整体问题"><a href="#匹配字符串整体问题" class="headerlink" title="匹配字符串整体问题"></a>匹配字符串整体问题</h4><p>因为是要匹配整个字符串，我们经常会在正则前后中加上锚 <code>^</code> 和 <code>$</code>。</p>
<p>比如要匹配目标字符串 <code>&quot;abc&quot;</code> 或者 <code>&quot;bcd&quot;</code> 时，如果一不小心，就会写成 <code>/^abc|bcd$/</code>。</p>
<p>而位置字符和字符序列优先级要比竖杠高，故其匹配的结构是：</p>
<p><img src="https://meowv.github.io/images/r.5.2.png" alt="PNG"></p>
<p>应该修改成:</p>
<p><img src="https://meowv.github.io/images/r.5.3.png" alt="PNG"></p>
<h4 id="量词连缀问题"><a href="#量词连缀问题" class="headerlink" title="量词连缀问题"></a>量词连缀问题</h4><p>假设，要匹配这样的字符串：</p>
<ol>
<li><p>每个字符为 “a、”b”、”c”任选其一，</p>
</li>
<li><p>字符串的长度是 3 的倍数。</p>
</li>
</ol>
<p>此时正则不能想当然地写成 <code>/^[abc]{3}+$/</code>，这样会报错，说 <code>+</code> 前面没什么可重复的：</p>
<p>此时要修改成：</p>
<p><img src="https://meowv.github.io/images/r.5.4.png" alt="PNG"></p>
<h4 id="元字符转义问题"><a href="#元字符转义问题" class="headerlink" title="元字符转义问题"></a>元字符转义问题</h4><p>所谓元字符，就是正则中有特殊含义的字符。</p>
<p>所有结构里，用到的元字符总结如下：</p>
<p><code>^</code>、<code>$</code>、<code>.</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>|</code>、<code>\</code>、<code>/</code>、<code>(</code>、<code>)</code>、<code>[</code>、<code>]</code>、<code>{</code>、<code>}</code>、<code>=</code>、<code>!</code>、<code>:</code>、<code>-</code> ，当匹配上面的字符本身时，可以一律转义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"^$.*+?|\\/[]&#123;&#125;=!:-,"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>其中 <code>string</code> 中的 <code>\</code> 字符也要转义的。</p>
<p>另外，在 <code>string</code> 中，也可以把每个字符转义，当然，转义后的结果仍是本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"^$.*+?|\\/[]&#123;&#125;=!:-,"</span>;</div><div class="line"><span class="keyword">var</span> string2 = <span class="string">"\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,"</span>;</div><div class="line"><span class="built_in">console</span>.log( string == string2 );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>现在的问题是，是不是每个字符都需要转义呢？否，看情况。</p>
<h5 id="字符组中的元字符"><a href="#字符组中的元字符" class="headerlink" title="字符组中的元字符"></a>字符组中的元字符</h5><p>跟字符组相关的元字符有 <code>[</code>、<code>]</code>、<code>^</code>、<code>-</code>。因此在会引起歧义的地方进行转义。例如开头的 <code>^</code> 必须转义，不然会把整个字符组，看成反义字符组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"^$.*+?|\\/[]&#123;&#125;=!:-,"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/[\^$.*+?|\\/\[\]&#123;&#125;=!:\-,]/g</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["^", "$", ".", "*", "+", "?", "|", "\", "/", "[", "]", "&#123;", "&#125;", "=", "!", ":","-", ","]</span></div></pre></td></tr></table></figure>
<h5 id="匹配-quot-abc-quot-和-quot-3-5-quot"><a href="#匹配-quot-abc-quot-和-quot-3-5-quot" class="headerlink" title="匹配 &quot;[abc]&quot; 和 &quot;{3,5}&quot;"></a>匹配 <code>&quot;[abc]&quot;</code> 和 <code>&quot;{3,5}&quot;</code></h5><p>我们知道 <code>[abc]</code>，是个字符组。如果要匹配字符串 <code>&quot;[abc]&quot;</code> 时，该怎么办？</p>
<p>可以写成 <code>/\[abc\]/</code>，也可以写成 <code>/\[abc]/</code>，测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"[abc]"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\[abc]/g</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex)[<span class="number">0</span>] );</div><div class="line"><span class="comment">// =&gt; "[abc]"</span></div></pre></td></tr></table></figure>
<p>只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。</p>
<p>同理，要匹配字符串 <code>&quot;{3,5}&quot;</code>，只需要把正则写成 <code>/\{3,5}/</code> 即可。</p>
<p>另外，我们知道量词有简写形式 <code>{m,}</code>，却没有 <code>{,n}</code> 的情况。虽然后者不构成量词的形式，但此时并不会报错。当然，匹配的字符串也是 <code>&quot;{,n}&quot;</code>，测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"&#123;,3&#125;"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/&#123;,3&#125;/g</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex)[<span class="number">0</span>] );</div><div class="line"><span class="comment">// =&gt; "&#123;,3&#125;"</span></div></pre></td></tr></table></figure>
<h5 id="其余情况"><a href="#其余情况" class="headerlink" title="其余情况"></a>其余情况</h5><p>比如<code>=</code>、<code>!</code>、<code>:</code>、<code>-</code>、,等符号，只要不在特殊结构中，并不需要转义。</p>
<p>但是，括号需要前后都转义的，如 <code>/\(123\)/</code>。</p>
<p>至于剩下的 <code>^</code>、<code>$</code>、<code>.</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>|</code>、<code>\</code>、<code>/</code> 等字符，只要不在字符组内，都需要转义的。</p>
<h3 id="案例分析">案例分析</h3>

<p>接下来分析两个例子，一个简单的，一个复杂的。</p>
<h4 id="身份证"><a href="#身份证" class="headerlink" title="身份证"></a>身份证</h4><p>正则表达式是：</p>
<p><code>/^(\d{15}|\d{17}[\dxX])$/</code></p>
<p>因为竖杠 <code>|</code> 的优先级最低，所以正则分成了两部分 <code>\d{15}</code> 和 <code>\d{17}[\dxX]</code>。</p>
<p><code>\d{15}</code> 表示 15 位连续数字。</p>
<p><code>\d{17}[\dxX]</code> 表示 17 位连续数字，最后一位可以是数字，可以大小写字母 <code>&quot;x&quot;</code>。</p>
<p>可视化如下：</p>
<p><img src="https://meowv.github.io/images/r.5.5.png" alt="PNG"></p>
<h4 id="IPV4-地址"><a href="#IPV4-地址" class="headerlink" title="IPV4 地址"></a>IPV4 地址</h4><p>正则表达式是：</p>
<p><code>/^((0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])$/</code></p>
<p>这个正则，看起来非常吓人。但是熟悉优先级后，会立马得出如下的结构：</p>
<p><code>((…)\.){3}(…)</code></p>
<p>其中，两个 <code>(…)</code> 是一样的结构。表示匹配的是 3 位数字。因此整个结构是</p>
<p><code>3位数.3位数.3位数.3位数</code></p>
<p>然后再来分析 <code>(…)</code>：</p>
<p><code>(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])</code></p>
<p>它是一个多选结构，分成5个部分：</p>
<ul>
<li><code>0{0,2}\d</code>，匹配一位数，包括 <code>&quot;0&quot;</code> 补齐的。比如，<code>&quot;9&quot;</code>、<code>&quot;09&quot;</code>、<code>&quot;009&quot;</code>；</li>
<li><code>0?\d{2}</code>，匹配两位数，包括 <code>&quot;0&quot;</code> 补齐的，也包括一位数；</li>
<li><code>1\d{2}</code>，匹配 <code>&quot;100&quot;</code> 到 <code>&quot;199&quot;</code>;</li>
<li><code>2[0-4]\d</code>，匹配 <code>&quot;200&quot;</code> 到 <code>&quot;249&quot;</code>；</li>
<li><code>25[0-5]</code>，匹配 <code>&quot;250&quot;</code> 到 <code>&quot;255&quot;</code>。</li>
</ul>
<p>最后来看一下其可视化形式：</p>
<p><img src="https://meowv.github.io/images/r.5.6.png" alt="PNG"></p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>掌握正则表达式中的优先级后，再看任何正则应该都有信心分析下去了。</p>
<p>至于例子，不一而足，没有写太多。</p>
<p>这里稍微总结一下，竖杠的优先级最低，即最后运算。</p>
<p>只要知道这一点，就能读懂大部分正则。</p>
<p>另外关于元字符转义问题，当自己不确定与否时，尽管去转义，总之是不会错的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第五章-正则表达式的拆分&quot;&gt;&lt;a href=&quot;#第五章-正则表达式的拆分&quot; class=&quot;headerlink&quot; title=&quot;第五章 正则表达式的拆分&quot;&gt;&lt;/a&gt;第五章 正则表达式的拆分&lt;/h2&gt;&lt;p&gt;对于一门语言的掌握程度怎么样，可以有两个角度来衡量：读和写。&lt;/p&gt;
&lt;p&gt;不仅要求自己能解决问题，还要看懂别人的解决方案。代码是这样，正则表达式也是这样。&lt;/p&gt;
&lt;p&gt;正则这门语言跟其他语言有一点不同，它通常就是一大堆字符，而没有所谓“语句”的概念。&lt;/p&gt;
&lt;p&gt;如何能正确地把一大串正则拆分成一块一块的，成为了破解“天书”的关键。&lt;/p&gt;
&lt;p&gt;本章就解决这一问题，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#结构和操作符&quot;&gt;结构和操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#注意要点&quot;&gt;注意要点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#案例分析&quot;&gt;案例分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式回溯法原理</title>
    <link href="http://xj8c.cc/2017/10/11/Regex-4/"/>
    <id>http://xj8c.cc/2017/10/11/Regex-4/</id>
    <published>2017-10-11T01:18:38.000Z</published>
    <updated>2017-10-11T01:19:05.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-正则表达式回溯法原理"><a href="#第四章-正则表达式回溯法原理" class="headerlink" title="第四章 正则表达式回溯法原理"></a>第四章 正则表达式回溯法原理</h2><p>学习正则表达式，是需要懂点儿匹配原理的。</p>
<p>而研究匹配原理时，有两个字出现的频率比较高：“回溯”。</p>
<p>听起来挺高大上，事实上却是一个比较容易理解的概念。</p>
<p>因此，本章就简单扼要地说清楚回溯到底是什么东西。</p>
<p>内容包括：</p>
<ul>
<li><a href="#没有回溯的匹配">没有回溯的匹配</a></li>
<li><a href="#有回溯的匹配">有回溯的匹配</a></li>
<li><a href="#常见的回溯形式">常见的回溯形式</a></li>
</ul>
<a id="more"></a>
<h3 id="没有回溯的匹配">没有回溯的匹配</h3>

<p>假设我们的正则是 <code>/ab{1,3}c/</code>，其可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.4.1.png" alt="PNG"></p>
<p>而当目标字符串是 <code>&quot;abbbc&quot;</code> 时，就没有所谓的“回溯”。其匹配过程是：</p>
<p><img src="https://meowv.github.io/images/r.4.2.png" alt="PNG"></p>
<p>其中子表达式 <code>b{1,3}</code> 表示 <code>&quot;b&quot;</code> 字符连续出现 1 到 3 次。</p>
<h3 id="有回溯的匹配">有回溯的匹配</h3>

<p>如果目标字符串是”abbc”，中间就有回溯。</p>
<p><img src="https://meowv.github.io/images/r.4.3.png" alt="PNG"></p>
<p>图中第 5 步有红颜色，表示匹配不成功。此时 <code>b{1,3}</code> 已经匹配到了 2 个字符 <code>&quot;b&quot;</code>，准备尝试第三个时，结果发现接下来的字符是 <code>&quot;c&quot;</code>。那么就认为 <code>b{1,3}</code> 就已经匹配完毕。然后状态又回到之前的状态（即第 6 步与第 4 步一样），最后再用子表达式 <code>c</code>，去匹配字符 <code>&quot;c&quot;</code>。当然，此时整个表达式匹配成功了。</p>
<p>图中的第 6 步，就是“回溯”。</p>
<p>你可能对此没有感觉，这里我们再举一个例子。正则是：</p>
<p><img src="https://meowv.github.io/images/r.4.4.png" alt="PNG"></p>
<p>目标字符串是<code>&quot;abbbc&quot;</code>，匹配过程是：</p>
<p><img src="https://meowv.github.io/images/r.4.5.png" alt="PNG"></p>
<p>其中第 7 步和第 10 步是回溯。第 7 步与第 4 步一样，此时 <code>b{1,3}</code> 匹配了两个 <code>&quot;b&quot;</code>，而第 10 步与第 3 步一样，此时 <code>b{1,3}</code> 只匹配了一个 <code>&quot;b&quot;</code>，这也是 <code>b{1,3}</code> 的最终匹配结果。</p>
<p>这里再看一个清晰的回溯，正则是：</p>
<p><img src="https://meowv.github.io/images/r.4.6.png" alt="PNG"></p>
<p>目标字符串是：<code>&quot;abc&quot;de</code>，匹配过程是：</p>
<p><img src="https://meowv.github.io/images/r.4.7.png" alt="PNG"></p>
<p>图中省略了尝试匹配双引号失败的过程。可以看出 <code>.*</code> 是非常影响效率的。</p>
<p>为了减少一些不必要的回溯，可以把正则修改为 <code>/&quot;[^&quot;]*&quot;/</code>。</p>
<h3 id="常见的回溯形式">常见的回溯形式</h3>

<p>正则表达式匹配字符串的这种方式，有个学名，叫回溯法。</p>
<blockquote>
<p>回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发<br>所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从<br>另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、<br>不断“回溯”寻找解的方法，就称作“回溯法”。 — 百度百科</p>
</blockquote>
<p>本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。</p>
<p>道理，我们是懂了。那么 JavaScript 中正则表达式会产生回溯的地方都有哪些呢？</p>
<h4 id="贪婪量词"><a href="#贪婪量词" class="headerlink" title="贪婪量词"></a>贪婪量词</h4><p>之前的例子都是贪婪量词相关的。比如 <code>b{1,3}</code>，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试 <code>&quot;bbb&quot;</code>，然后再看整个正则是否能匹配。不能匹配时，吐出一个 “b”，即在 “bb” 的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。</p>
<p>虽然局部匹配是贪婪的，但也要满足整体能正确匹配。否则，皮之不存，毛将焉附？</p>
<p>此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？</p>
<p>答案是，先下手为强！因为深度优先搜索。测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"12345"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["12345", "123", "45", index: 0, input: "12345"]</span></div></pre></td></tr></table></figure>
<p>其中，前面的 <code>\d{1,3}</code> 匹配的是 <code>&quot;123&quot;</code>，后面的 <code>\d{1,3}</code> 匹配的是 <code>&quot;45&quot;</code>。</p>
<h4 id="惰性量词"><a href="#惰性量词" class="headerlink" title="惰性量词"></a>惰性量词</h4><p>惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"12345"</span>;</div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;1,3&#125;?)(\d&#123;1,3&#125;)/</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["1234", "1", "234", index: 0, input: "12345"]</span></div></pre></td></tr></table></figure>
<p>其中 <code>\d{1,3}?</code> 只匹配到一个字符 <code>&quot;1&quot;</code>，而后面的 <code>\d{1,3}</code> 匹配了 <code>&quot;234&quot;</code>。</p>
<p>虽然惰性量词不贪，但也会有回溯的现象。比如正则是：</p>
<p><img src="https://meowv.github.io/images/r.4.8.png" alt="PNG"></p>
<p>目标字符串是”12345”，匹配过程是：</p>
<p><img src="https://meowv.github.io/images/r.4.9.png" alt="PNG"></p>
<p>知道你不贪、很知足，但是为了整体匹配成，没办法，也只能给你多塞点了。因此最后 <code>\d{1,3}?</code> 匹配的字<br>符是 <code>&quot;12&quot;</code>，是两个数字，而不是一个。</p>
<h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>我们知道分支也是惰性的，比如 <code>/can|candy/</code>，去匹配字符串 <code>&quot;candy&quot;</code>，得到的结果是 <code>&quot;can&quot;</code>，因为分支会<br>一个一个尝试，如果前面的满足了，后面就不会再试验了。</p>
<p>分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分<br>支。这种尝试也可以看成一种回溯。</p>
<p>比如正则：</p>
<p><img src="https://meowv.github.io/images/r.4.10.png" alt="PNG"></p>
<p>目标字符串是 <code>&quot;candy&quot;</code>，匹配过程：</p>
<p><img src="https://meowv.github.io/images/r.4.11.png" alt="PNG"></p>
<p>上面第 5 步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是一种回溯的。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>其实回溯法，很容易掌握的。</p>
<p>简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。</p>
<ul>
<li>贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。</li>
<li>惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。</li>
<li>分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。</li>
</ul>
<p>既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些 DFA 引擎, DFA 是“确定型有限自动机”的简写。</p>
<p>而 JavaScript 的正则引擎是 NFA，NFA 是“非确定型有限自动机”的简写。</p>
<p>大部分语言中的正则都是 NFA，为啥它这么流行呢？</p>
<p>答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第四章-正则表达式回溯法原理&quot;&gt;&lt;a href=&quot;#第四章-正则表达式回溯法原理&quot; class=&quot;headerlink&quot; title=&quot;第四章 正则表达式回溯法原理&quot;&gt;&lt;/a&gt;第四章 正则表达式回溯法原理&lt;/h2&gt;&lt;p&gt;学习正则表达式，是需要懂点儿匹配原理的。&lt;/p&gt;
&lt;p&gt;而研究匹配原理时，有两个字出现的频率比较高：“回溯”。&lt;/p&gt;
&lt;p&gt;听起来挺高大上，事实上却是一个比较容易理解的概念。&lt;/p&gt;
&lt;p&gt;因此，本章就简单扼要地说清楚回溯到底是什么东西。&lt;/p&gt;
&lt;p&gt;内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#没有回溯的匹配&quot;&gt;没有回溯的匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#有回溯的匹配&quot;&gt;有回溯的匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#常见的回溯形式&quot;&gt;常见的回溯形式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式括号的作用</title>
    <link href="http://xj8c.cc/2017/10/10/Regex-3/"/>
    <id>http://xj8c.cc/2017/10/10/Regex-3/</id>
    <published>2017-10-10T03:21:05.000Z</published>
    <updated>2017-10-10T03:23:33.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-正则表达式括号的作用"><a href="#第三章-正则表达式括号的作用" class="headerlink" title="第三章 正则表达式括号的作用"></a>第三章 正则表达式括号的作用</h2><p>不管哪门语言中都有括号。正则表达式也是一门语言，而括号的存在使这门语言更为强大。</p>
<p>对括号的使用是否得心应手，是衡量对正则的掌握水平的一个侧面标准。</p>
<p>括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。</p>
<p>引用某个分组，会有两种情形：在 JavaScript 里引用它，在正则表达式里引用它。</p>
<p>本章内容虽相对简单，但我也要写长点。</p>
<p>内容包括：</p>
<ul>
<li><a href="#分组和分支结构">分组和分支结构</a></li>
<li><a href="#分组引用">分组引用</a></li>
<li><a href="#反向引用">反向引用</a></li>
<li><a href="#非捕获括号">非捕获括号</a></li>
<li><a href="#相关案例">相关案例</a></li>
</ul>
<a id="more"></a>
<h3 id="分组和分支结构">分组和分支结构</h3>

<p>这二者是括号最直觉的作用，也是最原始的功能，强调括号内的正则是一个整体，即提供子表达式。</p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>我们知道 <code>/a+/</code> 匹配连续出现的 <code>&quot;a&quot;</code>，而要匹配连续出现的 <code>&quot;ab&quot;</code> 时，需要使用 <code>/(ab)+/</code>。</p>
<p>其中括号是提供分组功能，使量词 <code>+</code> 作用于 <code>&quot;ab&quot;</code> 这个整体，测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(ab)+/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"ababa abbb ababab"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["abab", "ab", "ababab"]</span></div></pre></td></tr></table></figure>
<h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>而在多选分支结构 <code>(p1|p2)</code> 中，此处括号的作用也是不言而喻的，提供了分支表达式的所有可能。</p>
<p>比如，要匹配如下的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I love JavaScript</div><div class="line">I love Regular Expression</div></pre></td></tr></table></figure>
<p>可以使用正则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^I love (JavaScript|Regular Expression)$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"I love JavaScript"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"I love Regular Expression"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>如果去掉正则中的括号，即：</p>
<p><code>/^I love JavaScript|Regular Expression$/，</code></p>
<p>匹配字符串是 <code>&quot;I love JavaScript&quot;</code> 和 <code>&quot;Regular Expression&quot;</code>，当然这不是我们想要的。</p>
<h3 id="分组引用">分组引用</h3>

<p>这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。</p>
<p>而要使用它带来的好处，必须配合使用实现环境的 API。</p>
<p>以日期为例。假设格式是 <code>yyyy-mm-dd</code> 的，我们可以先写一个简单的正则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;</div></pre></td></tr></table></figure>
<p>其可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.3.1.png" alt="PNG"></p>
<p>然后再修改成括号版的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div></pre></td></tr></table></figure>
<p>其可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.3.2.png" alt="PNG"></p>
<p>对比这两个可视化图片，我们发现，与前者相比，后者多了分组编号，如 <code>Group #1</code>。</p>
<p>其实正则引擎也是这么做的，在匹配过程中，给每一个分组都开辟一个空间，用来存储每一个分组匹配到的数据。</p>
<p>既然分组可以捕获数据，那么我们就可以使用它们。</p>
<h4 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h4><p>比如提取出年、月、日，可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>NOTE： <code>match</code> 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match<br>返回的数组格式是不一样的。</p>
</blockquote>
<p>另外也可以使用正则实例对象的 <code>exec</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.exec(string) );</div><div class="line"><span class="comment">// =&gt; ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]</span></div></pre></td></tr></table></figure>
<p>同时，也可以使用构造函数的全局属性 <code>$1</code> 至 <code>$9</code> 来获取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line">regex.test(string); <span class="comment">// 正则操作即可，例如</span></div><div class="line"><span class="comment">//regex.exec(string);</span></div><div class="line"><span class="comment">//string.match(regex);</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>); <span class="comment">// "2017"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">// "06"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>); <span class="comment">// "12"</span></div></pre></td></tr></table></figure>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>比如，想把 <code>yyyy-mm-dd</code> 格式，替换成 <code>mm/dd/yyyy</code> 怎么做？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="string">"$2/$3/$1"</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "06/12/2017"</span></div></pre></td></tr></table></figure>
<p>其中 <code>replace</code> 中的，第二个参数里用 <code>$1</code>、<code>$2</code>、<code>$3</code> 指代相应的分组。等价于如下的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">2</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "06/12/2017"</span></div></pre></td></tr></table></figure>
<p>也等价于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="function"><span class="keyword">function</span> (<span class="params">match, year, month, day</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "06/12/2017"</span></div></pre></td></tr></table></figure>
<h3 id="反向引用">反向引用</h3>

<p>除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。</p>
<p>还是以日期为例。</p>
<p>比如要写一个正则支持匹配如下三种格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-06-12</div><div class="line">2016/06/12</div><div class="line">2016.06.12</div></pre></td></tr></table></figure>
<p>最先可能想到的正则是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/</span>;</div><div class="line"><span class="keyword">var</span> string1 = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> string2 = <span class="string">"2017/06/12"</span>;</div><div class="line"><span class="keyword">var</span> string3 = <span class="string">"2017.06.12"</span>;</div><div class="line"><span class="keyword">var</span> string4 = <span class="string">"2016-06/12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>其中 <code>/</code> 和 <code>.</code> 需要转义。虽然匹配了要求的情况，但也匹配 <code>&quot;2016-06/12&quot;</code> 这样的数据。</p>
<p>假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</div><div class="line"><span class="keyword">var</span> string1 = <span class="string">"2017-06-12"</span>;</div><div class="line"><span class="keyword">var</span> string2 = <span class="string">"2017/06/12"</span>;</div><div class="line"><span class="keyword">var</span> string3 = <span class="string">"2017.06.12"</span>;</div><div class="line"><span class="keyword">var</span> string4 = <span class="string">"2016-06/12"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>其可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.3.3.png" alt="PNG"></p>
<p>注意里面的 <code>\1</code>，表示的引用之前的那个分组 <code>(-|\/|\.)</code>。不管它匹配到什么（比如 <code>-</code>），<code>\1</code> 都匹配那个同样的具体某个字符。</p>
<p>我们知道了 <code>\1</code> 的含义后，那么 <code>\2</code> 和 <code>\3</code>的概念也就理解了，即分别指代第二个和第三个分组。</p>
<p>看到这里，此时，恐怕你会有几个问题。</p>
<h4 id="括号嵌套怎么办？"><a href="#括号嵌套怎么办？" class="headerlink" title="括号嵌套怎么办？"></a>括号嵌套怎么办？</h4><p>以左括号（开括号）为准。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"1231231233"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">1</span> ); <span class="comment">// 123</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">2</span> ); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">3</span> ); <span class="comment">// 23</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">RegExp</span>.$<span class="number">4</span> ); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>我们可以看看这个正则匹配模式：</p>
<ul>
<li>第一个字符是数字，比如说 <code>&quot;1&quot;</code>，</li>
<li>第二个字符是数字，比如说 <code>&quot;2&quot;</code>，</li>
<li>第三个字符是数字，比如说 <code>&quot;3&quot;</code>，</li>
<li>接下来的是 <code>\1</code>，是第一个分组内容，那么看第一个开括号对应的分组是什么，是 <code>&quot;123&quot;</code>，</li>
<li>接下来的是 <code>\2</code>，找到第2个开括号，对应的分组，匹配的内容是 <code>&quot;1&quot;</code>，</li>
<li>接下来的是 <code>\3</code>，找到第3个开括号，对应的分组，匹配的内容是 <code>&quot;23&quot;</code>，</li>
<li>最后的是 <code>\4</code>，找到第3个开括号，对应的分组，匹配的内容是 <code>&quot;3&quot;</code>。</li>
</ul>
<p>此正则的可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.3.4.png" alt="PNG"></p>
<h4 id="10-表示什么呢？"><a href="#10-表示什么呢？" class="headerlink" title="\10 表示什么呢？"></a><code>\10</code> 表示什么呢？</h4><p>另外一个疑问可能是，即 <code>\10</code> 是表示第 <code>10</code> 个分组，还是 <code>\1</code> 和 <code>0</code> 呢？</p>
<p>答案是前者，虽然一个正则里出现 <code>\10</code> 比较罕见。测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"123456789# ######"</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>TIP： 如果真要匹配 <code>\1</code> 和 <code>0</code> 的话，请使用 (<code>?:\1)0</code> 或者 <code>\1(?:0)</code>。</p>
</blockquote>
<h4 id="引用不存在的分组会怎样？"><a href="#引用不存在的分组会怎样？" class="headerlink" title="引用不存在的分组会怎样？"></a>引用不存在的分组会怎样？</h4><p>因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如 <code>\2</code>，就匹配 <code>&quot;\2&quot;</code>。注意 <code>&quot;\2&quot;</code> 表示对 <code>&quot;2&quot;</code> 进行了转义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\1\2\3\4\5\6\7\8\9/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"\1\2\3\4\5\6\7\8\9"</span>) );</div><div class="line"><span class="built_in">console</span>.log( <span class="string">"\1\2\3\4\5\6\7\8\9"</span>.split(<span class="string">""</span>) );</div></pre></td></tr></table></figure>
<p>Chrome 浏览器打印的结果：</p>
<p><img src="https://meowv.github.io/images/r.3.5.png" alt="PNG"></p>
<h4 id="分组后面有量词会怎样？"><a href="#分组后面有量词会怎样？" class="headerlink" title="分组后面有量词会怎样？"></a>分组后面有量词会怎样？</h4><p>分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。比如如下的测试案例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d)+/</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"12345"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["12345", "5", index: 0, input: "12345"]</span></div></pre></td></tr></table></figure>
<p>从上面看出，分组 <code>(\d)</code> 捕获的数据是 <code>&quot;5&quot;</code>。</p>
<p>同理对于反向引用，也是这样的。测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d)+ \1/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"12345 1"</span>) );</div><div class="line"><span class="comment">// =&gt; false</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"12345 5"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<h3 id="非捕获括号">非捕获括号</h3>

<p>之前文中出现的括号，都会捕获它们匹配到的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分支。</p>
<p>如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。</p>
<p>此时可以使用非捕获括号 <code>(?:p)</code> 和 <code>(?:p1|p2|p3)</code>，例如本章第一个例子可以修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?:ab)+/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"ababa abbb ababab"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["abab", "ab", "ababab"]</span></div></pre></td></tr></table></figure>
<p>同理，第二例子可以修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^I love (?:JavaScript|Regular Expression)$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"I love JavaScript"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"I love Regular Expression"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<h3 id="相关案例">相关案例</h3>

<p>至此括号的作用已经讲完了，总结一句话，就是提供了可供我们使用的分组，如何用就看我们的了。</p>
<h4 id="字符串-trim-方法模拟"><a href="#字符串-trim-方法模拟" class="headerlink" title="字符串 trim 方法模拟"></a>字符串 trim 方法模拟</h4><p><code>trim</code> 方法是去掉字符串的开头和结尾的空白符。有两种思路去做。</p>
<p>第一种，匹配到开头和结尾的空白符，然后替换成空字符。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( trim(<span class="string">" foobar "</span>) );</div><div class="line"><span class="comment">// =&gt; "foobar"</span></div></pre></td></tr></table></figure>
<p>第二种，匹配整个字符串，然后用引用来提取出相应的数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span> (<span class="params">str</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> str.replace(<span class="regexp">/^\s*(.*?)\s*$/g</span>, <span class="string">"$1"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( trim(<span class="string">" foobar "</span>) );</div><div class="line"><span class="comment">// =&gt; "foobar"</span></div></pre></td></tr></table></figure>
<p>这里使用了惰性匹配 <code>*?</code>，不然也会匹配最后一个空格之前的所有空格的</p>
<p>当然，前者效率高。</p>
<h4 id="将每个单词的首字母转换为大写"><a href="#将每个单词的首字母转换为大写" class="headerlink" title="将每个单词的首字母转换为大写"></a>将每个单词的首字母转换为大写</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span> (<span class="params">str</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> str.toLowerCase().replace(<span class="regexp">/(?:^|\s)\w/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> c.toUpperCase();</div><div class="line"> &#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( titleize(<span class="string">'my name is epeli'</span>) );</div><div class="line"><span class="comment">// =&gt; "My Name Is Epeli"</span></div></pre></td></tr></table></figure>
<p>思路是找到每个单词的首字母，当然这里不使用非捕获匹配也是可以的。</p>
<h4 id="驼峰化"><a href="#驼峰化" class="headerlink" title="驼峰化"></a>驼峰化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span> (<span class="params">str</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> str.replace(<span class="regexp">/[-_\s]+(.)?/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, c</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</div><div class="line"> &#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( camelize(<span class="string">'-moz-transform'</span>) );</div><div class="line"><span class="comment">// =&gt; "MozTransform"</span></div></pre></td></tr></table></figure>
<p>其中分组 <code>(.)</code> 表示首字母。单词的界定是，前面的字符可以是多个连字符、下划线以及空白符。正则后面的 <code>?</code> 的目的，是为了应对 <code>str</code> 尾部的字符可能不是单词字符，比如 <code>str</code> 是 <code>&#39;-moz-transform &#39;</code>。</p>
<h4 id="中划线化"><a href="#中划线化" class="headerlink" title="中划线化"></a>中划线化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dasherize</span> (<span class="params">str</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> str.replace(<span class="regexp">/([A-Z])/g</span>, <span class="string">'-$1'</span>).replace(<span class="regexp">/[-_\s]+/g</span>, <span class="string">'-'</span>).toLowerCase();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( dasherize(<span class="string">'MozTransform'</span>) );</div><div class="line"><span class="comment">// =&gt; "-moz-transform"</span></div></pre></td></tr></table></figure>
<p>驼峰化的逆过程。</p>
<h4 id="HTML-转义和反转义"><a href="#HTML-转义和反转义" class="headerlink" title="HTML 转义和反转义"></a>HTML 转义和反转义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将HTML特殊字符转换成等值的实体</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span> (<span class="params">str</span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> escapeChars = &#123;</div><div class="line"> <span class="string">'&lt;'</span> : <span class="string">'lt'</span>,</div><div class="line"> <span class="string">'&gt;'</span> : <span class="string">'gt'</span>,</div><div class="line"> <span class="string">'"'</span> : <span class="string">'quot'</span>,</div><div class="line"> <span class="string">'&amp;'</span> : <span class="string">'amp'</span>,</div><div class="line"> <span class="string">'\''</span> : <span class="string">'#39'</span></div><div class="line"> &#125;;</div><div class="line"> <span class="keyword">return</span> str.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'['</span> + <span class="built_in">Object</span>.keys(escapeChars).join(<span class="string">''</span>) +<span class="string">']'</span>, <span class="string">'g'</span>),</div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">match</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> <span class="string">'&amp;'</span> + escapeChars[match] + <span class="string">';'</span>;</div><div class="line"> &#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( escapeHTML(<span class="string">'&lt;div&gt;Blah blah blah&lt;/div&gt;'</span>) );</div><div class="line"><span class="comment">// =&gt; "&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt";</span></div></pre></td></tr></table></figure>
<p>其中使用了用构造函数生成的正则，然后替换相应的格式就行了，这个跟本章没多大关系。</p>
<p>倒是它的逆过程，使用了括号，以便提供引用，也很简单，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实体字符转换为等值的HTML。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unescapeHTML</span> (<span class="params">str</span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> htmlEntities = &#123;</div><div class="line"> <span class="attr">nbsp</span>: <span class="string">' '</span>,</div><div class="line"> <span class="attr">lt</span>: <span class="string">'&lt;'</span>,</div><div class="line"> <span class="attr">gt</span>: <span class="string">'&gt;'</span>,</div><div class="line"> <span class="attr">quot</span>: <span class="string">'"'</span>,</div><div class="line"> <span class="attr">amp</span>: <span class="string">'&amp;'</span>,</div><div class="line"> <span class="attr">apos</span>: <span class="string">'\''</span></div><div class="line"> &#125;;</div><div class="line"> <span class="keyword">return</span> str.replace(<span class="regexp">/\&amp;([^;]+);/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, key</span>) </span>&#123;</div><div class="line"> <span class="keyword">if</span> (key <span class="keyword">in</span> htmlEntities) &#123;</div><div class="line"> <span class="keyword">return</span> htmlEntities[key];</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> match;</div><div class="line"> &#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( unescapeHTML(<span class="string">'&amp;lt;div&amp;gt;Blah blah blah&amp;lt;/div&amp;gt;'</span>) );</div><div class="line"><span class="comment">// =&gt; "&lt;div&gt;Blah blah blah&lt;/div&gt;"</span></div></pre></td></tr></table></figure>
<p>通过 <code>key</code> 获取相应的分组引用，然后作为对象的键。</p>
<h4 id="匹配成对标签"><a href="#匹配成对标签" class="headerlink" title="匹配成对标签"></a>匹配成对标签</h4><p>要求匹配：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>regular expression<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>laoyao bye bye<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>不匹配：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>wrong!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>匹配一个开标签，可以使用正则 <code>&lt;[^&gt;]+&gt;</code>，</p>
<p>匹配一个闭标签，可以使用 <code>&lt;\/[^&gt;]+&gt;</code>，</p>
<p>但是要求匹配成对标签，那就需要使用反向引用，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</span>;</div><div class="line"><span class="keyword">var</span> string1 = <span class="string">"&lt;title&gt;regular expression&lt;/title&gt;"</span>;</div><div class="line"><span class="keyword">var</span> string2 = <span class="string">"&lt;p&gt;laoyao bye bye&lt;/p&gt;"</span>;</div><div class="line"><span class="keyword">var</span> string3 = <span class="string">"&lt;title&gt;wrong!&lt;/p&gt;"</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>其中开标签 <code>&lt;[\^&gt;]+&gt;</code> 改成 <code>&lt;([^&gt;]+)&gt;</code>，使用括号的目的是为了后面使用反向引用，而提供分组。闭标签使用了反向引用，<code>&lt;\/\1&gt;</code>。</p>
<p>另外，<code>[\d\D]</code>的意思是，这个字符是数字或者不是数字，因此，也就是匹配任意字符的意思。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>重点理解括号可以提供分组，我们可以提取数据，应该就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-正则表达式括号的作用&quot;&gt;&lt;a href=&quot;#第三章-正则表达式括号的作用&quot; class=&quot;headerlink&quot; title=&quot;第三章 正则表达式括号的作用&quot;&gt;&lt;/a&gt;第三章 正则表达式括号的作用&lt;/h2&gt;&lt;p&gt;不管哪门语言中都有括号。正则表达式也是一门语言，而括号的存在使这门语言更为强大。&lt;/p&gt;
&lt;p&gt;对括号的使用是否得心应手，是衡量对正则的掌握水平的一个侧面标准。&lt;/p&gt;
&lt;p&gt;括号的作用，其实三言两语就能说明白，括号提供了分组，便于我们引用它。&lt;/p&gt;
&lt;p&gt;引用某个分组，会有两种情形：在 JavaScript 里引用它，在正则表达式里引用它。&lt;/p&gt;
&lt;p&gt;本章内容虽相对简单，但我也要写长点。&lt;/p&gt;
&lt;p&gt;内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#分组和分支结构&quot;&gt;分组和分支结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#分组引用&quot;&gt;分组引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#反向引用&quot;&gt;反向引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#非捕获括号&quot;&gt;非捕获括号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#相关案例&quot;&gt;相关案例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式位置匹配攻略</title>
    <link href="http://xj8c.cc/2017/09/29/Regex-2/"/>
    <id>http://xj8c.cc/2017/09/29/Regex-2/</id>
    <published>2017-09-29T07:52:50.000Z</published>
    <updated>2017-09-29T07:58:57.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-正则表达式位置匹配攻略"><a href="#第二章-正则表达式位置匹配攻略" class="headerlink" title="第二章 正则表达式位置匹配攻略"></a>第二章 正则表达式位置匹配攻略</h2><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。</p>
<p>然而大部分人学习正则时，对于匹配位置的重视程度没有那么高。</p>
<p>本章讲讲正则匹配位置的相关知识点。</p>
<p>内容包括：</p>
<ul>
<li><a href="#什么是位置呢？">什么是位置？</a></li>
<li><a href="#如何匹配位置呢？">如何匹配位置？</a></li>
<li><a href="#位置的特性">位置的特性</a></li>
<li><a href="#相关案例">几个应用实例分析</a></li>
</ul>
<h3 id="什么是位置呢？">什么是位置呢？</h3>

<p>位置（锚）是相邻字符之间的位置。比如，下图中箭头所指的地方：</p>
<p><img src="https://meowv.github.io/images/r.2.1.png" alt="PNG"></p>
<a id="more"></a>
<h3 id="如何匹配位置呢？">如何匹配位置呢？</h3>

<p>在 ES5 中，共有 6 个锚：</p>
<p><code>^</code>、<code>$</code>、<code>\b</code>、<code>\B</code>、<code>(?=p)</code>、<code>(?!p)</code></p>
<p>相应的可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.2.2.png" alt="PNG"></p>
<h4 id="和"><a href="#和" class="headerlink" title="^ 和 $"></a><code>^</code> 和 <code>$</code></h4><p><code>^</code>（脱字符）匹配开头，在多行匹配中匹配行开头。</p>
<p><code>$</code>（美元符号）匹配结尾，在多行匹配中匹配行结尾。</p>
<p>比如我们把字符串的开头和结尾用 <code>&quot;#&quot;</code> 替换（位置可以替换成字符的！）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>.replace(<span class="regexp">/^|$/g</span>, <span class="string">'#'</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "#hello#"</span></div></pre></td></tr></table></figure>
<p>多行匹配模式（即有修饰符 <code>m</code>）时，二者是行的概念，这一点需要我们注意：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"I\nlove\njavascript"</span>.replace(<span class="regexp">/^|$/gm</span>, <span class="string">'#'</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">/*</span></div><div class="line">#I#</div><div class="line">#love#</div><div class="line">#javascript#</div><div class="line">*/</div></pre></td></tr></table></figure>
<h4 id="b-和-B"><a href="#b-和-B" class="headerlink" title="\b 和 \B"></a><code>\b</code> 和 <code>\B</code></h4><p><code>\b</code> 是单词边界，具体就是 <code>\w</code> 与 <code>\W</code> 之间的位置，也包括 <code>\w</code> 与 <code>^</code> 之间的位置，和 <code>\w</code> 与 <code>$</code> 之间的位置。</p>
<p>比如考察文件名 <code>&quot;[JS] Lesson_01.mp4&quot;</code> 中的 <code>\b</code>，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"[JS] Lesson_01.mp4"</span>.replace(<span class="regexp">/\b/g</span>, <span class="string">'#'</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "[#JS#] #Lesson_01#.#mp4#"</span></div></pre></td></tr></table></figure>
<p>为什么是这样呢？这需要仔细看看。</p>
<p>首先，我们知道，<code>\w</code> 是字符组 <code>[0-9a-zA-Z_]</code> 的简写形式，即 <code>\w</code> 是字母数字或者下划线的中任何一个字符。而 <code>\W</code> 是排除字符组 <code>[^0-9a-zA-Z_]</code> 的简写形式，即 <code>\W</code> 是 <code>\w</code> 以外的任何一个字符。</p>
<p>此时我们可以看看 <code>&quot;[#JS#] #Lesson_01#.#mp4#&quot;</code> 中的每一个井号 ，是怎么来的。</p>
<ul>
<li>第 1 个，两边字符是 <code>&quot;[&quot;</code> 与 <code>&quot;J&quot;</code>，是 <code>\W</code> 与 <code>\w</code> 之间的位置。</li>
<li>第 2 个，两边字符是 <code>&quot;S&quot;</code> 与 <code>&quot;]&quot;</code>，也就是 <code>\w</code> 与 <code>\W</code> 之间的位置。</li>
<li>第 3 个，两边字符是空格与 <code>&quot;L&quot;</code>，也就是 <code>\W</code> 与 <code>\w</code> 之间的位置。</li>
<li>第 4 个，两边字符是 <code>&quot;1&quot;</code> 与 <code>&quot;.&quot;</code>，也就是 <code>\w</code> 与 <code>\W</code> 之间的位置。</li>
<li>第 5 个，两边字符是 <code>&quot;.&quot;</code> 与 <code>&quot;m&quot;</code>，也就是 <code>\W</code> 与 <code>\w</code>之间的位置。</li>
<li>第 6 个，位于结尾，前面的字符 <code>&quot;4&quot;</code> 是 <code>\w</code>，即 <code>\w</code> 与 <code>$</code> 之间的位置。</li>
</ul>
<p>知道了 <code>\b</code> 的概念后，那么 <code>\B</code> 也就相对好理解了。</p>
<p><code>\B</code> 就是 <code>\b</code> 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 <code>\b</code>，剩下的都是 <code>\B</code> 的。</p>
<p>具体说来就是 <code>\w</code> 与 <code>\w</code>、 <code>\W</code> 与 <code>\W</code>、<code>^</code> 与 <code>\W</code>，<code>\W</code> 与 <code>$</code> 之间的位置。</p>
<p>比如上面的例子，把所有 <code>\B</code> 替换成 <code>&quot;#&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"[JS] Lesson_01.mp4"</span>.replace(<span class="regexp">/\B/g</span>, <span class="string">'#'</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"</span></div></pre></td></tr></table></figure>
<h4 id="p-和-p"><a href="#p-和-p" class="headerlink" title="(?=p) 和 (?!p)"></a><code>(?=p)</code> 和 <code>(?!p)</code></h4><p><code>(?=p)</code>，其中 <code>p</code> 是一个子模式，即 <code>p</code> 前面的位置，或者说，该位置后面的字符要匹配 <code>p</code>。</p>
<p>比如 <code>(?=l)</code>，表示 <code>&quot;l&quot;</code> 字符前面的位置，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>.replace(<span class="regexp">/(?=l)/g</span>, <span class="string">'#'</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "he#l#lo"</span></div></pre></td></tr></table></figure>
<p>而 <code>(?!p)</code> 就是 <code>(?=p)</code> 的反面意思，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>.replace(<span class="regexp">/(?!l)/g</span>, <span class="string">'#'</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "#h#ell#o#"</span></div></pre></td></tr></table></figure>
<p>二者的学名分别是 positive lookahead 和 negative lookahead。</p>
<p>中文翻译分别是正向先行断言和负向先行断言。</p>
<p>ES5 之后的版本，会支持 positive lookbehind 和 negative lookbehind。</p>
<p>具体是 <code>(?&lt;=p)</code> 和 <code>(?&lt;!p)</code>。</p>
<p>也有书上把这四个东西，翻译成环视，即看看右边和看看左边。</p>
<p>但一般书上，没有很好强调这四者是个位置。</p>
<p>比如 <code>(?=p)</code>，一般都理解成：要求接下来的字符与 <code>p</code> 匹配，但不能包括 <code>p</code> 匹配的那些字符。</p>
<p>而在本人看来，<code>(?=p)</code> 就与 <code>^</code> 一样好理解，就是 <code>p</code> 前面的那个位置。</p>
<h3 id="位置的特性">位置的特性</h3>

<p>对于位置的理解，我们可以理解成空字符 <code>&quot;&quot;</code>。</p>
<p>比如 <code>&quot;hello&quot;</code> 字符串等价于如下的形式：</p>
<p><code>&quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;o&quot; + &quot;&quot;;</code></p>
<p>也等价于：</p>
<p><code>&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot;</code></p>
<p>因此，把 <code>/\^hello$/</code> 写成 <code>/^^hello$$$/</code>，是没有任何问题的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="regexp">/^^hello$$$/</span>.test(<span class="string">"hello"</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>甚至可以写成更复杂的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="regexp">/(?=he)^^he(?=\w)llo$\b\b$/</span>.test(<span class="string">"hello"</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>也就是说字符之间的位置，可以写成多个。</p>
<blockquote>
<p>TIP： 把位置理解空字符，是对位置非常有效的理解方式。</p>
</blockquote>
<h3 id="相关案例">相关案例</h3>

<h4 id="不匹配任何东西的正则"><a href="#不匹配任何东西的正则" class="headerlink" title="不匹配任何东西的正则"></a>不匹配任何东西的正则</h4><p>让你写个正则不匹配任何东西</p>
<p>easy，<code>/.^/</code>。</p>
<p>因为此正则要求只有一个字符，但该字符后面是开头，而这样的字符串是不存在的</p>
<h4 id="数字的千位分隔符表示法"><a href="#数字的千位分隔符表示法" class="headerlink" title="数字的千位分隔符表示法"></a>数字的千位分隔符表示法</h4><p>比如把 <code>&quot;12345678&quot;</code>，变成 <code>&quot;12,345,678&quot;</code>。</p>
<p>可见是需要把相应的位置替换成 <code>&quot;,&quot;</code>。</p>
<p>思路是什么呢？</p>
<h5 id="弄出最后一个逗号"><a href="#弄出最后一个逗号" class="headerlink" title="弄出最后一个逗号"></a>弄出最后一个逗号</h5><p>使用 <code>(?=\d{3}$)</code> 就可以做到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"12345678"</span>.replace(<span class="regexp">/(?=\d&#123;3&#125;$)/g</span>, <span class="string">','</span>)</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "12345,678"</span></div></pre></td></tr></table></figure>
<p>其中，<code>(?=\d{3}$)</code> 匹配 <code>\d{3}$</code> 前面的位置。而 <code>\d{3}$</code> 匹配的是目标字符串最后那 3 位数字。</p>
<h5 id="弄出所有的逗号"><a href="#弄出所有的逗号" class="headerlink" title="弄出所有的逗号"></a>弄出所有的逗号</h5><p>因为逗号出现的位置，要求后面 3 个数字一组，也就是 <code>\d{3}</code> 至少出现一次。</p>
<p>此时可以使用量词 <code>+</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"12345678"</span>.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">','</span>)</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "12,345,678"</span></div></pre></td></tr></table></figure>
<h5 id="匹配其余案例"><a href="#匹配其余案例" class="headerlink" title="匹配其余案例"></a>匹配其余案例</h5><p>写完正则后，要多验证几个案例，此时我们会发现问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"123456789"</span>.replace(<span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">','</span>)</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; ",123,456,789"</span></div></pre></td></tr></table></figure>
<p>因为上面的正则，仅仅表示把从结尾向前数，一但是 3 的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。</p>
<p>怎么解决呢？我们要求匹配的到这个位置不能是开头。</p>
<p>我们知道匹配开头可以使用 <code>^</code>，但要求这个位置不是开头怎么办？</p>
<p>easy，<code>(?!^)</code>，你想到了吗？测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>;</div><div class="line"><span class="keyword">var</span> result = <span class="string">"12345678"</span>.replace(regex, <span class="string">','</span>)</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "12,345,678"</span></div><div class="line"></div><div class="line">result = <span class="string">"123456789"</span>.replace(regex, <span class="string">','</span>);</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "123,456,789"</span></div></pre></td></tr></table></figure>
<h5 id="支持其他形式"><a href="#支持其他形式" class="headerlink" title="支持其他形式"></a>支持其他形式</h5><p>如果要把 <code>&quot;12345678 123456789&quot;</code> 替换成 <code>&quot;12,345,678 123,456,789&quot;</code>。</p>
<p>此时我们需要修改正则，把里面的开头 <code>^</code> 和结尾 <code>$</code>，修改成 <code>\b</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">"12345678 123456789"</span>,</div><div class="line">regex = <span class="regexp">/(?!\b)(?=(\d&#123;3&#125;)+\b)/g</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="string">','</span>)</div><div class="line"><span class="built_in">console</span>.log(result);</div><div class="line"><span class="comment">// =&gt; "12,345,678 123,456,789"</span></div></pre></td></tr></table></figure>
<p>其中 <code>(?!\b)</code> 怎么理解呢？</p>
<p>要求当前是一个位置，但不是 <code>\b</code> 前面的位置，其实 <code>(?!\b)</code> 说的就是 <code>\B</code>。</p>
<p>因此最终正则变成了：<code>/\B(?=(\d{3})+\b)/g</code>。</p>
<p>可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.2.3.png" alt="PNG"></p>
<h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><p>千分符表示法一个常见的应用就是货币格式化。</p>
<p>比如把下面的字符串：<code>1888</code></p>
<p>格式化成：<code>$ 1,888.00</code></p>
<p>有了前面的铺垫，我们很容实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span> (<span class="params">num</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> num.toFixed(<span class="number">2</span>).replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+\b)/</span>, <span class="string">","</span>).replace(<span class="regexp">/^/</span>, <span class="string">"$$ "</span>);</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log( format(<span class="number">1888</span>) );</div><div class="line"><span class="comment">// =&gt; "$ 1,888.00"</span></div></pre></td></tr></table></figure>
<h4 id="验证密码问题"><a href="#验证密码问题" class="headerlink" title="验证密码问题"></a>验证密码问题</h4><p>密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。</p>
<p>此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。</p>
<p>那么，我们就来挑战一下。看看我们对位置的理解是否深刻。</p>
<h5 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h5><p>不考虑“但必须至少包括 2 种字符”这一条件。我们可以容易写出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9A-Za-z]&#123;6,12&#125;$/</span>;</div></pre></td></tr></table></figure>
<h5 id="判断是否包含有某一种字符"><a href="#判断是否包含有某一种字符" class="headerlink" title="判断是否包含有某一种字符"></a>判断是否包含有某一种字符</h5><p>假设，要求的必须包含数字，怎么办？此时我们可以使用 <code>(?=.*[0-9])</code> 来做。</p>
<p>因此正则变成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?=.*[0-9])^[0-9A-Za-z]&#123;6,12&#125;$/</span>;</div></pre></td></tr></table></figure>
<h5 id="同时包含具体两种字符"><a href="#同时包含具体两种字符" class="headerlink" title="同时包含具体两种字符"></a>同时包含具体两种字符</h5><p>比如同时包含数字和小写字母，可以用 <code>(?=.[0-9])(?=.[a-z])</code> 来做。</p>
<p>因此正则变成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]&#123;6,12&#125;$/</span>;</div></pre></td></tr></table></figure>
<h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><p>我们可以把原题变成下列几种情况之一：</p>
<ul>
<li>同时包含数字和小写字母</li>
<li>同时包含数字和大写字母</li>
<li>同时包含小写字母和大写字母</li>
<li>同时包含数字、小写字母和大写字母</li>
<li>以上的 4 种情况是或的关系（实际上，可以不用第 4 条）。</li>
</ul>
<p>最终答案是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-</span></div><div class="line">Z]))^[0-9A-Za-z]&#123;6,12&#125;$/;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"1234567"</span>) ); <span class="comment">// false 全是数字</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"abcdef"</span>) ); <span class="comment">// false 全是小写字母</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"ABCDEFGH"</span>) ); <span class="comment">// false 全是大写字母</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"ab23C"</span>) ); <span class="comment">// false 不足6位</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"ABCDEF234"</span>) ); <span class="comment">// true 大写字母和数字</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"abcdEF234"</span>) ); <span class="comment">// true 三者都有</span></div></pre></td></tr></table></figure>
<p>可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.2.4.png" alt="PNG"></p>
<h5 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h5><p>上面的正则看起来比较复杂，只要理解了第二步，其余就全部理解了。</p>
<p><code>/(?=.*[0-9])^[0-9A-Za-z]{6,12}$/</code></p>
<p>对于这个正则，我们只需要弄明白 <code>(?=.*[0-9])^</code> 即可。</p>
<p>分开来看就是 <code>(?=.*[0-9])</code> 和 <code>^</code>。</p>
<p>表示开头前面还有个位置（当然也是开头，即同一个位置，想想之前的空字符类比）。</p>
<p><code>(?=.*[0-9])</code> 表示该位置后面的字符匹配 <code>.*[0-9]</code>，即，有任何多个任意字符，后面再跟个数字。</p>
<p>翻译成大白话，就是接下来的字符，必须包含个数字。</p>
<h5 id="另外一种解法"><a href="#另外一种解法" class="headerlink" title="另外一种解法"></a>另外一种解法</h5><p>“至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。</p>
<p>那么要求“不能全部都是数字”，怎么做呢？ <code>(?!p)</code> 出马！</p>
<p>对应的正则是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?!^[0-9]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/</span>;</div></pre></td></tr></table></figure>
<p>三种“都不能”呢？</p>
<p>最终答案是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"1234567"</span>) ); <span class="comment">// false 全是数字</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"abcdef"</span>) ); <span class="comment">// false 全是小写字母</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"ABCDEFGH"</span>) ); <span class="comment">// false 全是大写字母</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"ab23C"</span>) ); <span class="comment">// false 不足6位</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"ABCDEF234"</span>) ); <span class="comment">// true 大写字母和数字</span></div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"abcdEF234"</span>) ); <span class="comment">// true 三者都有</span></div></pre></td></tr></table></figure>
<p>其可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.2.5.png" alt="PNG"></p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>重点掌握匹配位置的这 6 个锚，给我们的解决正则问题工具箱内添加了新工具。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第二章-正则表达式位置匹配攻略&quot;&gt;&lt;a href=&quot;#第二章-正则表达式位置匹配攻略&quot; class=&quot;headerlink&quot; title=&quot;第二章 正则表达式位置匹配攻略&quot;&gt;&lt;/a&gt;第二章 正则表达式位置匹配攻略&lt;/h2&gt;&lt;p&gt;正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。&lt;/p&gt;
&lt;p&gt;然而大部分人学习正则时，对于匹配位置的重视程度没有那么高。&lt;/p&gt;
&lt;p&gt;本章讲讲正则匹配位置的相关知识点。&lt;/p&gt;
&lt;p&gt;内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#什么是位置呢？&quot;&gt;什么是位置？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#如何匹配位置呢？&quot;&gt;如何匹配位置？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#位置的特性&quot;&gt;位置的特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#相关案例&quot;&gt;几个应用实例分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;什么是位置呢？&quot;&gt;什么是位置呢？&lt;/h3&gt;

&lt;p&gt;位置（锚）是相邻字符之间的位置。比如，下图中箭头所指的地方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://meowv.github.io/images/r.2.1.png&quot; alt=&quot;PNG&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式字符匹配攻略</title>
    <link href="http://xj8c.cc/2017/09/28/Regex-1/"/>
    <id>http://xj8c.cc/2017/09/28/Regex-1/</id>
    <published>2017-09-28T02:36:26.000Z</published>
    <updated>2017-09-29T07:18:39.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-正则表达式字符匹配攻略"><a href="#第一章-正则表达式字符匹配攻略" class="headerlink" title="第一章 正则表达式字符匹配攻略"></a>第一章 正则表达式字符匹配攻略</h2><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。</p>
<p>然而关于正则如何匹配字符的学习，大部分人都觉得这块比较杂乱。</p>
<p>毕竟元字符太多了，看起来没有系统性，不好记。本章就解决这个问题。</p>
<p>内容包括：</p>
<ul>
<li><a href="#两种模糊匹配">两种模糊匹配</a></li>
<li><a href="#字符组">字符组</a></li>
<li><a href="#量词">量词</a></li>
<li><a href="#分支结构">分支结构</a></li>
<li><a href="#案例分析">案例分析</a></li>
</ul>
<h3 id="两种模糊匹配">两种模糊匹配</h3>

<p>如果正则只有精确匹配是没多大意义的，比如 <code>/hello/</code>，也只能匹配字符串中的 <code>&quot;hello&quot;</code> 这个子串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/hello/</span>;</div><div class="line"><span class="built_in">console</span>.log(regex.test(<span class="string">"hello"</span>));</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>正则表达式之所以强大，是因为其能实现模糊匹配。</p>
<p>而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊。</p>
<h4 id="横向模糊匹配"><a href="#横向模糊匹配" class="headerlink" title="横向模糊匹配"></a>横向模糊匹配</h4><p>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。</p>
<p>其实现的方式是使用量词。譬如 <code>{m,n}</code>，表示连续出现最少 m 次，最多 n 次。</p>
<p>比如正则 <code>/ab{2,5}c/</code> 表示匹配这样一个字符串：第一个字符是 <code>&quot;a&quot;</code>，接下来是 2 到 5 个字符 <code>&quot;b&quot;</code>，最后是字符 <code>&quot;c&quot;</code>。</p>
<p>其可视化形式如下：</p>
<p><img src="https://meowv.github.io/images/r.1.1.png" alt="PNG"></p>
<p>测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;2,5&#125;c/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"abc abbc abbbc abbbbc abbbbbc abbbbbbc"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["abbc", "abbbc", "abbbbc", "abbbbbc"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>NOTE： 案例中用的正则是 <code>/ab{2,5}c/g</code>，其中 <code>g</code> 是正则的一个<code>修饰符</code>。表示全局匹配，即，在目标字符串中按顺序找到满足匹配模式的所有子串，强调的是“所有”，而不只是“第一个”。<code>g</code> 是单词 global 的首字母。</p>
</blockquote>
<h4 id="纵向模糊匹配"><a href="#纵向模糊匹配" class="headerlink" title="纵向模糊匹配"></a>纵向模糊匹配</h4><p>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。</p>
<p>其实现的方式是使用字符组。譬如 <code>[abc]</code>，表示该字符是可以字符 <code>&quot;a&quot;、&quot;b&quot;、&quot;c&quot;</code> 中的任何一个。</p>
<p>比如 <code>/a[123]b/</code> 可以匹配如下三种字符串： <code>&quot;a1b&quot;、&quot;a2b&quot;、&quot;a3b&quot;</code>。</p>
<p>其可视化形式如下：</p>
<p><img src="https://meowv.github.io/images/r.1.2.png" alt="PNG"></p>
<p>测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/a[123]b/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"a0b a1b a2b a3b a4b"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["a1b", "a2b", "a3b"]</span></div></pre></td></tr></table></figure>
<p>以上就是本章讲的主体内容，只要掌握横向和纵向模糊匹配，就能解决很大部分正则匹配问题。</p>
<p>接下来，我们将具体展开来说。</p>
<h3 id="字符组">字符组</h3>

<p>需要强调的是，虽叫字符组（字符类），但只是其中一个字符。</p>
<p>例如 <code>[abc]</code>，表示匹配一个字符，它可以是 <code>&quot;a&quot;、&quot;b&quot;、&quot;c&quot;</code> 之一。</p>
<h4 id="范围表示法"><a href="#范围表示法" class="headerlink" title="范围表示法"></a>范围表示法</h4><p>如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。</p>
<p>比如 <code>[123456abcdefGHIJKLM]</code>，可以写成 <code>[1-6a-fG-M]</code>。用连字符 - 来省略和简写。</p>
<p>因为连字符有特殊用途，那么要匹配 <code>&quot;a&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;z&quot;</code> 这三者中任意一个字符，该怎么做呢？</p>
<p>不能写成 <code>[a-z]</code>，因为其表示小写字符中的任何一个字符。</p>
<p>可以写成如下的方式：<code>[-az]</code> 或 <code>[az-]</code> 或 <code>[a\-z]</code>。</p>
<p>即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。</p>
<h4 id="排除字符组"><a href="#排除字符组" class="headerlink" title="排除字符组"></a>排除字符组</h4><p>纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 <code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code>。</p>
<p>此时就是排除字符组（反义字符组）的概念。例如 <code>[^abc]</code>，表示是一个除 <code>&quot;a&quot;</code>、<code>&quot;b&quot;</code>、<code>&quot;c&quot;</code>之外的任意一个字<br>符。字符组的第一位放 <code>^</code>（脱字符），表示求反的概念。</p>
<p>当然，也有相应的范围表示法。</p>
<h4 id="常见的简写形式"><a href="#常见的简写形式" class="headerlink" title="常见的简写形式"></a>常见的简写形式</h4><p>有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。</p>
<table>
<thead>
<tr>
<th>字符组</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\d</code></td>
<td>表示 <code>[0-9]</code>。表示是一位数字。<br>记忆方式：其英文是 digit（数字）。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>表示 <code>[^0-9]</code>。表示除数字外的任意字符。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>表示 <code>[0-9a-zA-Z_]</code>。表示数字、大小写字母和下划线。<br>记忆方式：w 是 word 的简写，也称单词字符。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>表示 <code>[^0-9a-zA-Z_]</code>。非单词字符。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>表示 <code>[ \t\v\n\r\f]</code>。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。<br>记忆方式：s 是 space 的首字母，空白符的单词是 white space。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>表示 <code>[^ \t\v\n\r\f]</code>。 非空白符。</td>
</tr>
<tr>
<td><code>.</code></td>
<td>表示 <code>[^\n\r\u2028\u2029]</code>。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。<br>记忆方式：想想省略号 … 中的每个点，都可以理解成占位符，表示任何类似的东西。</td>
</tr>
</tbody>
</table>
<p>如果要匹配任意字符怎么办？可以使用 <code>[\d\D]</code>、<code>[\w\W]</code>、<code>[\s\S]</code> 和 <code>[^]</code> 中任何的一个。</p>
<p>以上各字符组对应的可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.1.3.png" alt="PNG"></p>
<h3 id="量词">量词</h3>

<p>量词也称重复。掌握 <code>{m,n}</code> 的准确含义后，只需要记住一些简写形式。</p>
<h4 id="简写形式"><a href="#简写形式" class="headerlink" title="简写形式"></a>简写形式</h4><table>
<thead>
<tr>
<th>量词</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{m,}</code></td>
<td>表示至少出现 m 次。</td>
</tr>
<tr>
<td><code>{m}</code></td>
<td>等价于 <code>{m,m}</code>，表示出现 m 次。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>等价于 <code>{0,1}</code>，表示出现或者不出现。<br>记忆方式：问号的意思表示，有吗？</td>
</tr>
<tr>
<td><code>+</code></td>
<td>等价于 <code>{1,}</code>，表示出现至少一次。<br>记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。</td>
</tr>
<tr>
<td><code>*</code></td>
<td>等价于 <code>{0,}</code>，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。</td>
</tr>
</tbody>
</table>
<p>以上量词对应的可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.1.4.png" alt="PNG"></p>
<h4 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h4><p>看如下的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"123 1234 12345 123456"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["123", "1234", "12345", "12345"]</span></div></pre></td></tr></table></figure>
<p>其中正则 <code>/\d{2,5}/</code>，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字。</p>
<p>但是其是贪婪的，它会尽可能多的匹配。你能给我 6 个，我就要 5 个。你能给我 3 个，我就要 3 个。反正只要在能力范围内，越多越好。</p>
<p>我们知道有时贪婪不是一件好事（请看文章最后一个例子）。而惰性匹配，就是尽可能少的匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;?/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"123 1234 12345 123456"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["12", "12", "34", "12", "34", "12", "34", "56"]</span></div></pre></td></tr></table></figure>
<p>其中 <code>/\d{2,5}?/</code> 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。</p>
<p>通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：</p>
<table>
<thead>
<tr>
<th>惰性量词</th>
<th>贪婪量词</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{m,n}?</code></td>
<td><code>{m,n}</code></td>
</tr>
<tr>
<td><code>{m,}?</code></td>
<td><code>{m,}</code></td>
</tr>
<tr>
<td><code>??</code></td>
<td><code>?</code></td>
</tr>
<tr>
<td><code>+?</code></td>
<td><code>+</code></td>
</tr>
<tr>
<td><code>*?</code></td>
<td><code>*</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>TIP： 对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？</p>
</blockquote>
<p>以上惰性量词对应的可视化形式是：</p>
<p><img src="https://meowv.github.io/images/r.1.5.png" alt="PNG"></p>
<h3 id="分支结构">多选分支</h3>

<p>一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。</p>
<p>具体形式如下：<code>(p1|p2|p3)</code>，其中 <code>p1</code>、<code>p2</code> 和 <code>p3</code> 是子模式，用 <code>|</code>（管道符）分隔，表示其中任何之一。</p>
<p>例如要匹配字符串 <code>&quot;good&quot;</code> 和 <code>&quot;nice&quot;</code> 可以使用 <code>/good|nice/</code>。</p>
<p>可视化形式如下：</p>
<p><img src="https://meowv.github.io/images/r.1.6.png" alt="PNG"></p>
<p>测试如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|nice/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"good idea, nice try."</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["good", "nice"]</span></div></pre></td></tr></table></figure>
<p>但有个事实我们应该注意，比如我用 <code>/good|goodbye/</code>，去匹配 <code>&quot;goodbye&quot;</code> 字符串时，结果是 <code>&quot;good&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|goodbye/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"goodbye"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["good"]</span></div></pre></td></tr></table></figure>
<p>而把正则改成 <code>/goodbye|good/</code>，结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/goodbye|good/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"goodbye"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["goodbye"]</span></div></pre></td></tr></table></figure>
<p>也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。</p>
<h3 id="案例分析">案例分析</h3>

<p>匹配字符，无非就是字符组、量词和分支结构的组合使用罢了。</p>
<p>下面找几个例子演练一下（其中，每个正则并不是只有唯一写法）：</p>
<h4 id="匹配-16-进制颜色值"><a href="#匹配-16-进制颜色值" class="headerlink" title="匹配 16 进制颜色值"></a>匹配 16 进制颜色值</h4><p>要求匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#ffbbad</div><div class="line">#Fc01DF</div><div class="line">#FFF</div><div class="line">#ffE</div></pre></td></tr></table></figure>
<p>分析：</p>
<p>表示一个 16 进制字符，可以用字符组 <code>[0-9a-fA-F]</code>。</p>
<p>其中字符可以出现 3 或 6 次，需要是用量词和分支结构。</p>
<p>使用分支结构时，需要注意顺序。</p>
<p>正则如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</div><div class="line"><span class="keyword">var</span> string = <span class="string">"#ffbbad #Fc01DF #FFF #ffE"</span>;</div><div class="line"><span class="built_in">console</span>.log( string.match(regex) );</div><div class="line"><span class="comment">// =&gt; ["#ffbbad", "#Fc01DF", "#FFF", "#ffE"]</span></div></pre></td></tr></table></figure>
<p>其可视化形式：</p>
<p><img src="https://meowv.github.io/images/r.1.7.png" alt="PNG"></p>
<h4 id="匹配时间"><a href="#匹配时间" class="headerlink" title="匹配时间"></a>匹配时间</h4><p>以 24 小时制为例。</p>
<p>要求匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">23:59</div><div class="line">02:07</div></pre></td></tr></table></figure>
<p>分析：</p>
<p>共 4 位数字，第一位数字可以为 <code>[0-2]</code>。</p>
<p>当第 1 位为 <code>&quot;2&quot;</code> 时，第 2 位可以为 <code>[0-3]</code>，其他情况时，第 2 位为 <code>[0-9]</code>。</p>
<p>第 3 位数字为 <code>[0-5]</code>，第4位为 <code>[0-9]</code>。</p>
<p>正则如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^([01][0-9]|[2][0-3]):[0-5][0-9]$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"23:59"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"02:07"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>NOTE： 正则中使用了 <code>^</code> 和 <code>$</code>，分别表示字符串开头和结尾。具体详细请参考第二章。</p>
</blockquote>
<p>如果也要求匹配 <code>&quot;7:9&quot;</code>，也就是说时分前面的 <code>&quot;0&quot;</code> 可以省略。</p>
<p>此时正则变成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"23:59"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"02:07"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"7:9"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>其可视化形式：</p>
<p><img src="https://meowv.github.io/images/r.1.8.png" alt="PNG"></p>
<h4 id="匹配日期"><a href="#匹配日期" class="headerlink" title="匹配日期"></a>匹配日期</h4><p>比如 <code>yyyy-mm-dd</code> 格式为例。</p>
<p>要求匹配： <code>2017-06-10</code></p>
<p>分析：</p>
<p>年，四位数字即可，可用 <code>[0-9]{4}</code>。</p>
<p>月，共 12 个月，分两种情况 <code>&quot;01&quot;</code>、<code>&quot;02&quot;</code>、…、<code>&quot;09&quot;</code> 和 <code>&quot;10&quot;</code>、<code>&quot;11&quot;</code>、<code>&quot;12&quot;</code>，可用 <code>(0[1-9]|1[0-2])</code>。</p>
<p>日，最大 31 天，可用 <code>(0[1-9]|[12][0-9]|3[01])</code>。</p>
<p>正则如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"2017-06-10"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>其可视化形式：</p>
<p><img src="https://meowv.github.io/images/r.1.9.png" alt="PNG"></p>
<h4 id="window-操作系统文件路径"><a href="#window-操作系统文件路径" class="headerlink" title="window 操作系统文件路径"></a>window 操作系统文件路径</h4><p>要求匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">F:\study\javascript\regex\regular expression.pdf</div><div class="line">F:\study\javascript\regex\</div><div class="line">F:\study\javascript</div><div class="line">F:\</div></pre></td></tr></table></figure>
<p>分析：</p>
<p>整体模式是:  <code>盘符:\文件夹\文件夹\文件夹\</code></p>
<p>其中匹配 <code>&quot;F:\&quot;</code>，需要使用 <code>[a-zA-Z]:\\</code>，其中盘符不区分大小写，注意 \ 字符需要转义。</p>
<p>文件名或者文件夹名，不能包含一些特殊字符，此时我们需要排除字符组 <code>[^\\:*&lt;&gt;|&quot;?\r\n/]</code> 来表示合法<br>字符。</p>
<p>另外它们的名字不能为空名，至少有一个字符，也就是要使用量词 <code>+</code>。因此匹配 <code>文件夹\</code>，可用<code>[^\\:*&lt;&gt;|&quot;?\r\n/]+\\</code>。</p>
<p>另外 <code>文件夹\</code>，可以出现任意次。也就是 <code>([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*</code>。其中括号表示其内部正则是一个整体。具体详细请参考第三章。</p>
<p>路径的最后一部分可以是 <code>文件夹</code>，没有 <code>\</code>，因此需要添加 <code>([^\\:*&lt;&gt;|&quot;?\r\n/]+)?</code>。</p>
<p>最后拼接成了一个看起来比较复杂的正则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z]:\\([^\\:*&lt;&gt;|"?\r\n/]+\\)*([^\\:*&lt;&gt;|"?\r\n/]+)?$/</span>;</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript\\regex\\regular expression.pdf"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript\\regex\\"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\study\\javascript"</span>) );</div><div class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">"F:\\"</span>) );</div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div><div class="line"><span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure>
<p>其中，在JavaScript 中字符串要表示字符 <code>\</code> 时，也需要转义。</p>
<p>其可视化形式：</p>
<p><img src="https://meowv.github.io/images/r.1.10.png" alt="PNG"></p>
<h4 id="匹配-id"><a href="#匹配-id" class="headerlink" title="匹配 id"></a>匹配 id</h4><p>要求从</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>提取出 <code>id=&quot;container&quot;</code>。</p>
<p>可能最开始想到的正则是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/id=".*"/</span></div><div class="line"><span class="keyword">var</span> string = <span class="string">'&lt;div id="container" class="main"&gt;&lt;/div&gt;'</span>;</div><div class="line"><span class="built_in">console</span>.log(string.match(regex)[<span class="number">0</span>]);</div><div class="line"><span class="comment">// =&gt; id="container" class="main"</span></div></pre></td></tr></table></figure>
<p>其可视化形式：</p>
<p><img src="https://meowv.github.io/images/r.1.11.png" alt="PNG"></p>
<p>因为 <code>.</code> 是通配符，本身就匹配双引号的，而量词 <code>*</code> 又是贪婪的，当遇到 <code>container</code> 后面双引号时，是不会停下来，会继续匹配，直到遇到最后一个双引号为止。</p>
<p>解决之道，可以使用惰性匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/id=".*?"/</span></div><div class="line"><span class="keyword">var</span> string = <span class="string">'&lt;div id="container" class="main"&gt;&lt;/div&gt;'</span>;</div><div class="line"><span class="built_in">console</span>.log(string.match(regex)[<span class="number">0</span>]);</div><div class="line"><span class="comment">// =&gt; id="container"</span></div></pre></td></tr></table></figure>
<p>当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/id="[^"]*"/</span></div><div class="line"><span class="keyword">var</span> string = <span class="string">'&lt;div id="container" class="main"&gt;&lt;/div&gt;'</span>;</div><div class="line"><span class="built_in">console</span>.log(string.match(regex)[<span class="number">0</span>]);</div><div class="line"><span class="comment">// =&gt; id="container"</span></div></pre></td></tr></table></figure>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>掌握字符组和量词就能解决大部分常见的情形，也就是说，当你会了这二者，JavaScript 正则算是入门了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章-正则表达式字符匹配攻略&quot;&gt;&lt;a href=&quot;#第一章-正则表达式字符匹配攻略&quot; class=&quot;headerlink&quot; title=&quot;第一章 正则表达式字符匹配攻略&quot;&gt;&lt;/a&gt;第一章 正则表达式字符匹配攻略&lt;/h2&gt;&lt;p&gt;正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。&lt;/p&gt;
&lt;p&gt;然而关于正则如何匹配字符的学习，大部分人都觉得这块比较杂乱。&lt;/p&gt;
&lt;p&gt;毕竟元字符太多了，看起来没有系统性，不好记。本章就解决这个问题。&lt;/p&gt;
&lt;p&gt;内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#两种模糊匹配&quot;&gt;两种模糊匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#字符组&quot;&gt;字符组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#量词&quot;&gt;量词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#分支结构&quot;&gt;分支结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#案例分析&quot;&gt;案例分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;两种模糊匹配&quot;&gt;两种模糊匹配&lt;/h3&gt;

&lt;p&gt;如果正则只有精确匹配是没多大意义的，比如 &lt;code&gt;/hello/&lt;/code&gt;，也只能匹配字符串中的 &lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt; 这个子串。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; regex = &lt;span class=&quot;regexp&quot;&gt;/hello/&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(regex.test(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// =&amp;gt; true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="http://xj8c.cc/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://xj8c.cc/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>今日头条全站新闻文章数据爬取</title>
    <link href="http://xj8c.cc/2017/09/27/ToutiaoNews/"/>
    <id>http://xj8c.cc/2017/09/27/ToutiaoNews/</id>
    <published>2017-09-27T06:23:48.000Z</published>
    <updated>2017-09-27T06:25:38.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日头条全站新闻文章数据爬取"><a href="#今日头条全站新闻文章数据爬取" class="headerlink" title="今日头条全站新闻文章数据爬取"></a>今日头条全站新闻文章数据爬取</h1><p>url:<a href="https://www.toutiao.com/api/pc/feed/" target="_blank" rel="external">https://www.toutiao.com/api/pc/feed/</a></p>
<p>拼接参数：</p>
<ul>
<li><code>category</code>：见下<a href="#category">category</a>表格</li>
<li><code>utm_source</code>：</li>
<li><code>widen</code>：</li>
<li><code>max_behot_time</code>：</li>
<li><code>max_behot_time_tmp</code>：</li>
<li><code>tadrequire</code>：</li>
<li><code>as</code>：</li>
<li><code>cp</code>：<a id="more"></a>
<h2 id="category">category 列表</h2>

</li>
</ul>
<table>
<thead>
<tr>
<th>标签</th>
<th style="text-align:center">category值</th>
</tr>
</thead>
<tbody>
<tr>
<td>推荐</td>
<td style="text-align:center">__all__</td>
</tr>
<tr>
<td>热点</td>
<td style="text-align:center">news_hot</td>
</tr>
<tr>
<td>科技</td>
<td style="text-align:center">news_tech</td>
</tr>
<tr>
<td>社会</td>
<td style="text-align:center">news_society</td>
</tr>
<tr>
<td>娱乐</td>
<td style="text-align:center">news_entertainment</td>
</tr>
<tr>
<td>游戏</td>
<td style="text-align:center">news_game</td>
</tr>
<tr>
<td>体育</td>
<td style="text-align:center">news_sports</td>
</tr>
<tr>
<td>汽车</td>
<td style="text-align:center">news_car</td>
</tr>
<tr>
<td>财经</td>
<td style="text-align:center">news_finance</td>
</tr>
<tr>
<td>搞笑</td>
<td style="text-align:center">funny</td>
</tr>
<tr>
<td>段子</td>
<td style="text-align:center">essay_joke</td>
</tr>
<tr>
<td>军事</td>
<td style="text-align:center">news_military</td>
</tr>
<tr>
<td>国际</td>
<td style="text-align:center">news_world</td>
</tr>
<tr>
<td>时尚</td>
<td style="text-align:center">news_fashion</td>
</tr>
<tr>
<td>旅游</td>
<td style="text-align:center">news_travel</td>
</tr>
<tr>
<td>探索</td>
<td style="text-align:center">news_discovery</td>
</tr>
<tr>
<td>育儿</td>
<td style="text-align:center">news_baby</td>
</tr>
<tr>
<td>养生</td>
<td style="text-align:center">news_regimen</td>
</tr>
<tr>
<td>美文</td>
<td style="text-align:center">news_essay</td>
</tr>
<tr>
<td>历史</td>
<td style="text-align:center">news_history</td>
</tr>
<tr>
<td>美食</td>
<td style="text-align:center">news_food</td>
</tr>
<tr>
<td>…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>json接口示例:<a href="https://www.toutiao.com/api/pc/feed/?category=news_hot" target="_blank" rel="external">https://www.toutiao.com/api/pc/feed/?category=news_hot</a></p>
<h1 id="源代码下载"><a href="#源代码下载" class="headerlink" title="源代码下载"></a>源代码下载</h1><p><a href="https://github.com/Meowv/ToutiaoNews" target="_blank" rel="external">ToutiaoNews</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今日头条全站新闻文章数据爬取&quot;&gt;&lt;a href=&quot;#今日头条全站新闻文章数据爬取&quot; class=&quot;headerlink&quot; title=&quot;今日头条全站新闻文章数据爬取&quot;&gt;&lt;/a&gt;今日头条全站新闻文章数据爬取&lt;/h1&gt;&lt;p&gt;url:&lt;a href=&quot;https://www.toutiao.com/api/pc/feed/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.toutiao.com/api/pc/feed/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;拼接参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;category&lt;/code&gt;：见下&lt;a href=&quot;#category&quot;&gt;category&lt;/a&gt;表格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utm_source&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;widen&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_behot_time&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_behot_time_tmp&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tadrequire&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp&lt;/code&gt;：
    
    </summary>
    
    
      <category term="HtmlAgilityPack" scheme="http://xj8c.cc/tags/HtmlAgilityPack/"/>
    
      <category term="爬虫" scheme="http://xj8c.cc/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="今日头条" scheme="http://xj8c.cc/tags/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1/"/>
    
      <category term="Newtonsoft.Json" scheme="http://xj8c.cc/tags/Newtonsoft-Json/"/>
    
  </entry>
  
  <entry>
    <title>HtmlAgilityPack爬取美女图片、每日一文文章、小说</title>
    <link href="http://xj8c.cc/2017/09/07/HtmlAgilityPack/"/>
    <id>http://xj8c.cc/2017/09/07/HtmlAgilityPack/</id>
    <published>2017-09-07T01:23:53.000Z</published>
    <updated>2017-09-07T09:51:27.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HtmlAgilityPack？"><a href="#HtmlAgilityPack？" class="headerlink" title="HtmlAgilityPack？"></a>HtmlAgilityPack？</h1><p>HtmlAgilityPack 是 .NET 下的一个 HTML 解析类库。支持用 XPath 来解析 HTML 。命名空间： HtmlAgilityPack</p>
<h1 id="爬取美女图片核心代码"><a href="#爬取美女图片核心代码" class="headerlink" title="爬取美女图片核心代码"></a>爬取美女图片核心代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args)</div><div class="line">&#123;</div><div class="line">    HtmlWeb web = new HtmlWeb();</div><div class="line">    string path = @&quot;F:\pic\&quot;;</div><div class="line">    </div><div class="line">    for (int i = 88; i &gt;= 1; i--)</div><div class="line">    &#123;</div><div class="line">        var url = &quot;http://jandan.net/ooxx/page-&quot; + i;</div><div class="line"></div><div class="line">        HtmlDocument doc = web.Load(url);</div><div class="line"></div><div class="line">        List&lt;HtmlNode&gt; nodeList = doc.DocumentNode.SelectNodes(&quot;//*[@class=\&quot;commentlist\&quot;]/li&quot;).AsParallel().ToList();</div><div class="line"></div><div class="line">        foreach (var item in nodeList)</div><div class="line">        &#123;</div><div class="line">            HtmlNode imghtml = item.SelectSingleNode(&quot;.//img&quot;);</div><div class="line">            var imgsrc = &quot;http:&quot; + imghtml.Attributes[&quot;src&quot;].Value;</div><div class="line">            var imgname = Guid.NewGuid().ToString() + imgsrc.Substring(imgsrc.Length - 4, 4);</div><div class="line"></div><div class="line">            Console.WriteLine(imgsrc);</div><div class="line"></div><div class="line">            DownPic(imgsrc, path + imgname);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="爬取每日一文核心代码"><a href="#爬取每日一文核心代码" class="headerlink" title="爬取每日一文核心代码"></a>爬取每日一文核心代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var url = &quot;https://meiriyiwen.com/random/&quot;;</div><div class="line"></div><div class="line">HtmlWeb web = new HtmlWeb();</div><div class="line">HtmlDocument doc = web.Load(url);</div><div class="line">HtmlNode node = doc.DocumentNode.SelectSingleNode(&quot;//*[@id=\&quot;article_show\&quot;]&quot;);</div><div class="line">node.Descendants()</div><div class="line">    .Where(n =&gt; n.Name == &quot;script&quot; || n.Name == &quot;style&quot; || n.Name == &quot;#comment&quot; || n.Id == &quot;bdshare&quot;)</div><div class="line">    .ToList().ForEach(n =&gt; n.Remove());</div><div class="line">    </div><div class="line">var title = node.SelectSingleNode(&quot;//h1&quot;).InnerText;</div><div class="line">var author = node.SelectSingleNode(&quot;//*[@class=\&quot;article_author\&quot;]&quot;).InnerText;</div><div class="line">var article = node.SelectSingleNode(&quot;//*[@class=\&quot;article_text\&quot;]&quot;).InnerText.TrimStart();</div></pre></td></tr></table></figure>
<h1 id="爬取小说核心代码"><a href="#爬取小说核心代码" class="headerlink" title="爬取小说核心代码"></a>爬取小说核心代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args)</div><div class="line">&#123;</div><div class="line">    var domain = &quot;http://www.jueshitangmen.info&quot;;</div><div class="line"></div><div class="line">    HtmlWeb web = new HtmlWeb();</div><div class="line"></div><div class="line">    HtmlDocument doc = web.Load(domain + &quot;/zhetian/&quot;);</div><div class="line">    List&lt;HtmlNode&gt; nodeList = doc.DocumentNode.SelectNodes(&quot;//*[@class=\&quot;panel\&quot;]/ul/li&quot;).AsParallel().ToList();</div><div class="line"></div><div class="line">    foreach (var item in nodeList)</div><div class="line">    &#123;</div><div class="line">        HtmlNode html = item.SelectSingleNode(&quot;.//span/a&quot;);</div><div class="line">        var title = html.InnerText;</div><div class="line"></div><div class="line">        var url = html.Attributes[&quot;href&quot;].Value;</div><div class="line">        HtmlDocument document = web.Load(url);</div><div class="line"></div><div class="line">        HtmlNode node = document.DocumentNode.SelectSingleNode(&quot;//*[@class=\&quot;content\&quot;]&quot;);</div><div class="line">        node.Descendants()</div><div class="line">            .Where(n =&gt; n.Name == &quot;script&quot; || n.Name == &quot;style&quot; || n.Name == &quot;#comment&quot;)</div><div class="line">            .ToList().ForEach(n =&gt; n.Remove());</div><div class="line"></div><div class="line">        var content = node.InnerText.Trim();</div><div class="line"></div><div class="line">        Console.WriteLine(title + &quot;\r\n&quot;);</div><div class="line">        Console.WriteLine(content);</div><div class="line"></div><div class="line">        StreamWriter stream = new StreamWriter(@&quot;F:\Article\遮天\&quot; + title + &quot;.txt&quot;);</div><div class="line"></div><div class="line">        stream.WriteLine(title + &quot;\r\n&quot;);</div><div class="line">        stream.WriteLine(content);</div><div class="line"></div><div class="line">        stream.Close();</div><div class="line">        stream.Dispose();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="源代码下载"><a href="#源代码下载" class="headerlink" title="源代码下载"></a>源代码下载</h1><p><a href="https://github.com/Meowv/HtmlAgilityPack" target="_blank" rel="external">HtmlAgilityPackDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HtmlAgilityPack？&quot;&gt;&lt;a href=&quot;#HtmlAgilityPack？&quot; class=&quot;headerlink&quot; title=&quot;HtmlAgilityPack？&quot;&gt;&lt;/a&gt;HtmlAgilityPack？&lt;/h1&gt;&lt;p&gt;HtmlAgilityPack 是 .NET 下的一个 HTML 解析类库。支持用 XPath 来解析 HTML 。命名空间： HtmlAgilityPack&lt;/p&gt;
&lt;h1 id=&quot;爬取美女图片核心代码&quot;&gt;&lt;a href=&quot;#爬取美女图片核心代码&quot; class=&quot;headerlink&quot; title=&quot;爬取美女图片核心代码&quot;&gt;&lt;/a&gt;爬取美女图片核心代码&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;static void Main(string[] args)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    HtmlWeb web = new HtmlWeb();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    string path = @&amp;quot;F:\pic\&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for (int i = 88; i &amp;gt;= 1; i--)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        var url = &amp;quot;http://jandan.net/ooxx/page-&amp;quot; + i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        HtmlDocument doc = web.Load(url);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        List&amp;lt;HtmlNode&amp;gt; nodeList = doc.DocumentNode.SelectNodes(&amp;quot;//*[@class=\&amp;quot;commentlist\&amp;quot;]/li&amp;quot;).AsParallel().ToList();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        foreach (var item in nodeList)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            HtmlNode imghtml = item.SelectSingleNode(&amp;quot;.//img&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            var imgsrc = &amp;quot;http:&amp;quot; + imghtml.Attributes[&amp;quot;src&amp;quot;].Value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            var imgname = Guid.NewGuid().ToString() + imgsrc.Substring(imgsrc.Length - 4, 4);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            Console.WriteLine(imgsrc);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            DownPic(imgsrc, path + imgname);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="HtmlAgilityPack" scheme="http://xj8c.cc/tags/HtmlAgilityPack/"/>
    
      <category term="爬虫" scheme="http://xj8c.cc/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative开发中一些有用的资源</title>
    <link href="http://xj8c.cc/2017/07/18/ReactNative-resource/"/>
    <id>http://xj8c.cc/2017/07/18/ReactNative-resource/</id>
    <published>2017-07-18T08:47:42.000Z</published>
    <updated>2017-07-21T03:29:24.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些有用的资源"><a href="#一些有用的资源" class="headerlink" title="一些有用的资源"></a>一些有用的资源</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>英文（官方）：</p>
<p><a href="https://facebook.github.io/react-native" target="_blank" rel="external">https://facebook.github.io/react-native</a></p>
<p>中文：</p>
<p><a href="http://reactnative.cn" target="_blank" rel="external">http://reactnative.cn</a><br><a id="more"></a></p>
<h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><p>GitHub：</p>
<p><a href="https://github.com/facebook/react-native" target="_blank" rel="external">https://github.com/facebook/react-native</a></p>
<p>stackoverflow:</p>
<p><a href="http://stackoverflow.com/questions/tagged/react-native" target="_blank" rel="external">http://stackoverflow.com/questions/tagged/react-native</a></p>
<p>椰子壳:</p>
<p><a href="https://www.yeziker.com" target="_blank" rel="external">https://www.yeziker.com</a></p>
<h2 id="示例App"><a href="#示例App" class="headerlink" title="示例App"></a>示例App</h2><p>Examples：</p>
<p><a href="https://github.com/facebook/react-native/tree/master/Examples/UIExplorer" target="_blank" rel="external">https://github.com/facebook/react-native/tree/master/Examples/UIExplorer</a></p>
<p>F8App：</p>
<p><a href="https://github.com/fbsamples/f8app" target="_blank" rel="external">https://github.com/fbsamples/f8app</a></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>react-native-elements：</p>
<p><a href="https://github.com/react-native-training/react-native-elements" target="_blank" rel="external">https://github.com/react-native-training/react-native-elements</a></p>
<p>react-native-vector-icons：</p>
<p><a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="external">https://github.com/oblador/react-native-vector-icons</a></p>
<p>NativeBase：</p>
<p><a href="https://github.com/GeekyAnts/NativeBase" target="_blank" rel="external">https://github.com/GeekyAnts/NativeBase</a></p>
<p>react-native-video：</p>
<p><a href="https://github.com/react-native-community/react-native-video" target="_blank" rel="external">https://github.com/react-native-community/react-native-video</a></p>
<p>Realm：</p>
<p><a href="https://github.com/realm/realm-js" target="_blank" rel="external">https://github.com/realm/realm-js</a></p>
<p>react-native-maps：</p>
<p><a href="https://github.com/airbnb/react-native-maps" target="_blank" rel="external">https://github.com/airbnb/react-native-maps</a></p>
<p>react-native-app-intro：</p>
<p><a href="https://github.com/FuYaoDe/react-native-app-intro" target="_blank" rel="external">https://github.com/FuYaoDe/react-native-app-intro</a></p>
<p>react-native-chart：</p>
<p><a href="https://github.com/tomauty/react-native-chart" target="_blank" rel="external">https://github.com/tomauty/react-native-chart</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一些有用的资源&quot;&gt;&lt;a href=&quot;#一些有用的资源&quot; class=&quot;headerlink&quot; title=&quot;一些有用的资源&quot;&gt;&lt;/a&gt;一些有用的资源&lt;/h1&gt;&lt;h2 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h2&gt;&lt;p&gt;英文（官方）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://facebook.github.io/react-native&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://facebook.github.io/react-native&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://reactnative.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactnative.cn&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative样式总览</title>
    <link href="http://xj8c.cc/2017/07/17/ReactNative-styles/"/>
    <id>http://xj8c.cc/2017/07/17/ReactNative-styles/</id>
    <published>2017-07-17T08:46:47.000Z</published>
    <updated>2017-07-21T03:32:22.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="边框："><a href="#边框：" class="headerlink" title="边框："></a>边框：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">颜色</div><div class="line">borderColor: color</div><div class="line">borderBottomColor: color</div><div class="line">borderLeftColor: color</div><div class="line">borderTopColor: color</div><div class="line">borderRightColor: color</div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">圆角</div><div class="line">borderRadius: number</div><div class="line">borderBottomLeftRadius: number</div><div class="line">borderBottomRightRadius: number</div><div class="line">borderTopLeftRadius: number</div><div class="line">borderTopRightRadius: number</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">宽度</div><div class="line">borderWidth: number</div><div class="line">borderBottomWidth: number</div><div class="line">borderLeftWidth: number</div><div class="line">borderRightWidth: number</div><div class="line">borderTopWidth: number</div><div class="line">样式</div><div class="line">borderStyle: enum(&apos;solid&apos;, &apos;dotted&apos;, &apos;dashed&apos;)</div></pre></td></tr></table></figure>
<h2 id="边距："><a href="#边距：" class="headerlink" title="边距："></a>边距：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">内边距</div><div class="line">padding: number</div><div class="line">paddingBottom: number</div><div class="line">paddingLeft: number</div><div class="line">paddingRight: number</div><div class="line">paddingTop: number</div><div class="line">paddingHorizontal: number (左右内边距)</div><div class="line">paddingVertical: number (上下内边距)</div><div class="line"></div><div class="line">外边距</div><div class="line">margin: number</div><div class="line">marginBottom: number</div><div class="line">marginLeft: number</div><div class="line">marginRight: number</div><div class="line">marginTop: number</div><div class="line"></div><div class="line">marginHorizontal: number (左右内边距)</div><div class="line">marginVertical: number (上下外边距)</div></pre></td></tr></table></figure>
<h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">color: color</div><div class="line">fontFamily: string</div><div class="line">fontSize: number</div><div class="line">fontStyle: enum(&apos;normal&apos;, &apos;italic&apos;)</div><div class="line">fontWeight: enum(&apos;normal&apos;, &apos;bold&apos;, &apos;100&apos;, &apos;200&apos;, &apos;300&apos;, &apos;400&apos;, &apos;500&apos;, &apos;600&apos;, &apos;700&apos;, &apos;800&apos;, &apos;900&apos;)</div><div class="line">textDecorationColor: color (文本修饰颜色)</div><div class="line">textDecorationLine: enum(&apos;none&apos;, &apos;underline&apos;, &apos;line-through&apos;, &apos;underline line-through&apos;) </div><div class="line">textDecorationStyle: enum(&apos;solid&apos;, &apos;double&apos;, &apos;dashed&apos;, &apos;dotted&apos;)</div><div class="line">letterSpacing: number</div><div class="line">lineHeight:number</div><div class="line">textAlign: enum(&apos;auto&apos;, &apos;left&apos;, &apos;right&apos;, &apos;center&apos;, &apos;justify&apos;)</div></pre></td></tr></table></figure>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">backgroundColor: color</div><div class="line"></div><div class="line">flex: number</div><div class="line">flexDirection: enum(&apos;row&apos;, &apos;row-reverse&apos;, &apos;column&apos;, &apos;column-reverse&apos;)</div><div class="line">flexWrap: enum(&apos;wrap&apos;, &apos;nowrap&apos;) </div><div class="line">justifyContent: enum(&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;space-between&apos;, &apos;space-around&apos;) </div><div class="line">alignItems: enum(&apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) </div><div class="line">alignSelf: enum(&apos;auto&apos;, &apos;flex-start&apos;, &apos;flex-end&apos;, &apos;center&apos;, &apos;stretch&apos;) </div><div class="line"></div><div class="line">position: enum(&apos;absolute&apos;, &apos;relative&apos;)</div><div class="line">right: number</div><div class="line">left: number</div><div class="line">top: number</div><div class="line">bottom: number</div><div class="line">width: number</div><div class="line">height: number</div></pre></td></tr></table></figure>
<h2 id="图形变换"><a href="#图形变换" class="headerlink" title="图形变换"></a>图形变换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scaleX:水平方向缩放</div><div class="line">scaleY:垂直方向缩放</div><div class="line">rotation:旋转</div><div class="line">translateX:水平方向平移</div><div class="line">translateY:水平方向平移</div></pre></td></tr></table></figure>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><h4 id="说个悲惨的故事，阴影只能在ios用"><a href="#说个悲惨的故事，阴影只能在ios用" class="headerlink" title="说个悲惨的故事，阴影只能在ios用"></a>说个悲惨的故事，阴影只能在ios用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shadowColor: color</div><div class="line">shadowOffset: &#123;width: number, height: number&#125; </div><div class="line">shadowOpacity: number</div><div class="line">shadowRadius: number</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;边框：&quot;&gt;&lt;a href=&quot;#边框：&quot; class=&quot;headerlink&quot; title=&quot;边框：&quot;&gt;&lt;/a&gt;边框：&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;颜色&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;borderColor: color&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;borderBottomColor: color&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;borderLeftColor: color&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;borderTopColor: color&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;borderRightColor: color&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>打包你的App</title>
    <link href="http://xj8c.cc/2017/07/16/ReactNative-build/"/>
    <id>http://xj8c.cc/2017/07/16/ReactNative-build/</id>
    <published>2017-07-16T08:45:13.000Z</published>
    <updated>2017-07-21T03:29:02.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包应用"><a href="#打包应用" class="headerlink" title="打包应用"></a>打包应用</h1><p>假设你的应用做完了，总不能还在后台开着packager就把应用发布出去吧。很明显，我们需要让应用可以离线，下边所要讲的就是<br>一个让应用脱离packager的过程<br><a id="more"></a></p>
<h2 id="生成签名"><a href="#生成签名" class="headerlink" title="生成签名"></a>生成签名</h2><p>没签名直接打包应用是不行的，我们需要实现生成一个签名。在Linux下，我们执行这条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -genkey -v -keystore RN-key.keystore -alias RN-key-alias -keyalg RSA -keysize 2048 -validity 10000</div></pre></td></tr></table></figure>
<p>然后会让你设置最少6位的密码，密码一定要记好，作者君的建议是两个密码最好不要设置成一样的~</p>
<p>至于Windows，我们得进到JDK目录下执行此命令，或者使用一些傻瓜式的签名生成软件。</p>
<h2 id="修改gradle变量"><a href="#修改gradle变量" class="headerlink" title="修改gradle变量"></a>修改gradle变量</h2><p>将生成的RN-key.keystore放到android/app文件夹中，然后修改在android目录下的gradle.properties，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MYAPP_RELEASE_STORE_FILE=RN-key.keystore</div><div class="line">MYAPP_RELEASE_KEY_ALIAS=RN-key-alias </div><div class="line">MYAPP_RELEASE_STORE_PASSWORD=your password</div><div class="line">MYAPP_RELEASE_KEY_PASSWORD=your password</div></pre></td></tr></table></figure>
<h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><p>修改android/app目录下的build.gradle，在<code>defaultConfig</code>代码块下增加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">signingConfigs &#123;</div><div class="line">        release &#123;</div><div class="line">            storeFile file(&quot;RN-key.keystore&quot;)</div><div class="line">            storePassword your password</div><div class="line">            keyAlias RN-key-alias </div><div class="line">            keyPassword your password</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在buildTypes中的release下添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">signingConfig signingConfigs.release</div></pre></td></tr></table></figure>
<p>整体就像这样：</p>
<p><img src="https://meowv.github.io/images/10.1.png" alt="PNG"></p>
<h2 id="打包应用-1"><a href="#打包应用-1" class="headerlink" title="打包应用"></a>打包应用</h2><p>进入项目所在目录，执行以下命令（packger应该处于开启状态）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd android &amp;&amp; ./gradlew assembleRelease</div></pre></td></tr></table></figure>
<p>Windows用户不用写<code>./</code>，漫长的等待过后，我们便可以在<br>android/app/build/outputs/apk下找到我们的应用了，并且这个可以发布到各大应用市场。</p>
<h2 id="混淆及安全"><a href="#混淆及安全" class="headerlink" title="混淆及安全"></a>混淆及安全</h2><p>为了安全（也为了缩小apk大小），我们需要启用代码混淆。进入android/app目录，然后修改build.gradle文件，<br>将<code>def enableProguardInReleaseBuilds = false</code>改为<code>def enableProguardInReleaseBuilds = true</code></p>
<p>如果不准备同时支持ARM和X86，那么将<code>enableSeparateBuildPerCPUArchitecture</code>改为true可以给安装包减少4mb大小~</p>
<h2 id="修改icon"><a href="#修改icon" class="headerlink" title="修改icon"></a>修改icon</h2><p>进入android/app/src/main/res目录，我们可以看到有这么几个子目录：</p>
<p><img src="https://meowv.github.io/images/10.2.png" alt="PNG"></p>
<p>然后把这四个目录下的图片换成别的就可以啦，尺寸要对上哟~</p>
<h2 id="修改应用名称"><a href="#修改应用名称" class="headerlink" title="修改应用名称"></a>修改应用名称</h2><p>假设我们想将应用的名字换成<code>茯苓</code>要怎么办呢？很简单，还是在res目录，我们进入values目录，修改strings.xml即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;resources&gt;</div><div class="line">    &lt;string name=&quot;app_name&quot;&gt;茯苓&lt;/string&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;打包应用&quot;&gt;&lt;a href=&quot;#打包应用&quot; class=&quot;headerlink&quot; title=&quot;打包应用&quot;&gt;&lt;/a&gt;打包应用&lt;/h1&gt;&lt;p&gt;假设你的应用做完了，总不能还在后台开着packager就把应用发布出去吧。很明显，我们需要让应用可以离线，下边所要讲的就是&lt;br&gt;一个让应用脱离packager的过程&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>掌握React Native的Fetch Api</title>
    <link href="http://xj8c.cc/2017/07/15/ReactNative-net/"/>
    <id>http://xj8c.cc/2017/07/15/ReactNative-net/</id>
    <published>2017-07-15T08:43:47.000Z</published>
    <updated>2017-07-21T03:29:11.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>这一章呢，不会只讲网络哦~</p>
<h2 id="Mock-Api"><a href="#Mock-Api" class="headerlink" title="Mock Api"></a>Mock Api</h2><p>Mock Api是一项非常棒的服务，它可以帮助我们快速的模拟后端的REST Api并且不需要你自己的服务器，甚至代码都不用写，它的网址是<br><a href="http://www.mockapi.io/，" target="_blank" rel="external">http://www.mockapi.io/，</a> 可以注册也可以使用GitHub帐号登陆。<br><a id="more"></a><br>点击<code>+</code>来创建一个项目：</p>
<p><img src="https://meowv.github.io/images/9.1.png" alt="PNG"></p>
<p>填写项目名称和Api前缀(随便写就行)：</p>
<p><img src="https://meowv.github.io/images/9.2.png" alt="PNG"></p>
<p>接下来点击Create Resource来创建资源：</p>
<p><img src="https://meowv.github.io/images/9.3.png" alt="PNG"></p>
<p>然后填写资源名称，以及修改Schema，为了方便，我们就留下id和name：</p>
<p><img src="https://meowv.github.io/images/9.4.png" alt="PNG"></p>
<p>然后点击next按钮，这一步完了之后，我们就可以通过<code>xxxxxxx.mockapi.io/api/user</code>使用REST Api了。</p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>在React Native中，我们可以使用Fetch来进行网络请求，由于Fetch API天然支持Promise规范，所以我们的代码可以变得很优雅。</p>
<p>执行Get操作应该是最为简单的了，我们看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fetch(&apos;http://xxx.mockapi.io/api/user&apos;)</div><div class="line">  .then((response) =&gt; &#123;</div><div class="line">    console.log(response);</div><div class="line">  &#125;)</div><div class="line">  .catch((err) =&gt; console.error(err);)</div></pre></td></tr></table></figure>
<p>这样便可以在控制台打印出user下的所有内容。你可能会想：喵喵喵？React Native还有控制台？ 当然有啦，不过我们得打开远程调试，首先打开菜单：</p>
<p><img src="https://meowv.github.io/images/9.5.png" alt="PNG"></p>
<p>然后选择Debug Js Remotely，之后便会自动打开Chrome。自己打开Chrome的控制台便可以看到<code>console.log</code>的内容了。</p>
<p>实际应用中，我们会在组件渲染的时候把数据丢到状态或别的地方，然后使用这些数据(一般会用作列表渲染)。不管怎么说，不会直接console就是了。</p>
<p>然后是Post：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fetch(&apos;http://xxxx.mockapi.io/api/user&apos;, &#123;</div><div class="line">  method: &apos;POST&apos;,</div><div class="line">  headers: &#123;</div><div class="line">    &apos;Accept&apos;: &apos;application/json&apos;,</div><div class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;,</div><div class="line">  &#125;,</div><div class="line">  body: JSON.stringify(&#123;</div><div class="line">    name: &apos;meow&apos;,</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line">  .then(xxxx)</div><div class="line">  .catch((err) =&gt; console.error(err))</div></pre></td></tr></table></figure>
<p>我们可以加个then来处理在Post过程中要做的事情，并用catch来获取异常。</p>
<p>至于Put和Delete参考Post就好啦~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h1&gt;&lt;p&gt;这一章呢，不会只讲网络哦~&lt;/p&gt;
&lt;h2 id=&quot;Mock-Api&quot;&gt;&lt;a href=&quot;#Mock-Api&quot; class=&quot;headerlink&quot; title=&quot;Mock Api&quot;&gt;&lt;/a&gt;Mock Api&lt;/h2&gt;&lt;p&gt;Mock Api是一项非常棒的服务，它可以帮助我们快速的模拟后端的REST Api并且不需要你自己的服务器，甚至代码都不用写，它的网址是&lt;br&gt;&lt;a href=&quot;http://www.mockapi.io/，&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mockapi.io/，&lt;/a&gt; 可以注册也可以使用GitHub帐号登陆。&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>是时候用上React Navigation了</title>
    <link href="http://xj8c.cc/2017/07/14/ReactNative-navigation/"/>
    <id>http://xj8c.cc/2017/07/14/ReactNative-navigation/</id>
    <published>2017-07-14T08:42:18.000Z</published>
    <updated>2017-07-21T03:29:06.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导航器"><a href="#导航器" class="headerlink" title="导航器"></a>导航器</h1><p>一个应用（普通的那种），总是有好多个界面，只有一个界面的应用怎么能留得住用户呢？（虽然有很多界面的也不一定留得住）<br>所以说，做应用一般不会只做一个页面。我们知道，网页之间可以自由跳转，通过一个<code>&lt;a&gt;&lt;/a&gt;</code>就可以搞定了，但是<br>开发应用不是写网页，React Native中也没有<code>&lt;a&gt;</code>，那当我们需要做界面跳转的时候该怎么办呢？答案是使用<code>Navigator</code>组件。<br>哈哈，逗你的，在0.42版本前使用<code>Navigator</code>来实现导航效果没问题，不过呢，自从0.43版本之后React Native将停止维护这个组件了，<br>因为出现了更好用的<code>React Navigation</code>（半官方）。<br><a id="more"></a><br>首先我们来安装它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save react-navigation</div></pre></td></tr></table></figure>
<p>然后重新启动你的应用</p>
<p>作者君在安装这个库的时候，它的版本是beta7,有一个小bug需要处理一下，删掉<code>node_modules/react-navigation/src/views/Header.js</code>的第12行，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import ReactComponentWithPureRenderMixin from &apos;react/lib/ReactComponentWithPureRenderMixin&apos;;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>不然直接红屏报错。</p>
<p>安装完毕后，我们来一个简单的例子，首先我们需要引入它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &#123; StackNavigator &#125; from &apos;react-navigation&apos;;</div></pre></td></tr></table></figure>
<p>然后写两个组件，一个叫<code>HelloScreen</code>，一个叫<code>UserScreen</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">class HelloScreen extends Component &#123;</div><div class="line">  static navigationOptions = &#123;</div><div class="line">    title: &apos;Hello&apos;,</div><div class="line">  &#125;;</div><div class="line">  render() &#123;</div><div class="line">    const &#123; navigate &#125; = this.props.navigation;</div><div class="line">    return (</div><div class="line">      &lt;View&gt;</div><div class="line">        &lt;Text&gt;&#123;&apos;\n&apos;&#125;&lt;/Text&gt;</div><div class="line">        &lt;Text&gt;按下边的按钮&lt;/Text&gt;</div><div class="line">        &lt;Button</div><div class="line">          onPress=&#123;() =&gt; navigate(&apos;User&apos;)&#125;</div><div class="line">          title=&quot;Go&quot;</div><div class="line">        /&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;&#125;</div><div class="line"></div><div class="line">  class UserScreen extends Component &#123;</div><div class="line">  static navigationOptions = &#123;</div><div class="line">    title: &apos;这里是~&apos;,</div><div class="line">  &#125;;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View&gt;</div><div class="line">        &lt;Text&gt;&#123;&apos;\n&apos;&#125;&lt;/Text&gt;</div><div class="line">        &lt;Text&gt;嘿，猜猜这里是谁？&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其实在按钮里面写方法并不优雅，翻过了issues之后觉得都不是很好，所以这里就期待一下官方的变化吧</p>
</blockquote>
<p>这两个组件和正常的组件差不多，不过是多了些东西罢了。其中，<code>navigationOptions</code>数组里可以放些配置信息，一般用来配置Header部分。<br>HelloScreen里的<code>const { navigate } = this.props.navigation</code>是为了可以在组件中使用<code>navigate</code>方法。<code>navigate(...)</code>理解成<br>跳转到那个界面就好。不过，光有这两个组件可看不出来什么，我们还需要一个<code>StackNavigator</code>来使导航可以正常运作。（可以把这个当成一个特殊的组件，更好理解）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const MyApp = StackNavigator(&#123;</div><div class="line">  Home: &#123; screen: HelloScreen &#125;,</div><div class="line">  User: &#123; screen: UserScreen &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里的<code>Home</code>和<code>User</code>是路由别名，在使用<code>navigate</code>时需要用到。然后改一下注册的组件，就像下边那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AppRegistry.registerComponent(&apos;AppName&apos;, () =&gt; MyApp);</div></pre></td></tr></table></figure>
<p>好啦，我们刷新一下应用：</p>
<p><img src="https://meowv.github.io/images/8.1.png" alt="PNG"></p>
<p>然后点一下Go按钮：</p>
<p><img src="https://meowv.github.io/images/8.2.png" alt="PNG"></p>
<p>就像这样，几行代码轻轻松松便实现了导航效果，甚至连头部都帮你做好了~</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>很多时候，我们需要像要跳转的界面传递些参数，比如，某条数据的id，用户的名字。我们只需要把上边的例子小小的修改一下就可以传递参数了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//修改navigate方法</div><div class="line">navigate(&apos;User&apos;, &#123; id: &apos;233333333&apos;, name: &apos;nico&apos; &#125;);</div></pre></td></tr></table></figure>
<p>然后接受参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">    const &#123; params &#125; = this.props.navigation.state;</div><div class="line">    return (</div><div class="line">      &lt;View&gt;</div><div class="line">        &lt;Text&gt;&#123;&apos;\n&apos;&#125;&lt;/Text&gt;</div><div class="line">        &lt;Text&gt;嘿，这里是&#123;params.name&#125;，id是：&#123;params.id&#125;&lt;&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这样就实现参数的传递啦，快刷新一下看看效果吧~</p>
<h2 id="定制头部"><a href="#定制头部" class="headerlink" title="定制头部"></a>定制头部</h2><p>前边说过，<code>navigationOptions</code>里面会放些配置信息，我们可以用这个来定制头部，比如说在右边加一个按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static navigationOptions = &#123;</div><div class="line">  title: &apos;hahaha&apos;,</div><div class="line">  headerRight: &lt;Button title=&quot;你好&quot; /&gt;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>理论上来说，它会在右边显示一个按钮，但是并不行，一脸茫然的作者君去翻了下GitHub，发现别人也遇到了这些问题，然后默默的更新了<br>一下<code>react-navigation</code>，从beta7升到了beta9：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm update react-navigation</div></pre></td></tr></table></figure>
<p>然后刷新一下应用就可以发现按钮乖乖的显示在那里了：</p>
<p><img src="https://meowv.github.io/images/8.3.png" alt="PNG"></p>
<p>除了按钮，你还可以丢个<text>之类的过去，都是可以的。</text></p>
<h2 id="Tab-Navigator"><a href="#Tab-Navigator" class="headerlink" title="Tab Navigator"></a>Tab Navigator</h2><p>如果需要Tab导航，我们使用其内置的<code>TabNavigator</code>即可，用法和<code>StackNavigator</code>差不多，只要在最后使用<code>TabNavigator</code>即可<br>就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const XXX = TabNavigator(&#123;</div><div class="line">  ......</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果想要混用<code>StackNavigator</code>和<code>TabNavigator</code>则稍稍麻烦一点，首先，我们写两个新的组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class HiScreen extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;Text&gt;Hi&lt;/Text&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class WorldScreen extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;Text&gt;World&lt;/Text&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后使用<code>TabNavigator</code>：</p>
<p>const TabScreen = TabNavigator({<br>  Hi: { screen: HiScreen },<br>  World: { screen: WorldScreen },<br>});</p>
<p>这里的<code>Hi</code>，<code>world</code>会被作为选项卡（Tab）的名字，然后修改MyApp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const MyApp = StackNavigator(&#123;</div><div class="line">  Home: &#123; screen: TabScreen &#125;,</div><div class="line">  User: &#123; screen: UserScreen &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>刷新一下应用，会发现公用的头部是空白的：</p>
<p><img src="https://meowv.github.io/images/8.4.png" alt="PNG"></p>
<p>没关系，我们来添加一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TabScreen.navigationOptions = &#123;</div><div class="line">  title: &apos;这里是Tab&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>和别的导航组件，你也可以丢个按钮进去：</p>
<p><img src="https://meowv.github.io/images/8.5.png" alt="PNG"></p>
<p>最后，我们来写一个可以跳转到UserScreen的按钮(别忘记navigate)：</p>
<pre><code>//HiScreen
const { navigate } = this.props.navigation;
    return (
      &lt;View&gt;
        &lt;Text&gt;Hi&lt;/Text&gt;
        &lt;Button
          onPress={() =&gt; navigate(&apos;User&apos;, { id: &apos;233333333&apos;, name: &apos;nico&apos; })}
          title=&quot;Go&quot;
        /&gt;
      &lt;/View&gt;
    )
</code></pre><p>然后刷新一下看看是否成功吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;导航器&quot;&gt;&lt;a href=&quot;#导航器&quot; class=&quot;headerlink&quot; title=&quot;导航器&quot;&gt;&lt;/a&gt;导航器&lt;/h1&gt;&lt;p&gt;一个应用（普通的那种），总是有好多个界面，只有一个界面的应用怎么能留得住用户呢？（虽然有很多界面的也不一定留得住）&lt;br&gt;所以说，做应用一般不会只做一个页面。我们知道，网页之间可以自由跳转，通过一个&lt;code&gt;&amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;就可以搞定了，但是&lt;br&gt;开发应用不是写网页，React Native中也没有&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;，那当我们需要做界面跳转的时候该怎么办呢？答案是使用&lt;code&gt;Navigator&lt;/code&gt;组件。&lt;br&gt;哈哈，逗你的，在0.42版本前使用&lt;code&gt;Navigator&lt;/code&gt;来实现导航效果没问题，不过呢，自从0.43版本之后React Native将停止维护这个组件了，&lt;br&gt;因为出现了更好用的&lt;code&gt;React Navigation&lt;/code&gt;（半官方）。&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>带你了解ListView及FlatList</title>
    <link href="http://xj8c.cc/2017/07/13/ReactNative-ListView-FlatList/"/>
    <id>http://xj8c.cc/2017/07/13/ReactNative-ListView-FlatList/</id>
    <published>2017-07-13T08:31:08.000Z</published>
    <updated>2017-07-21T03:28:53.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ListView与FlatList"><a href="#ListView与FlatList" class="headerlink" title="ListView与FlatList"></a>ListView与FlatList</h1><p>当你需要给用户在一个页面展示一堆数据的时候，一个一个去渲染对性能来说真的不好，所以我们使用React Native内置的列表<br>来渲染数据。在0.43版本之前，我们一直使用ListView来渲染数据，不过它的性能经常被人吐嘈，社区里也不断提出解决方案。<br>就连Realm都内置了一个性能更好些的ListView。不过自从官方发布了0.43版之后，这种局面应该会离我们远去了，因为官方给出了<br>更好的方案FlatList。不过，ListView虽然老旧了一些，但依然还有学习的必要，所以我们从ListView开始学起<br><a id="more"></a></p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>对于ListView来说，我们需要一个数据源，这样ListView才有渲染视图的原料。这些数据可以放到一个数组里面(从Realm取出的数据可以直接用ListView渲染)，<br>首先定义取值策略，我们一般采用这种方式(上下数据不相等时更新数据)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;);</div></pre></td></tr></table></figure>
<p>然后我们来创建一个数组来储存数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const data = [</div><div class="line">    &#123;</div><div class="line">        id: 1,</div><div class="line">        name: &apos;meow&apos;</div><div class="line">        &#125;,</div><div class="line">    &#123;</div><div class="line">        id: 2,</div><div class="line">        name: &apos;meow2&apos;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        id: 3,</div><div class="line">        name: &apos;meow3&apos;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        id: 4,</div><div class="line">        name: &apos;meow4&apos;</div><div class="line">    &#125;        </div><div class="line">]</div></pre></td></tr></table></figure>
<p>准备好后，我们开始使用ListView，别忘记引用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">  ....,  </div><div class="line">  ListView</div><div class="line">&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>然后随便找个视图丢个ListView进去，然后用刚才初始化好的<code>ds</code>来接受数据并使用renderRow渲染数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ListView</div><div class="line">    dataSource=&#123;ds.cloneWithRows(data)&#125;</div><div class="line">    renderRow=&#123;(rowData) =&gt; &lt;Text&gt;id:&#123;rowData.id&#125;，name：&#123;rowData.name&#125;&lt;/Text&gt;&#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<p>没加任何样式，不过数据愉快的渲染出来了：</p>
<p><img src="https://meowv.github.io/images/7.1.png" alt="PNG"></p>
<p>我们可以用列表渲染文字，图片，在列表里嵌套组件等等，还可以像寻常组件一样为其添加各种样式。因为写样式就像寻常组件一样，所以这里<br>就不再说了。</p>
<p>除了传递<code>rowData</code>，还可以传递<code>sectionID, rowID</code>来获取section id和 row id，如果对这两个参数感兴趣就自己动手做下试验。</p>
<p>再提一个和性能有关的属性<code>initialListSize</code>，这个属性可以指定首屏渲染多少数据，避免造成性能损耗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ListView</div><div class="line">...</div><div class="line">initialListSize=&#123;123&#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<h2 id="FlatList"><a href="#FlatList" class="headerlink" title="FlatList"></a>FlatList</h2><p>FlatList是一个高性能的列表，为什么要使用它我们在开篇介绍已经讲过，下面我们来看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;FlatList</div><div class="line">    data=&#123;data&#125;</div><div class="line">    renderItem=&#123; (&#123; item &#125;) =&gt; &lt;Text&gt;&#123;item.id&#125;&lt;/Text&gt; &#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<p>这里的data是在ListView例子中用过的data，不过呢，这段代码并不能运行，因为FlatList需要每行都有一个不同的key，所以我们<br>需要炮制一下data。至于这个提示，先看前半句：</p>
<p><img src="https://meowv.github.io/images/7.3.png" alt="PNG"></p>
<p>之前在创建data的时候我们用了const，为了后边能够修改data，我们将const改成let。<br>然后写一小段代码为data添加key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (let i = 0; i &lt; data.length; i++) &#123;</div><div class="line">  data[i].key = i</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://meowv.github.io/images/7.2.png" alt="PNG"></p>
<p>然后data就可以丢到FlatList中使用了(使用新组件别忘记引入)。另外，在现在的版本中data只能是一个普通数组，不可以是别的复杂数据结构(为了简单)。</p>
<p>接下来，我们来看FlatList支持的属性。</p>
<p>FlatList默认竖式布局，但是只要设置<code>horizontal</code>属性为true，列表就会变成横的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">horizontal=&#123;true&#125;</div></pre></td></tr></table></figure>
<p>刚才为data添加key的那一步其实并没有必要，因为有<code>keyExtractor</code>属性，我们可以通过这一属性来指定key，拿刚才的data来举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keyExtractor=&#123; (item, index) =&gt; item.id &#125;</div></pre></td></tr></table></figure>
<p>然后是三个比较像的组件<code>ListHeaderComponent</code>，<code>ItemSeparatorComponent</code>，<code>ListFooterComponent</code>，<br>在这三个属性中，我们向其中分别会放头部组件，分隔组件，尾部组件。<br>举一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ListHeaderComponent=&#123;()=&gt;&#123;return &lt;Text&gt;我是头部&lt;/Text&gt;&#125;&#125;</div><div class="line">ItemSeparatorComponent=&#123;()=&gt;&#123;return &lt;Text&gt;我是分隔组件&lt;/Text&gt;&#125;&#125;</div><div class="line">ListFooterComponent=&#123;()=&gt;&#123;return &lt;Text&gt;我是尾部&lt;/Text&gt;&#125;&#125;</div></pre></td></tr></table></figure>
<p><img src="https://meowv.github.io/images/7.4.png" alt="PNG"></p>
<p>实际使用的时候记得把组件单独拿出来，这里这么写只是为了方便。<br>FlatList为了优化内存占用并保证流畅滑动会在屏幕外异步绘制列表内容（看不到的地方用空白代替items），所以如果用户滑动过快就会看到空白内容，<br>对于这个问题，我们可以使用<code>getItemLayout</code>属性来有优化，不过你得知道内容的行高才能用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//xxx是行高</div><div class="line">getItemLayout=&#123;(data, index) =&gt; (</div><div class="line">    &#123; length: xxx, offset: xxx * index, index &#125;</div><div class="line">)&#125;</div></pre></td></tr></table></figure>
<p>介绍的最后一个组件在当前版本（0.43）有点小问题<code>onEndReached</code>有时候会不触发，所以只好期待下一个版本喽</p>
<p><code>onEndReached</code>是当列表滑到尾部会调用的一个属性（距离尾部不足这个<code>onEndReachedThreshold</code>的大小），我们可以用它来更新列表数据什么的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">onEndReached=&#123;()=&gt;&#123;</div><div class="line">//更新数据</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
<p>与<code>onEndReachedThreshold</code>是个好基友，我们在里边放些数字，如果滑动列表就好触发<code>onEndReached</code>的话，我们需要设置<code>onEndReachedThreshold</code>的值<br>为0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onEndReachedThreshold=&#123;0&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ListView与FlatList&quot;&gt;&lt;a href=&quot;#ListView与FlatList&quot; class=&quot;headerlink&quot; title=&quot;ListView与FlatList&quot;&gt;&lt;/a&gt;ListView与FlatList&lt;/h1&gt;&lt;p&gt;当你需要给用户在一个页面展示一堆数据的时候，一个一个去渲染对性能来说真的不好，所以我们使用React Native内置的列表&lt;br&gt;来渲染数据。在0.43版本之前，我们一直使用ListView来渲染数据，不过它的性能经常被人吐嘈，社区里也不断提出解决方案。&lt;br&gt;就连Realm都内置了一个性能更好些的ListView。不过自从官方发布了0.43版之后，这种局面应该会离我们远去了，因为官方给出了&lt;br&gt;更好的方案FlatList。不过，ListView虽然老旧了一些，但依然还有学习的必要，所以我们从ListView开始学起&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>存储：与AsyncStorage相比，Realm更应该作为重点掌握内容</title>
    <link href="http://xj8c.cc/2017/07/12/ReactNative-storage/"/>
    <id>http://xj8c.cc/2017/07/12/ReactNative-storage/</id>
    <published>2017-07-12T08:28:22.000Z</published>
    <updated>2017-07-21T03:30:58.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h1><p>本章提要<br>  1.AsyncStorage<br>  2.Realm<br>一个应用总是要存些东西的，我们要怎么做才能把数据存起来呢？我们这里有两个选择，一个是使用官方提供的AsyncStorage另一个是使用小型数据库。</p>
<p>当数据量不大，结构很简单的时候，我们来使用AsyncStorage这个key-value储存系统，当数据量较大的时候，我们就需要使用小型数据库了，这里我们<br>会学习一个叫做Realm的数据库。<br><a id="more"></a><br>首先，我们来看看AsyncStorage吧~</p>
<h2 id="AsyncStorage"><a href="#AsyncStorage" class="headerlink" title="AsyncStorage"></a>AsyncStorage</h2><p>与数据打交道，免不了对数据进行增加，删除，更改和查找。我们来看看如何用AsyncStorage实现这些。</p>
<p>增加数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">`` </div><div class="line">save(key, value) &#123;</div><div class="line">  AsyncStorage.setItem(key,value).then(</div><div class="line">    (errs)=&gt;&#123;</div><div class="line">      if (!errs) &#123;</div><div class="line">        //xxx</div><div class="line">      &#125;else &#123;</div><div class="line">        //xxx</div><div class="line">      &#125;</div><div class="line">    &#125;)  </div><div class="line">&#125;</div><div class="line">``</div></pre></td></tr></table></figure>
<p>在这里，我们使用了promise，这样会使代码看起来舒服很多。虽然看起来很多，实际上，只要知道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AsyncStorage.setItem(key,value)</div></pre></td></tr></table></figure>
<p>就可以了，我们用<code>setItem</code>来将key和value存储起来，看到这里想必你已经知道了为什么AsyncStorage是key-value系统了。</p>
<p>由于有了key，所以我们可以用key进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">get(key) &#123;</div><div class="line">   AsyncStorage.getItem(key)</div><div class="line">            .then(  </div><div class="line">                (result)=&gt; &#123;   </div><div class="line">                    if (!result) &#123;</div><div class="line">                      //xxx</div><div class="line">                    &#125;</div><div class="line">                    //返回结果</div><div class="line">                &#125;</div><div class="line">            ).catch((error)=&gt; &#123;  </div><div class="line">              //错误处理</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数据我们存完了，但是如果数据没用了怎么办？删掉呗。和查询数据很像，删除也需要用到key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">del(key) &#123;</div><div class="line">   AsyncStorage.removeItem(key).</div><div class="line">            then(</div><div class="line">            ()=&gt;&#123;</div><div class="line">              //删除成功</div><div class="line">            &#125;</div><div class="line">          ).catch((error)=&gt; &#123;  </div><div class="line">              //错误处理</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于修改数据，其实写法和增加数据一样，当你需要修改一项数据的时候，直接传入key和一个新的值就可以了。</p>
<h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><p>前面的AsyncStorage只能存些小东西，数据量一大就开始捉襟见肘了，到了这种时候就该用Realm了。<br>其实用SQLite也行，不过不怎么好用，索性就不用了。当初作者君在用Realm的时候版本号才是0.14转眼间就到1.0.0了，所以请放心的使用Realm吧。</p>
<p>Realm并不是React Native自己就有的，所以我们需要安装Realm：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save realm</div></pre></td></tr></table></figure>
<p>安装好后大概是这样：</p>
<p><img src="https://meowv.github.io/images/6.1.png" alt="PNG">  </p>
<p>然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native link realm</div></pre></td></tr></table></figure>
<p><img src="https://meowv.github.io/images/6.2.png" alt="PNG">  </p>
<p>装完Realm之后得重新构建一下App：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native run-android</div></pre></td></tr></table></figure>
<p><em>Tips：由于网络的问题呢，可能会构建失败，多试几次就可以构建完成了</em></p>
<p>接下来测试一下Realm是不是安装成功了，先是引入Realm：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Realm from &apos;realm&apos;;</div></pre></td></tr></table></figure>
<p>下面是Realm官方文档的例子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">export default class &lt;project-name&gt; extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    let realm = new Realm(&#123;</div><div class="line">     schema: [&#123;name: &apos;Dog&apos;, properties: &#123;name: &apos;string&apos;&#125;&#125;]</div><div class="line">   &#125;);</div><div class="line"></div><div class="line">   realm.write(() =&gt; &#123;</div><div class="line">     realm.create(&apos;Dog&apos;, &#123;name: &apos;Rex&apos;&#125;);</div><div class="line">   &#125;);</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</div><div class="line">          Count of Dogs in Realm: &#123;realm.objects(&apos;Dog&apos;).length&#125;</div><div class="line">        &lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>&lt;project-name&gt;</code>是你的项目名称，别弄错了。然后刷新一下，界面上的数字就会加1。如果程序可以顺利运行，<br>Realm就已经安装好了。</p>
<p>先简单的解释一下上面的代码，首先我们新建了一个叫做Dog的Schema，下面的<code>write</code>是写入数据，组件中的<br><code>realm.objects(&#39;Dog&#39;).length</code>会返回Dog中的数据个数。每次刷新App，都会写入一条数据，所以数字会加一。</p>
<p>有了一个简单的认识之后，让我们来详细的了解Realm吧！</p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>在使用Realm的时候离不开Schema，一个大些的App一般会用到多个Schema，所以在正式使用Realm的时候<br>不能像上面的例子一样敷衍，我们需要进行一个简单的封装。新建一个叫Schema.js文件，它可以在app文件夹下（没有app文件夹就自己新建一个），</p>
<p>在文件头部引入Realm：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import Realm from &apos;realm&apos;;</div></pre></td></tr></table></figure>
<p>然后创建一个叫Todo的class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Todo extends Realm.Object &#123;&#125;</div></pre></td></tr></table></figure>
<p>不喜欢这个名字的话，你可以自己随便起一个名字。</p>
<p>然后来写Schema：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Todo.schema = &#123;</div><div class="line">    name:&apos;Todo&apos;,</div><div class="line">    primaryKey: &apos;id&apos;,</div><div class="line">    properties: &#123;</div><div class="line">        title: &#123;type: &apos;string&apos;&#125;,</div><div class="line">        id: &#123;type: &apos;string&apos;, indexed: true&#125;,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们用id来作为主键，由于这个id具有唯一性，我们一会儿会写一个小程序来生成id。 </p>
<p>然后导出模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export default new Realm(&#123;schema: [Todo]&#125;)</div><div class="line">``` </div><div class="line"></div><div class="line">如果你需要多个Schema，在后面加上就好：</div></pre></td></tr></table></figure>
<p>export default new Realm({schema: [Todo, Category, xxx, xxx]})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后在你需要使用储存的地方引入Schema.js。</div><div class="line"></div><div class="line">比如这样引入：</div></pre></td></tr></table></figure></p>
<p>import realm from ‘./Schema’;<br>//注意文件位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后写一个生成id(为了不生成重复的id，我们使用guid，别管这是啥，只要知道这东西一般不会重复就好了)的函数：</div></pre></td></tr></table></figure></p>
<p>const guid = () =&gt; {<br>  return ‘xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx’<br>    .replace(/[xy]/g, (c) =&gt; {<br>      var r = Math.random() * 16 | 0, v = c == ‘x’ ? r : (r &amp; 0x3 | 0x8);<br>      return v.toString(16);<br>    });<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">接下来，我们来看如何去用Realm（也就是增删改查）。</div><div class="line"></div><div class="line">我们来写一个输入框来收集数据：</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">![PNG](https://meowv.github.io/images/6.4.png)  </div><div class="line"></div><div class="line">不出意外的话，下边会有一个黄色的提示（前边的章节有说过），先不要管它，我们一会儿解决。</div><div class="line">为了储存数据，我们需要把输入的文字放到state里面，上面的`onChangeText`就是干这个的，对了，别忘记加一个叫title的状态：</div></pre></td></tr></table></figure>
<p>constructor(props){<br>      super(props);<br>      this.state = {<br>        text: null<br>      };<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Ok，搞定这些后我们来写一个写入数据的方法，我们起名叫write，write应该写在constructor下边：</div></pre></td></tr></table></figure></p>
<p>write(){<br>      realm.write(()=&gt;{<br>        realm.create(‘Todo’,{ title: this.state.title, id: guid() });<br>      });<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">写入数据需要用到`realm.write()`和`realm.create()`，Todo是Schema，后边跟着的是要写入的数据，title是从</div><div class="line">state中取出来的，然后我们调用`guid()`来生成一个不重复的id。</div><div class="line">接下来把这个方法绑到按钮上，实现点击添加数据：</div></pre></td></tr></table></figure></p>
<p><button title="添加" onpress="{" ()=""> this.write() }/&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">别忘记写this哦，write是内部的方法，不用this会引用不到的。</div><div class="line"></div><div class="line">我们可以在下边写一个文本来显示Todo中数据的条数，就和上面的例子一样，我们在Button下面写个换行符：</div></pre></td></tr></table></figure></button></p>
<p><text>{‘\n’}</text><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后把数据放到state里：</div></pre></td></tr></table></figure></p>
<p>this.state = {<br>  text: null,<br>  data: realm.objects(‘Todo’)<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在换行符下面继续写：</div></pre></td></tr></table></figure></p>
<p><text>{ this.state.data.length }</text><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后才是重点，Realm是可以使数据实时更新的，只要增加一个监听就好了，我们把这个监听写在构造里面：</div></pre></td></tr></table></figure></p>
<p>this.state = {…}<br>realm.addListener(‘change’, () =&gt; {<br>  this.forceUpdate()<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后输入一个数据，保存，下面的数字就可以实时的变化了~</div><div class="line"></div><div class="line">然后我们来看查询是怎样的，界面的话把上面的代码复制过去，改几个字就好：</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后把find放到state里，正如我们之前做过的一样：</div></pre></td></tr></table></figure>
<p>this.state = {<br>  text: null,<br>  find: null,<br>  data: realm.objects(‘Todo’)<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后我们写一个叫find的方法,这个方法稍稍有些复杂：</div></pre></td></tr></table></figure></p>
<p>find () {<br>  realm.objects(‘Todo’)<br>      .filtered(‘title = ‘ + ‘“‘ + this.state.find + ‘“‘)<br>      .forEach(result =&gt; ToastAndroid.show(result.id, ToastAndroid.SHORT));<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们借助了一个叫做`ToastAndroid`的组件来实现显示查找结果的id，所以别忘记引入这个组件。</div><div class="line">`filtered`是一个过滤器，我们在里面写查询代码，注意喽，查询的值应该是一个字符串所以在外面包裹了双引号。</div><div class="line">由于返回的结果稍稍有些复杂，所以我们用`forEach`来处理一下，使其获得id。</div><div class="line"></div><div class="line">效果应该是这个样子的：</div><div class="line"></div><div class="line">![PNG](https://meowv.github.io/images/6.5.png)  </div><div class="line"></div><div class="line">至于修改和删除就很简单了，所以这里只给出核心代码，作者君知道你很聪明，所以来想想具体怎么用把~</div><div class="line"></div><div class="line">修改：</div></pre></td></tr></table></figure></p>
<p>realm.write(() =&gt; {<br>  realm.create(‘Todo’, { id: xxx, title: xxx }, true);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">删除：</div></pre></td></tr></table></figure></p>
<p>realm.write(() =&gt; {<br>  const todo = realm.objects(‘Todo.filtered(‘id = xxxxx’);<br>  realm.delete(todo);<br>});<br>```</p>
<p>小提示：</p>
<p>唔？ID真的没有用吗？具体可以起到什么作用呢？</p>
<p>想明白这两点，修改和删除就没问题了。另外，有没有发现修改，增加，删除都是在write中进行的呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;储存&quot;&gt;&lt;a href=&quot;#储存&quot; class=&quot;headerlink&quot; title=&quot;储存&quot;&gt;&lt;/a&gt;储存&lt;/h1&gt;&lt;p&gt;本章提要&lt;br&gt;  1.AsyncStorage&lt;br&gt;  2.Realm&lt;br&gt;一个应用总是要存些东西的，我们要怎么做才能把数据存起来呢？我们这里有两个选择，一个是使用官方提供的AsyncStorage另一个是使用小型数据库。&lt;/p&gt;
&lt;p&gt;当数据量不大，结构很简单的时候，我们来使用AsyncStorage这个key-value储存系统，当数据量较大的时候，我们就需要使用小型数据库了，这里我们&lt;br&gt;会学习一个叫做Realm的数据库。&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>React Native中的样式，Flexbox布局及其他内容</title>
    <link href="http://xj8c.cc/2017/07/11/ReactNative-style-layout/"/>
    <id>http://xj8c.cc/2017/07/11/ReactNative-style-layout/</id>
    <published>2017-07-11T08:25:59.000Z</published>
    <updated>2017-07-21T03:29:22.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="是时候说说样式与布局了"><a href="#是时候说说样式与布局了" class="headerlink" title="是时候说说样式与布局了"></a>是时候说说样式与布局了</h1><p>本章提要</p>
<ul>
<li>样式</li>
<li>布局</li>
<li>Dimensions</li>
</ul>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>在前几章说了一些样式，是不是有点懵了呢？没关系，我们一起看看样式在React Native中的使用。</p>
<p>在React Native中，写样式和写CSS差不多，只不过是把<code>-</code>的连接方式换成了小驼峰式。又把<code>;</code>换成了<code>,</code>，有的时候要把值加上分号，比如这样：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">background-color: green; ---&gt;  backgroundColor: &apos;green&apos;,</div></pre></td></tr></table></figure></p>
<p>实际上，React Native的样式算是CSS的一个子集，当发现有些样式不能用的话不要惊讶，试着换用别的方式来实现就好~</p>
<p>作者君总结了一些常用的样式放到了附录里，可以作为写样式时的参考。</p>
<p>我们知道，代码总是会越写越多，样式也一样。所以为了效率，为了样式的整洁，我们写样式用<code>StyleSheet.create</code>比较好，不过只是写着玩玩的话，<br>怎么写都好。下面我们来看看这种定义样式的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    content: &#123;</div><div class="line">        backgroundColor: &apos;#fff&apos;,</div><div class="line">        height: 50,</div><div class="line">        width: 100</div><div class="line">    &#125;,</div><div class="line">    text: &#123;</div><div class="line">        color: &apos;blue&apos;,</div><div class="line">        textAlign: &apos;center&apos;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后在组件中这样使用即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;styles.content&#125;&gt;</div><div class="line">    &lt;Text style=&#123;styles.text&#125;&gt;哈，我是小整洁&lt;/Text&gt;</div><div class="line">    .....</div><div class="line">&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>这样写后，你的代码可读性会提高不少，毕竟样式都像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;&#123; fontStyle:&apos;italic&apos;, fontSize: 20,... &#125;&#125;</div></pre></td></tr></table></figure>
<p>就会变得乱糟糟一团团了。</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h3><p>在React Native中，你可以愉快的使用Flexbox布局，完全不用考虑兼容性（放心，绝对不需要考虑IE6）,<br>如果在浏览器端写过的话，在React Native上继续写这种布局会很是得心应手的。如果没接触过也没关系，这里会很详细的讲的（毕竟很重要）。</p>
<p>首先，我们先瞅瞅Flexbox布局需要用到什么样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex, flexDiretion, justifyCotent, alignItems, alignSelf, flexWrap, flexShrink, flexGrow</div></pre></td></tr></table></figure>
<p>嗯，先把这些列在这里，有个大概印象就成，我们一会儿再说。</p>
<p>对于Flexbox来说，有一个很重要的概念————轴。理解了轴的概念，使用Flexbox也不会有什么问题了。</p>
<p>对于一个平面来说，它有两个轴，横轴和纵轴，就是下面这样： </p>
<p><img src="https://meowv.github.io/images/5.1.png" alt="PNG">  </p>
<p>Flexbox用操作这两个轴的方式来完成布局，不过不叫横纵而是叫主次。</p>
<p>当横轴为主轴时，次轴是纵轴：</p>
<p><img src="https://meowv.github.io/images/5.2.png" alt="PNG">  </p>
<p>当纵轴为主轴时，次轴是横轴：</p>
<p><img src="https://meowv.github.io/images/5.3.png" alt="PNG">  </p>
<p>看完预备知识，我们可以看看Flexbox是怎么用的了。</p>
<p>首先，要有一个flex容器，如果不指定高度和宽度，它会占满能够占领的最大空间，如果给了高度和宽度，那么会占满你给它的空间。</p>
<p>我们用<code>flex</code>告诉React Native说这是一个使用了弹性布局的组件，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;&#123; flex:1 &#125;&#125;&gt;&lt;/View&gt;</div></pre></td></tr></table></figure></p>
<p>flex后面的数字可以简单的理解为比例</p>
<p>不过呢，我们一般不会只写个<code>flex: 1</code>，我们还得写一些别的东西，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;&#123; flex: 1, flexDirection: &apos;column&apos;, justifyContent:&apos;center&apos;, alignItems:&apos;flex-end&apos; &#125;&#125;&gt;</div><div class="line">&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>除了<code>flex: 1</code>，剩下的其实就是用来操作横纵轴的。<br>用<code>flexDirection</code>声明主轴是纵轴，次轴是横轴，用<code>justifyContent</code>声明元素处在主轴的中心位置，用<code>alignItems</code>声明元素处在<br>次轴的末尾。</p>
<p>我们在<code>View</code>容器里填充一些元素进去，就可以很直观的看到效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;&#123; flex: 1, flexDirection: &apos;column&apos;, justifyContent:&apos;center&apos;, alignItems:&apos;flex-end&apos; &#125;&#125;&gt;</div><div class="line">    &lt;Text style=&#123;&#123; backgroundColor:&apos;blue&apos;&#125;&#125; &gt;1&lt;/Text&gt;</div><div class="line">    &lt;Text style=&#123;&#123; backgroundColor:&apos;red&apos; &#125;&#125;&gt;2&lt;/Text&gt;</div><div class="line">    &lt;Text style=&#123;&#123; backgroundColor:&apos;green&apos; &#125;&#125;&gt;3&lt;/Text&gt;</div><div class="line">&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>效果是这样（虽然比较建议你自己敲一下代码，但是还是把图放在这里比较好）：</p>
<p><img src="https://meowv.github.io/images/5.4.png" alt="PNG">  </p>
<p>至于为啥这个图看起来有些大，是因为作者君把整个模拟器的屏幕截过来了，毕竟要突出元素在主轴中间的效果嘛。</p>
<p>这些还不是全部，毕竟不可能每个整体都是统一的，内部总是要有些不一样的。拿上面的那个例子来说：如果我不想让每个元素都在次轴的末尾，那<br>该怎么办呢？ 很简单，这个时候我们就可以使用<code>alignSelf</code>了。<code>alignSelf</code>可以使容器里的元素和父样式不一样，我们来简单的改造一下上面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;&#123; backgroundColor:&apos;green&apos;, alignSelf:&apos;flex-start&apos; &#125;&#125;&gt;3&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>这样就可以使第三个<code>Text</code>在前面了。就像这样：</p>
<p><img src="https://meowv.github.io/images/5.5.png" alt="PNG">  </p>
<p>我们再说回<code>flex</code>。我们知道，<code>flex</code>后面是接数字的，数字是这个容器所占的比例，也就是说，后面的数字越大，容器所占比例也就越大。</p>
<p>不过，如果只有<code>flex: 1</code>的话，它会自己占领所有地盘，谁叫没有其它的容器和它抢地盘呢。</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>对于一个App来说，不可能只用到Flexbox，还得用到其他的布局方式。</p>
<p>首先来看绝对布局absolute，绝对布局这名字听起来挺霸气的，实际上也确实霸气，规定元素在那里，那元素就得在那里待着。<br>我们使用<code>top,bottom,left,right</code>来声明元素的上下左右距容器有多少距离，从而将元素定在那个位置。我们在用绝对布局的时候<br>需要告诉元素它的布局方式是绝对布局，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;&#123; position: &apos;absolute&apos;, width: 50, height: 50 &#125;&#125;&gt;&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>只不过我们得事先声明元素的宽度和高度，不然样式会变得很奇怪，然后来定位元素的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;&#123; position: &apos;absolute&apos;, width:50, height: 50, bottom: 20, left:10 &#125;&#125;&gt;233&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>就像这样：</p>
<p><img src="https://meowv.github.io/images/5.6.png" alt="PNG">  </p>
<p>还有一点得注意，我们需要给父容器一个合适的高度和宽度，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;&#123; height:500,width:500 &#125;&#125;&gt;</div><div class="line">    &lt;Text style=&#123;&#123; position: &apos;absolute&apos;, bottom: 20, left:10, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt;</div><div class="line">    &lt;Text style=&#123;&#123; position: &apos;absolute&apos;, bottom: 20, left:80, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt;</div><div class="line">&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>既然有绝对布局，就有相对布局，只不过可能会有些难用。你可以把相对布局理解成一个流，只不过<code>bottom,right</code>不能用。<br>可以使用<code>top,left</code>更改元素在流中的上，左偏移大小（top,left初始值为0）。下面是个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;&#123;height:500,width:500&#125;&#125;&gt;</div><div class="line">    &lt;Text style=&#123;&#123; position: &apos;relative&apos;,  left:10, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt;</div><div class="line">    &lt;Text style=&#123;&#123; position: &apos;relative&apos;,  left:60, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt;</div><div class="line">    &lt;Text style=&#123;&#123; position: &apos;relative&apos;,  left:120, width:50, height: 50 &#125;&#125;&gt;233&lt;/Text&gt;</div><div class="line">&lt;/View&gt;</div></pre></td></tr></table></figure>
<p><img src="https://meowv.github.io/images/5.7.png" alt="PNG"> </p>
<h2 id="Dimensions"><a href="#Dimensions" class="headerlink" title="Dimensions"></a>Dimensions</h2><p>在React Native中，我们不能用<code>width: 60%</code>之类的方式来进行布局，那该怎么办嘞？嗯，我们可以换个方式，那就是<code>Dimensions</code>，<br>我们来请Dimensions出场：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">  Dimensions</div><div class="line">&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>然后获取宽度和高度，这里我们用解构赋值的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const &#123; width, height &#125; = Dimensions.get(&quot;window&quot;);</div></pre></td></tr></table></figure>
<p>然后就可以在样式中使用喽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;&#123; width: width * 0.5 ,height: height * 0.5 &#125;&#125;&gt;&lt;/View&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;是时候说说样式与布局了&quot;&gt;&lt;a href=&quot;#是时候说说样式与布局了&quot; class=&quot;headerlink&quot; title=&quot;是时候说说样式与布局了&quot;&gt;&lt;/a&gt;是时候说说样式与布局了&lt;/h1&gt;&lt;p&gt;本章提要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;样式&lt;/li&gt;
&lt;li&gt;布局&lt;/li&gt;
&lt;li&gt;Dimensions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;样式&quot;&gt;&lt;a href=&quot;#样式&quot; class=&quot;headerlink&quot; title=&quot;样式&quot;&gt;&lt;/a&gt;样式&lt;/h2&gt;&lt;p&gt;在前几章说了一些样式，是不是有点懵了呢？没关系，我们一起看看样式在React Native中的使用。&lt;/p&gt;
&lt;p&gt;在React Native中，写样式和写CSS差不多，只不过是把&lt;code&gt;-&lt;/code&gt;的连接方式换成了小驼峰式。又把&lt;code&gt;;&lt;/code&gt;换成了&lt;code&gt;,&lt;/code&gt;，有的时候要把值加上分号，比如这样：&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>React Native常用的组件</title>
    <link href="http://xj8c.cc/2017/07/10/ReactNative-module/"/>
    <id>http://xj8c.cc/2017/07/10/ReactNative-module/</id>
    <published>2017-07-10T08:24:39.000Z</published>
    <updated>2017-07-21T03:29:16.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些一定要知道的组件"><a href="#一些一定要知道的组件" class="headerlink" title="一些一定要知道的组件"></a>一些一定要知道的组件</h1><p>本章提要</p>
<ul>
<li>View组件</li>
<li>Text组件</li>
<li>Button组件</li>
<li>Image组件</li>
<li>第三方组件</li>
</ul>
<p>很多组件是开发应用的基石，如果没有这些组件，那么是写不出来一个应用的，在这一章，我们来学习一些一定要知道的组件。<br><a id="more"></a><br>在使用组件的时候，忘记引入组件是不行的，我们来看一下怎么引入组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Button,</div><div class="line">  ...其它的组件名字</div><div class="line">&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure>
<p>这样就可以依次引入Text，View和Button组件了~</p>
<h2 id="View组件"><a href="#View组件" class="headerlink" title="View组件"></a>View组件</h2><p>这么说吧，第一个就介绍View组件是有原因的。View组件可是最最基础的组件，我们经常需要拿View组件当容器使用~<br>View自己没有固定的样式，我们需要自己为它定义样式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;&#123; backgroundColor:&apos;green&apos;, height:50, width:50 &#125;&#125;&gt;&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>这样，在屏幕上便可以出现一个绿色的，边长为50dp的正方形</p>
<p><img src="https://meowv.github.io/images/4.1.png" alt="PNG"> </p>
<p>样式什么的，我们会在下一章讲到，在这里简单看看就好。</p>
<h2 id="Text组件"><a href="#Text组件" class="headerlink" title="Text组件"></a>Text组件</h2><p>一般来说，一个应用总是离不开文字的，在React Native中，文字外面需要套上Text组件才可以，<br>我们可以通过Text组件控制文字大小及颜色，文字行数，还可以通过点击Text组件来触发一些动作（函数）。<br>栗子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Text numberOfLines=&#123; 1 &#125; style=&#123;&#123; fontSize:20, color:&apos;green&apos; &#125;&#125;&gt;</div><div class="line">略略略,略略略略略略，略略略略略略略略略，略略略略略略略略略略略略</div><div class="line">&lt;/Text&gt;</div></pre></td></tr></table></figure>
<p>我们通过numberOfLines来控制行数，超过设定的行数便会在设定好的最后一行显示省略号。通过fontSize和color设定了文字的<br>大小及颜色。效果如下：</p>
<p><img src="https://meowv.github.io/images/4.2.png" alt="PNG"> </p>
<h2 id="Button组件"><a href="#Button组件" class="headerlink" title="Button组件"></a>Button组件</h2><p>Button组件大概是在0.37版加入的，在那之前按钮什么的要自己写，如果对官方出的这个不满意的话，那就自己写或找一些第三方组件吧~<br>我们写两个按钮当作栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;View&gt;</div><div class="line">    &lt;Button color=&quot;green&quot; title=&quot;我是一个正常的按钮&quot;/&gt;</div><div class="line">    &lt;Button  disabled=&#123;true&#125; title=&quot;我是一个不可用的按钮&quot;/&gt;</div><div class="line">&lt;/View&gt;</div></pre></td></tr></table></figure>
<p><img src="https://meowv.github.io/images/4.3.png" alt="PNG"> </p>
<p>由于写了两个组件，所以要在外面包裹一层容器，这里我们用View。这两个按钮一个是<br>正常状态，一个是不可用状态，我们通过控制disabled属性来控制是否可用(默认false)。按钮中的文字写在title里，color属性可以控制颜色。<br>由于按钮需要和onPress一起用，所以会有一个这样的警告：</p>
<p><img src="https://meowv.github.io/images/4.4.png" alt="PNG"> </p>
<p>不过暂时没什么问题，咱先不用管，以后用到的时候再写~</p>
<h2 id="Image组件"><a href="#Image组件" class="headerlink" title="Image组件"></a>Image组件</h2><p>在以前，用React Native引用组件总是很坑，不过现在比以前好多了。由于作者君木有苹果电脑，所以不怎么清楚IOS版是怎么用的，<br>我们就只说安卓的吧。<br>图片的来源有两种，一种是本地图片，一种是网络图片，这两种图片在引入的时候稍稍有些差别，我们先看引入本地图片的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Image source=&#123;require(&apos;./images/avatar.png&apos;)&#125; style=&#123;&#123; height:50, width:50 &#125;&#125; /&gt;</div></pre></td></tr></table></figure>
<p>我们在项目根目录创建一个叫images的文件夹，并在里面放一个叫avatar的图片。然后require图片地址，<br>使用图片组件要给它宽和高，不然无法正常显示。还有，如果图片没显示的话，记得重新执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native run-android</div></pre></td></tr></table></figure>
<p>然后是网络图片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Image source=&#123;&#123;uri: &apos;http://qiniu.com/xxx/png&#125;&#125; style=&#123;&#123; height:50, width:50 &#125;&#125; /&gt;</div></pre></td></tr></table></figure>
<p>在使用网络图片的时候，要将require改成uri，而且不写高度和宽度也没问题~</p>
<h2 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h2><p>当你觉得官方组件有限，自己写又心好累，这时该怎么办呢？</p>
<p>当然是使用第三方组件啦~React Native社区越来越大，我们可以用的组件也越來越多，在这里，<br>作者君推荐两个搜索组件的地方：</p>
<ul>
<li>js.coach(<a href="https://js.coach/react-native" target="_blank" rel="external">https://js.coach/react-native</a>)</li>
<li>GitHub(<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a>)</li>
</ul>
<p>其实js.coach的组件来源也是GitHub 23333</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一些一定要知道的组件&quot;&gt;&lt;a href=&quot;#一些一定要知道的组件&quot; class=&quot;headerlink&quot; title=&quot;一些一定要知道的组件&quot;&gt;&lt;/a&gt;一些一定要知道的组件&lt;/h1&gt;&lt;p&gt;本章提要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View组件&lt;/li&gt;
&lt;li&gt;Text组件&lt;/li&gt;
&lt;li&gt;Button组件&lt;/li&gt;
&lt;li&gt;Image组件&lt;/li&gt;
&lt;li&gt;第三方组件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多组件是开发应用的基石，如果没有这些组件，那么是写不出来一个应用的，在这一章，我们来学习一些一定要知道的组件。&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://xj8c.cc/tags/ReactNative/"/>
    
  </entry>
  
</feed>
